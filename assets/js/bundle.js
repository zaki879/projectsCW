/*! For license information please see bundle.js.LICENSE.txt */
( () => {
  "use strict";
  function e() {
      return e = Object.assign ? Object.assign.bind() : function(e) {
          for (var t = 1; t < arguments.length; t++) {
              var i = arguments[t];
              for (var n in i)
                  Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
          }
          return e
      }
      ,
      e.apply(this, arguments)
  }
  class t {
      constructor() {
          this._events = {}
      }
      on(e, t, i) {
          void 0 === i && (i = {}),
          this._events[e] || (this._events[e] = []),
          this._events[e].push({
              callback: t,
              options: i
          })
      }
      off(e, t) {
          this._events[e] = t ? this._events[e].filter((e => e.callback !== t)) : []
      }
      trigger(e) {
          this._events[e] && this._events[e].forEach((t => {
              t.callback.call(this, ...[].slice.call(arguments, 1)),
              t.options.once && this.off(e, t.callback)
          }
          ))
      }
  }
  class i extends t {
      constructor(e, t, i) {
          super(),
          this.app = e,
          this.el = t,
          this.options = i,
          this._namespace = null,
          this._executors = {}
      }
      onInit() {
          return Promise.resolve()
      }
      onRefresh() {
          return Promise.resolve()
      }
      onEnter() {
          return Promise.resolve()
      }
      onComplete() {
          return Promise.resolve()
      }
      onLeave() {
          return Promise.resolve()
      }
      onDestroy() {
          return Promise.resolve()
      }
      onLoaded() {
          return Promise.resolve()
      }
  }
  const n = navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")
    , r = function(e, t, i) {
      if (void 0 === i && (i = window.location.host),
      "A" !== e.tagName || !e.href || e.host !== i)
          return !1;
      if (e.getAttribute("target") || e.hasAttribute("download"))
          return !1;
      if (t) {
          const i = e.href.match(t);
          if (!i || i[1])
              return !1
      }
      return !0
  };
  function s(e) {
      if (void 0 === e)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e
  }
  function a(e, t) {
      e.prototype = Object.create(t.prototype),
      e.prototype.constructor = e,
      e.__proto__ = t
  }
  var o, l, c, u, h, d, p, f, m, g, v, _, y, x, S = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
          lineHeight: ""
      }
  }, E = {
      duration: .5,
      overwrite: !1,
      delay: 0
  }, M = 1e8, b = 1e-8, T = 2 * Math.PI, w = T / 4, D = 0, C = Math.sqrt, A = Math.cos, P = Math.sin, R = function(e) {
      return "string" == typeof e
  }, L = function(e) {
      return "function" == typeof e
  }, I = function(e) {
      return "number" == typeof e
  }, N = function(e) {
      return void 0 === e
  }, F = function(e) {
      return "object" == typeof e
  }, O = function(e) {
      return !1 !== e
  }, U = function() {
      return "undefined" != typeof window
  }, B = function(e) {
      return L(e) || R(e)
  }, z = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
  , k = Array.isArray, V = /(?:-?\.?\d|\.)+/gi, H = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, G = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, W = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, X = /[+-]=-?[.\d]+/, q = /[^,'"\[\]\s]+/gi, j = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Y = {}, K = {}, Z = function(e) {
      return (K = Te(e, Y)) && Ti
  }, $ = function(e, t) {
      return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
  }, J = function(e, t) {
      return !t && console.warn(e)
  }, Q = function(e, t) {
      return e && (Y[e] = t) && K && (K[e] = t) || Y
  }, ee = function() {
      return 0
  }, te = {
      suppressEvents: !0,
      isStart: !0,
      kill: !1
  }, ie = {
      suppressEvents: !0,
      kill: !1
  }, ne = {
      suppressEvents: !0
  }, re = {}, se = [], ae = {}, oe = {}, le = {}, ce = 30, ue = [], he = "", de = function(e) {
      var t, i, n = e[0];
      if (F(n) || L(n) || (e = [e]),
      !(t = (n._gsap || {}).harness)) {
          for (i = ue.length; i-- && !ue[i].targetTest(n); )
              ;
          t = ue[i]
      }
      for (i = e.length; i--; )
          e[i] && (e[i]._gsap || (e[i]._gsap = new zt(e[i],t))) || e.splice(i, 1);
      return e
  }, pe = function(e) {
      return e._gsap || de(it(e))[0]._gsap
  }, fe = function(e, t, i) {
      return (i = e[t]) && L(i) ? e[t]() : N(i) && e.getAttribute && e.getAttribute(t) || i
  }, me = function(e, t) {
      return (e = e.split(",")).forEach(t) || e
  }, ge = function(e) {
      return Math.round(1e5 * e) / 1e5 || 0
  }, ve = function(e) {
      return Math.round(1e7 * e) / 1e7 || 0
  }, _e = function(e, t) {
      var i = t.charAt(0)
        , n = parseFloat(t.substr(2));
      return e = parseFloat(e),
      "+" === i ? e + n : "-" === i ? e - n : "*" === i ? e * n : e / n
  }, ye = function(e, t) {
      for (var i = t.length, n = 0; e.indexOf(t[n]) < 0 && ++n < i; )
          ;
      return n < i
  }, xe = function() {
      var e, t, i = se.length, n = se.slice(0);
      for (ae = {},
      se.length = 0,
      e = 0; e < i; e++)
          (t = n[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
  }, Se = function(e, t, i, n) {
      se.length && !l && xe(),
      e.render(t, i, n || l && t < 0 && (e._initted || e._startAt)),
      se.length && !l && xe()
  }, Ee = function(e) {
      var t = parseFloat(e);
      return (t || 0 === t) && (e + "").match(q).length < 2 ? t : R(e) ? e.trim() : e
  }, Me = function(e) {
      return e
  }, be = function(e, t) {
      for (var i in t)
          i in e || (e[i] = t[i]);
      return e
  }, Te = function(e, t) {
      for (var i in t)
          e[i] = t[i];
      return e
  }, we = function e(t, i) {
      for (var n in i)
          "__proto__" !== n && "constructor" !== n && "prototype" !== n && (t[n] = F(i[n]) ? e(t[n] || (t[n] = {}), i[n]) : i[n]);
      return t
  }, De = function(e, t) {
      var i, n = {};
      for (i in e)
          i in t || (n[i] = e[i]);
      return n
  }, Ce = function(e) {
      var t, i = e.parent || u, n = e.keyframes ? (t = k(e.keyframes),
      function(e, i) {
          for (var n in i)
              n in e || "duration" === n && t || "ease" === n || (e[n] = i[n])
      }
      ) : be;
      if (O(e.inherit))
          for (; i; )
              n(e, i.vars.defaults),
              i = i.parent || i._dp;
      return e
  }, Ae = function(e, t, i, n, r) {
      void 0 === i && (i = "_first"),
      void 0 === n && (n = "_last");
      var s, a = e[n];
      if (r)
          for (s = t[r]; a && a[r] > s; )
              a = a._prev;
      return a ? (t._next = a._next,
      a._next = t) : (t._next = e[i],
      e[i] = t),
      t._next ? t._next._prev = t : e[n] = t,
      t._prev = a,
      t.parent = t._dp = e,
      t
  }, Pe = function(e, t, i, n) {
      void 0 === i && (i = "_first"),
      void 0 === n && (n = "_last");
      var r = t._prev
        , s = t._next;
      r ? r._next = s : e[i] === t && (e[i] = s),
      s ? s._prev = r : e[n] === t && (e[n] = r),
      t._next = t._prev = t.parent = null
  }, Re = function(e, t) {
      e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
      e._act = 0
  }, Le = function(e, t) {
      if (e && (!t || t._end > e._dur || t._start < 0))
          for (var i = e; i; )
              i._dirty = 1,
              i = i.parent;
      return e
  }, Ie = function(e, t, i, n) {
      return e._startAt && (l ? e._startAt.revert(ie) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, n))
  }, Ne = function e(t) {
      return !t || t._ts && e(t.parent)
  }, Fe = function(e) {
      return e._repeat ? Oe(e._tTime, e = e.duration() + e._rDelay) * e : 0
  }, Oe = function(e, t) {
      var i = Math.floor(e /= t);
      return e && i === e ? i - 1 : i
  }, Ue = function(e, t) {
      return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
  }, Be = function(e) {
      return e._end = ve(e._start + (e._tDur / Math.abs(e._ts || e._rts || b) || 0))
  }, ze = function(e, t) {
      var i = e._dp;
      return i && i.smoothChildTiming && e._ts && (e._start = ve(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
      Be(e),
      i._dirty || Le(i, e)),
      e
  }, ke = function(e, t) {
      var i;
      if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = Ue(e.rawTime(), t),
      (!t._dur || Je(0, t.totalDuration(), i) - t._tTime > b) && t.render(i, !0)),
      Le(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
          if (e._dur < e.duration())
              for (i = e; i._dp; )
                  i.rawTime() >= 0 && i.totalTime(i._tTime),
                  i = i._dp;
          e._zTime = -1e-8
      }
  }, Ve = function(e, t, i, n) {
      return t.parent && Re(t),
      t._start = ve((I(i) ? i : i || e !== u ? Ke(e, i, t) : e._time) + t._delay),
      t._end = ve(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
      Ae(e, t, "_first", "_last", e._sort ? "_start" : 0),
      Xe(t) || (e._recent = t),
      n || ke(e, t),
      e._ts < 0 && ze(e, e._tTime),
      e
  }, He = function(e, t) {
      return (Y.ScrollTrigger || $("scrollTrigger", t)) && Y.ScrollTrigger.create(t, e)
  }, Ge = function(e, t, i, n, r) {
      return jt(e, t, r),
      e._initted ? !i && e._pt && !l && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && m !== wt.frame ? (se.push(e),
      e._lazy = [r, n],
      1) : void 0 : 1
  }, We = function e(t) {
      var i = t.parent;
      return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || e(i))
  }, Xe = function(e) {
      var t = e.data;
      return "isFromStart" === t || "isStart" === t
  }, qe = function(e, t, i, n) {
      var r = e._repeat
        , s = ve(t) || 0
        , a = e._tTime / e._tDur;
      return a && !n && (e._time *= s / e._dur),
      e._dur = s,
      e._tDur = r ? r < 0 ? 1e10 : ve(s * (r + 1) + e._rDelay * r) : s,
      a > 0 && !n && ze(e, e._tTime = e._tDur * a),
      e.parent && Be(e),
      i || Le(e.parent, e),
      e
  }, je = function(e) {
      return e instanceof Vt ? Le(e) : qe(e, e._dur)
  }, Ye = {
      _start: 0,
      endTime: ee,
      totalDuration: ee
  }, Ke = function e(t, i, n) {
      var r, s, a, o = t.labels, l = t._recent || Ye, c = t.duration() >= M ? l.endTime(!1) : t._dur;
      return R(i) && (isNaN(i) || i in o) ? (s = i.charAt(0),
      a = "%" === i.substr(-1),
      r = i.indexOf("="),
      "<" === s || ">" === s ? (r >= 0 && (i = i.replace(/=/, "")),
      ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(i.substr(1)) || 0) * (a ? (r < 0 ? l : n).totalDuration() / 100 : 1)) : r < 0 ? (i in o || (o[i] = c),
      o[i]) : (s = parseFloat(i.charAt(r - 1) + i.substr(r + 1)),
      a && n && (s = s / 100 * (k(n) ? n[0] : n).totalDuration()),
      r > 1 ? e(t, i.substr(0, r - 1), n) + s : c + s)) : null == i ? c : +i
  }, Ze = function(e, t, i) {
      var n, r, s = I(t[1]), a = (s ? 2 : 1) + (e < 2 ? 0 : 1), o = t[a];
      if (s && (o.duration = t[1]),
      o.parent = i,
      e) {
          for (n = o,
          r = i; r && !("immediateRender"in n); )
              n = r.vars.defaults || {},
              r = O(r.vars.inherit) && r.parent;
          o.immediateRender = O(n.immediateRender),
          e < 2 ? o.runBackwards = 1 : o.startAt = t[a - 1]
      }
      return new Jt(t[0],o,t[a + 1])
  }, $e = function(e, t) {
      return e || 0 === e ? t(e) : t
  }, Je = function(e, t, i) {
      return i < e ? e : i > t ? t : i
  }, Qe = function(e, t) {
      return R(e) && (t = j.exec(e)) ? t[1] : ""
  }, et = [].slice, tt = function(e, t) {
      return e && F(e) && "length"in e && (!t && !e.length || e.length - 1 in e && F(e[0])) && !e.nodeType && e !== h
  }, it = function(e, t, i) {
      return c && !t && c.selector ? c.selector(e) : !R(e) || i || !d && Dt() ? k(e) ? function(e, t, i) {
          return void 0 === i && (i = []),
          e.forEach((function(e) {
              var n;
              return R(e) && !t || tt(e, 1) ? (n = i).push.apply(n, it(e)) : i.push(e)
          }
          )) || i
      }(e, i) : tt(e) ? et.call(e, 0) : e ? [e] : [] : et.call((t || p).querySelectorAll(e), 0)
  }, nt = function(e) {
      return e = it(e)[0] || J("Invalid scope") || {},
      function(t) {
          var i = e.current || e.nativeElement || e;
          return it(t, i.querySelectorAll ? i : i === e ? J("Invalid scope") || p.createElement("div") : e)
      }
  }, rt = function(e) {
      return e.sort((function() {
          return .5 - Math.random()
      }
      ))
  }, st = function(e) {
      if (L(e))
          return e;
      var t = F(e) ? e : {
          each: e
      }
        , i = Nt(t.ease)
        , n = t.from || 0
        , r = parseFloat(t.base) || 0
        , s = {}
        , a = n > 0 && n < 1
        , o = isNaN(n) || a
        , l = t.axis
        , c = n
        , u = n;
      return R(n) ? c = u = {
          center: .5,
          edges: .5,
          end: 1
      }[n] || 0 : !a && o && (c = n[0],
      u = n[1]),
      function(e, a, h) {
          var d, p, f, m, g, v, _, y, x, S = (h || t).length, E = s[S];
          if (!E) {
              if (!(x = "auto" === t.grid ? 0 : (t.grid || [1, M])[1])) {
                  for (_ = -M; _ < (_ = h[x++].getBoundingClientRect().left) && x < S; )
                      ;
                  x < S && x--
              }
              for (E = s[S] = [],
              d = o ? Math.min(x, S) * c - .5 : n % x,
              p = x === M ? 0 : o ? S * u / x - .5 : n / x | 0,
              _ = 0,
              y = M,
              v = 0; v < S; v++)
                  f = v % x - d,
                  m = p - (v / x | 0),
                  E[v] = g = l ? Math.abs("y" === l ? m : f) : C(f * f + m * m),
                  g > _ && (_ = g),
                  g < y && (y = g);
              "random" === n && rt(E),
              E.max = _ - y,
              E.min = y,
              E.v = S = (parseFloat(t.amount) || parseFloat(t.each) * (x > S ? S - 1 : l ? "y" === l ? S / x : x : Math.max(x, S / x)) || 0) * ("edges" === n ? -1 : 1),
              E.b = S < 0 ? r - S : r,
              E.u = Qe(t.amount || t.each) || 0,
              i = i && S < 0 ? Lt(i) : i
          }
          return S = (E[e] - E.min) / E.max || 0,
          ve(E.b + (i ? i(S) : S) * E.v) + E.u
      }
  }, at = function(e) {
      var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
      return function(i) {
          var n = ve(Math.round(parseFloat(i) / e) * e * t);
          return (n - n % 1) / t + (I(i) ? 0 : Qe(i))
      }
  }, ot = function(e, t) {
      var i, n, r = k(e);
      return !r && F(e) && (i = r = e.radius || M,
      e.values ? (e = it(e.values),
      (n = !I(e[0])) && (i *= i)) : e = at(e.increment)),
      $e(t, r ? L(e) ? function(t) {
          return n = e(t),
          Math.abs(n - t) <= i ? n : t
      }
      : function(t) {
          for (var r, s, a = parseFloat(n ? t.x : t), o = parseFloat(n ? t.y : 0), l = M, c = 0, u = e.length; u--; )
              (r = n ? (r = e[u].x - a) * r + (s = e[u].y - o) * s : Math.abs(e[u] - a)) < l && (l = r,
              c = u);
          return c = !i || l <= i ? e[c] : t,
          n || c === t || I(t) ? c : c + Qe(t)
      }
      : at(e))
  }, lt = function(e, t, i, n) {
      return $e(k(e) ? !t : !0 === i ? !!(i = 0) : !n, (function() {
          return k(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + .99 * i)) / i) * i * n) / n
      }
      ))
  }, ct = function(e, t, i) {
      return $e(i, (function(i) {
          return e[~~t(i)]
      }
      ))
  }, ut = function(e) {
      for (var t, i, n, r, s = 0, a = ""; ~(t = e.indexOf("random(", s)); )
          n = e.indexOf(")", t),
          r = "[" === e.charAt(t + 7),
          i = e.substr(t + 7, n - t - 7).match(r ? q : V),
          a += e.substr(s, t - s) + lt(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5),
          s = n + 1;
      return a + e.substr(s, e.length - s)
  }, ht = function(e, t, i, n, r) {
      var s = t - e
        , a = n - i;
      return $e(r, (function(t) {
          return i + ((t - e) / s * a || 0)
      }
      ))
  }, dt = function(e, t, i) {
      var n, r, s, a = e.labels, o = M;
      for (n in a)
          (r = a[n] - t) < 0 == !!i && r && o > (r = Math.abs(r)) && (s = n,
          o = r);
      return s
  }, pt = function(e, t, i) {
      var n, r, s, a = e.vars, o = a[t], l = c, u = e._ctx;
      if (o)
          return n = a[t + "Params"],
          r = a.callbackScope || e,
          i && se.length && xe(),
          u && (c = u),
          s = n ? o.apply(r, n) : o.call(r),
          c = l,
          s
  }, ft = function(e) {
      return Re(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!l),
      e.progress() < 1 && pt(e, "onInterrupt"),
      e
  }, mt = [], gt = function(e) {
      if (e)
          if (e = !e.name && e.default || e,
          U() || e.headless) {
              var t = e.name
                , i = L(e)
                , n = t && !i && e.init ? function() {
                  this._props = []
              }
              : e
                , r = {
                  init: ee,
                  render: oi,
                  add: Xt,
                  kill: ci,
                  modifier: li,
                  rawVars: 0
              }
                , s = {
                  targetTest: 0,
                  get: 0,
                  getSetter: ni,
                  aliases: {},
                  register: 0
              };
              if (Dt(),
              e !== n) {
                  if (oe[t])
                      return;
                  be(n, be(De(e, r), s)),
                  Te(n.prototype, Te(r, De(e, s))),
                  oe[n.prop = t] = n,
                  e.targetTest && (ue.push(n),
                  re[t] = 1),
                  t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
              }
              Q(t, n),
              e.register && e.register(Ti, n, di)
          } else
              mt.push(e)
  }, vt = 255, _t = {
      aqua: [0, vt, vt],
      lime: [0, vt, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, vt],
      navy: [0, 0, 128],
      white: [vt, vt, vt],
      olive: [128, 128, 0],
      yellow: [vt, vt, 0],
      orange: [vt, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [vt, 0, 0],
      pink: [vt, 192, 203],
      cyan: [0, vt, vt],
      transparent: [vt, vt, vt, 0]
  }, yt = function(e, t, i) {
      return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (i - t) * e * 6 : e < .5 ? i : 3 * e < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * vt + .5 | 0
  }, xt = function(e, t, i) {
      var n, r, s, a, o, l, c, u, h, d, p = e ? I(e) ? [e >> 16, e >> 8 & vt, e & vt] : 0 : _t.black;
      if (!p) {
          if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)),
          _t[e])
              p = _t[e];
          else if ("#" === e.charAt(0)) {
              if (e.length < 6 && (n = e.charAt(1),
              r = e.charAt(2),
              s = e.charAt(3),
              e = "#" + n + n + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")),
              9 === e.length)
                  return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & vt, p & vt, parseInt(e.substr(7), 16) / 255];
              p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & vt, e & vt]
          } else if ("hsl" === e.substr(0, 3))
              if (p = d = e.match(V),
              t) {
                  if (~e.indexOf("="))
                      return p = e.match(H),
                      i && p.length < 4 && (p[3] = 1),
                      p
              } else
                  a = +p[0] % 360 / 360,
                  o = +p[1] / 100,
                  n = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o),
                  p.length > 3 && (p[3] *= 1),
                  p[0] = yt(a + 1 / 3, n, r),
                  p[1] = yt(a, n, r),
                  p[2] = yt(a - 1 / 3, n, r);
          else
              p = e.match(V) || _t.transparent;
          p = p.map(Number)
      }
      return t && !d && (n = p[0] / vt,
      r = p[1] / vt,
      s = p[2] / vt,
      l = ((c = Math.max(n, r, s)) + (u = Math.min(n, r, s))) / 2,
      c === u ? a = o = 0 : (h = c - u,
      o = l > .5 ? h / (2 - c - u) : h / (c + u),
      a = c === n ? (r - s) / h + (r < s ? 6 : 0) : c === r ? (s - n) / h + 2 : (n - r) / h + 4,
      a *= 60),
      p[0] = ~~(a + .5),
      p[1] = ~~(100 * o + .5),
      p[2] = ~~(100 * l + .5)),
      i && p.length < 4 && (p[3] = 1),
      p
  }, St = function(e) {
      var t = []
        , i = []
        , n = -1;
      return e.split(Mt).forEach((function(e) {
          var r = e.match(G) || [];
          t.push.apply(t, r),
          i.push(n += r.length + 1)
      }
      )),
      t.c = i,
      t
  }, Et = function(e, t, i) {
      var n, r, s, a, o = "", l = (e + o).match(Mt), c = t ? "hsla(" : "rgba(", u = 0;
      if (!l)
          return e;
      if (l = l.map((function(e) {
          return (e = xt(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
      }
      )),
      i && (s = St(e),
      (n = i.c).join(o) !== s.c.join(o)))
          for (a = (r = e.replace(Mt, "1").split(G)).length - 1; u < a; u++)
              o += r[u] + (~n.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : i).shift());
      if (!r)
          for (a = (r = e.split(Mt)).length - 1; u < a; u++)
              o += r[u] + l[u];
      return o + r[a]
  }, Mt = function() {
      var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
      for (e in _t)
          t += "|" + e + "\\b";
      return new RegExp(t + ")","gi")
  }(), bt = /hsl[a]?\(/, Tt = function(e) {
      var t, i = e.join(" ");
      if (Mt.lastIndex = 0,
      Mt.test(i))
          return t = bt.test(i),
          e[1] = Et(e[1], t),
          e[0] = Et(e[0], t, St(e[1])),
          !0
  }, wt = function() {
      var e, t, i, n, r, s, a = Date.now, o = 500, l = 33, c = a(), u = c, m = 1e3 / 240, g = m, _ = [], y = function i(h) {
          var d, p, f, v, y = a() - u, x = !0 === h;
          if ((y > o || y < 0) && (c += y - l),
          ((d = (f = (u += y) - c) - g) > 0 || x) && (v = ++n.frame,
          r = f - 1e3 * n.time,
          n.time = f /= 1e3,
          g += d + (d >= m ? 4 : m - d),
          p = 1),
          x || (e = t(i)),
          p)
              for (s = 0; s < _.length; s++)
                  _[s](f, r, v, h)
      };
      return n = {
          time: 0,
          frame: 0,
          tick: function() {
              y(!0)
          },
          deltaRatio: function(e) {
              return r / (1e3 / (e || 60))
          },
          wake: function() {
              f && (!d && U() && (h = d = window,
              p = h.document || {},
              Y.gsap = Ti,
              (h.gsapVersions || (h.gsapVersions = [])).push(Ti.version),
              Z(K || h.GreenSockGlobals || !h.gsap && h || {}),
              mt.forEach(gt)),
              i = "undefined" != typeof requestAnimationFrame && requestAnimationFrame,
              e && n.sleep(),
              t = i || function(e) {
                  return setTimeout(e, g - 1e3 * n.time + 1 | 0)
              }
              ,
              v = 1,
              y(2))
          },
          sleep: function() {
              (i ? cancelAnimationFrame : clearTimeout)(e),
              v = 0,
              t = ee
          },
          lagSmoothing: function(e, t) {
              o = e || 1 / 0,
              l = Math.min(t || 33, o)
          },
          fps: function(e) {
              m = 1e3 / (e || 240),
              g = 1e3 * n.time + m
          },
          add: function(e, t, i) {
              var r = t ? function(t, i, s, a) {
                  e(t, i, s, a),
                  n.remove(r)
              }
              : e;
              return n.remove(e),
              _[i ? "unshift" : "push"](r),
              Dt(),
              r
          },
          remove: function(e, t) {
              ~(t = _.indexOf(e)) && _.splice(t, 1) && s >= t && s--
          },
          _listeners: _
      },
      n
  }(), Dt = function() {
      return !v && wt.wake()
  }, Ct = {}, At = /^[\d.\-M][\d.\-,\s]/, Pt = /["']/g, Rt = function(e) {
      for (var t, i, n, r = {}, s = e.substr(1, e.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)
          i = s[o],
          t = o !== l - 1 ? i.lastIndexOf(",") : i.length,
          n = i.substr(0, t),
          r[a] = isNaN(n) ? n.replace(Pt, "").trim() : +n,
          a = i.substr(t + 1).trim();
      return r
  }, Lt = function(e) {
      return function(t) {
          return 1 - e(1 - t)
      }
  }, It = function e(t, i) {
      for (var n, r = t._first; r; )
          r instanceof Vt ? e(r, i) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === i || (r.timeline ? e(r.timeline, i) : (n = r._ease,
          r._ease = r._yEase,
          r._yEase = n,
          r._yoyo = i)),
          r = r._next
  }, Nt = function(e, t) {
      return e && (L(e) ? e : Ct[e] || function(e) {
          var t, i, n, r, s = (e + "").split("("), a = Ct[s[0]];
          return a && s.length > 1 && a.config ? a.config.apply(null, ~e.indexOf("{") ? [Rt(s[1])] : (t = e,
          i = t.indexOf("(") + 1,
          n = t.indexOf(")"),
          r = t.indexOf("(", i),
          t.substring(i, ~r && r < n ? t.indexOf(")", n + 1) : n)).split(",").map(Ee)) : Ct._CE && At.test(e) ? Ct._CE("", e) : a
      }(e)) || t
  }, Ft = function(e, t, i, n) {
      void 0 === i && (i = function(e) {
          return 1 - t(1 - e)
      }
      ),
      void 0 === n && (n = function(e) {
          return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
      }
      );
      var r, s = {
          easeIn: t,
          easeOut: i,
          easeInOut: n
      };
      return me(e, (function(e) {
          for (var t in Ct[e] = Y[e] = s,
          Ct[r = e.toLowerCase()] = i,
          s)
              Ct[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Ct[e + "." + t] = s[t]
      }
      )),
      s
  }, Ot = function(e) {
      return function(t) {
          return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
      }
  }, Ut = function e(t, i, n) {
      var r = i >= 1 ? i : 1
        , s = (n || (t ? .3 : .45)) / (i < 1 ? i : 1)
        , a = s / T * (Math.asin(1 / r) || 0)
        , o = function(e) {
          return 1 === e ? 1 : r * Math.pow(2, -10 * e) * P((e - a) * s) + 1
      }
        , l = "out" === t ? o : "in" === t ? function(e) {
          return 1 - o(1 - e)
      }
      : Ot(o);
      return s = T / s,
      l.config = function(i, n) {
          return e(t, i, n)
      }
      ,
      l
  }, Bt = function e(t, i) {
      void 0 === i && (i = 1.70158);
      var n = function(e) {
          return e ? --e * e * ((i + 1) * e + i) + 1 : 0
      }
        , r = "out" === t ? n : "in" === t ? function(e) {
          return 1 - n(1 - e)
      }
      : Ot(n);
      return r.config = function(i) {
          return e(t, i)
      }
      ,
      r
  };
  me("Linear,Quad,Cubic,Quart,Quint,Strong", (function(e, t) {
      var i = t < 5 ? t + 1 : t;
      Ft(e + ",Power" + (i - 1), t ? function(e) {
          return Math.pow(e, i)
      }
      : function(e) {
          return e
      }
      , (function(e) {
          return 1 - Math.pow(1 - e, i)
      }
      ), (function(e) {
          return e < .5 ? Math.pow(2 * e, i) / 2 : 1 - Math.pow(2 * (1 - e), i) / 2
      }
      ))
  }
  )),
  Ct.Linear.easeNone = Ct.none = Ct.Linear.easeIn,
  Ft("Elastic", Ut("in"), Ut("out"), Ut()),
  _ = 7.5625,
  y = 2.75,
  Ft("Bounce", (function(e) {
      return 1 - x(1 - e)
  }
  ), x = function(e) {
      return e < .36363636363636365 ? _ * e * e : e < .7272727272727273 ? _ * Math.pow(e - 1.5 / y, 2) + .75 : e < .9090909090909092 ? _ * (e -= 2.25 / y) * e + .9375 : _ * Math.pow(e - 2.625 / y, 2) + .984375
  }
  ),
  Ft("Expo", (function(e) {
      return e ? Math.pow(2, 10 * (e - 1)) : 0
  }
  )),
  Ft("Circ", (function(e) {
      return -(C(1 - e * e) - 1)
  }
  )),
  Ft("Sine", (function(e) {
      return 1 === e ? 1 : 1 - A(e * w)
  }
  )),
  Ft("Back", Bt("in"), Bt("out"), Bt()),
  Ct.SteppedEase = Ct.steps = Y.SteppedEase = {
      config: function(e, t) {
          void 0 === e && (e = 1);
          var i = 1 / e
            , n = e + (t ? 0 : 1)
            , r = t ? 1 : 0;
          return function(e) {
              return ((n * Je(0, .99999999, e) | 0) + r) * i
          }
      }
  },
  E.ease = Ct["quad.out"],
  me("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(e) {
      return he += e + "," + e + "Params,"
  }
  ));
  var zt = function(e, t) {
      this.id = D++,
      e._gsap = this,
      this.target = e,
      this.harness = t,
      this.get = t ? t.get : fe,
      this.set = t ? t.getSetter : ni
  }
    , kt = function() {
      function e(e) {
          this.vars = e,
          this._delay = +e.delay || 0,
          (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0,
          this._yoyo = !!e.yoyo || !!e.yoyoEase),
          this._ts = 1,
          qe(this, +e.duration, 1, 1),
          this.data = e.data,
          c && (this._ctx = c,
          c.data.push(this)),
          v || wt.wake()
      }
      var t = e.prototype;
      return t.delay = function(e) {
          return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay),
          this._delay = e,
          this) : this._delay
      }
      ,
      t.duration = function(e) {
          return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
      }
      ,
      t.totalDuration = function(e) {
          return arguments.length ? (this._dirty = 0,
          qe(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
      }
      ,
      t.totalTime = function(e, t) {
          if (Dt(),
          !arguments.length)
              return this._tTime;
          var i = this._dp;
          if (i && i.smoothChildTiming && this._ts) {
              for (ze(this, e),
              !i._dp || i.parent || ke(i, this); i && i.parent; )
                  i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0),
                  i = i.parent;
              !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && Ve(this._dp, this, this._start - this._delay)
          }
          return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === b || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e),
          Se(this, e, t)),
          this
      }
      ,
      t.time = function(e, t) {
          return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + Fe(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
      }
      ,
      t.totalProgress = function(e, t) {
          return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
      }
      ,
      t.progress = function(e, t) {
          return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + Fe(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
      }
      ,
      t.iteration = function(e, t) {
          var i = this.duration() + this._rDelay;
          return arguments.length ? this.totalTime(this._time + (e - 1) * i, t) : this._repeat ? Oe(this._tTime, i) + 1 : 1
      }
      ,
      t.timeScale = function(e, t) {
          if (!arguments.length)
              return -1e-8 === this._rts ? 0 : this._rts;
          if (this._rts === e)
              return this;
          var i = this.parent && this._ts ? Ue(this.parent._time, this) : this._tTime;
          return this._rts = +e || 0,
          this._ts = this._ps || -1e-8 === e ? 0 : this._rts,
          this.totalTime(Je(-Math.abs(this._delay), this._tDur, i), !1 !== t),
          Be(this),
          function(e) {
              for (var t = e.parent; t && t.parent; )
                  t._dirty = 1,
                  t.totalDuration(),
                  t = t.parent;
              return e
          }(this)
      }
      ,
      t.paused = function(e) {
          return arguments.length ? (this._ps !== e && (this._ps = e,
          e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
          this._ts = this._act = 0) : (Dt(),
          this._ts = this._rts,
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== b && (this._tTime -= b)))),
          this) : this._ps
      }
      ,
      t.startTime = function(e) {
          if (arguments.length) {
              this._start = e;
              var t = this.parent || this._dp;
              return t && (t._sort || !this.parent) && Ve(t, this, e - this._delay),
              this
          }
          return this._start
      }
      ,
      t.endTime = function(e) {
          return this._start + (O(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
      }
      ,
      t.rawTime = function(e) {
          var t = this.parent || this._dp;
          return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ue(t.rawTime(e), this) : this._tTime : this._tTime
      }
      ,
      t.revert = function(e) {
          void 0 === e && (e = ne);
          var t = l;
          return l = e,
          (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e),
          this.totalTime(-.01, e.suppressEvents)),
          "nested" !== this.data && !1 !== e.kill && this.kill(),
          l = t,
          this
      }
      ,
      t.globalTime = function(e) {
          for (var t = this, i = arguments.length ? e : t.rawTime(); t; )
              i = t._start + i / (Math.abs(t._ts) || 1),
              t = t._dp;
          return !this.parent && this._sat ? this._sat.globalTime(e) : i
      }
      ,
      t.repeat = function(e) {
          return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e,
          je(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
      }
      ,
      t.repeatDelay = function(e) {
          if (arguments.length) {
              var t = this._time;
              return this._rDelay = e,
              je(this),
              t ? this.time(t) : this
          }
          return this._rDelay
      }
      ,
      t.yoyo = function(e) {
          return arguments.length ? (this._yoyo = e,
          this) : this._yoyo
      }
      ,
      t.seek = function(e, t) {
          return this.totalTime(Ke(this, e), O(t))
      }
      ,
      t.restart = function(e, t) {
          return this.play().totalTime(e ? -this._delay : 0, O(t))
      }
      ,
      t.play = function(e, t) {
          return null != e && this.seek(e, t),
          this.reversed(!1).paused(!1)
      }
      ,
      t.reverse = function(e, t) {
          return null != e && this.seek(e || this.totalDuration(), t),
          this.reversed(!0).paused(!1)
      }
      ,
      t.pause = function(e, t) {
          return null != e && this.seek(e, t),
          this.paused(!0)
      }
      ,
      t.resume = function() {
          return this.paused(!1)
      }
      ,
      t.reversed = function(e) {
          return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)),
          this) : this._rts < 0
      }
      ,
      t.invalidate = function() {
          return this._initted = this._act = 0,
          this._zTime = -1e-8,
          this
      }
      ,
      t.isActive = function() {
          var e, t = this.parent || this._dp, i = this._start;
          return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= i && e < this.endTime(!0) - b))
      }
      ,
      t.eventCallback = function(e, t, i) {
          var n = this.vars;
          return arguments.length > 1 ? (t ? (n[e] = t,
          i && (n[e + "Params"] = i),
          "onUpdate" === e && (this._onUpdate = t)) : delete n[e],
          this) : n[e]
      }
      ,
      t.then = function(e) {
          var t = this;
          return new Promise((function(i) {
              var n = L(e) ? e : Me
                , r = function() {
                  var e = t.then;
                  t.then = null,
                  L(n) && (n = n(t)) && (n.then || n === t) && (t.then = e),
                  i(n),
                  t.then = e
              };
              t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r
          }
          ))
      }
      ,
      t.kill = function() {
          ft(this)
      }
      ,
      e
  }();
  be(kt.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: !1,
      parent: null,
      _initted: !1,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -1e-8,
      _prom: 0,
      _ps: !1,
      _rts: 1
  });
  var Vt = function(e) {
      function t(t, i) {
          var n;
          return void 0 === t && (t = {}),
          (n = e.call(this, t) || this).labels = {},
          n.smoothChildTiming = !!t.smoothChildTiming,
          n.autoRemoveChildren = !!t.autoRemoveChildren,
          n._sort = O(t.sortChildren),
          u && Ve(t.parent || u, s(n), i),
          t.reversed && n.reverse(),
          t.paused && n.paused(!0),
          t.scrollTrigger && He(s(n), t.scrollTrigger),
          n
      }
      a(t, e);
      var i = t.prototype;
      return i.to = function(e, t, i) {
          return Ze(0, arguments, this),
          this
      }
      ,
      i.from = function(e, t, i) {
          return Ze(1, arguments, this),
          this
      }
      ,
      i.fromTo = function(e, t, i, n) {
          return Ze(2, arguments, this),
          this
      }
      ,
      i.set = function(e, t, i) {
          return t.duration = 0,
          t.parent = this,
          Ce(t).repeatDelay || (t.repeat = 0),
          t.immediateRender = !!t.immediateRender,
          new Jt(e,t,Ke(this, i),1),
          this
      }
      ,
      i.call = function(e, t, i) {
          return Ve(this, Jt.delayedCall(0, e, t), i)
      }
      ,
      i.staggerTo = function(e, t, i, n, r, s, a) {
          return i.duration = t,
          i.stagger = i.stagger || n,
          i.onComplete = s,
          i.onCompleteParams = a,
          i.parent = this,
          new Jt(e,i,Ke(this, r)),
          this
      }
      ,
      i.staggerFrom = function(e, t, i, n, r, s, a) {
          return i.runBackwards = 1,
          Ce(i).immediateRender = O(i.immediateRender),
          this.staggerTo(e, t, i, n, r, s, a)
      }
      ,
      i.staggerFromTo = function(e, t, i, n, r, s, a, o) {
          return n.startAt = i,
          Ce(n).immediateRender = O(n.immediateRender),
          this.staggerTo(e, t, n, r, s, a, o)
      }
      ,
      i.render = function(e, t, i) {
          var n, r, s, a, o, c, h, d, p, f, m, g, v = this._time, _ = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, x = e <= 0 ? 0 : ve(e), S = this._zTime < 0 != e < 0 && (this._initted || !y);
          if (this !== u && x > _ && e >= 0 && (x = _),
          x !== this._tTime || i || S) {
              if (v !== this._time && y && (x += this._time - v,
              e += this._time - v),
              n = x,
              p = this._start,
              c = !(d = this._ts),
              S && (y || (v = this._zTime),
              (e || !t) && (this._zTime = e)),
              this._repeat) {
                  if (m = this._yoyo,
                  o = y + this._rDelay,
                  this._repeat < -1 && e < 0)
                      return this.totalTime(100 * o + e, t, i);
                  if (n = ve(x % o),
                  x === _ ? (a = this._repeat,
                  n = y) : ((a = ~~(x / o)) && a === x / o && (n = y,
                  a--),
                  n > y && (n = y)),
                  f = Oe(this._tTime, o),
                  !v && this._tTime && f !== a && this._tTime - f * o - this._dur <= 0 && (f = a),
                  m && 1 & a && (n = y - n,
                  g = 1),
                  a !== f && !this._lock) {
                      var E = m && 1 & f
                        , M = E === (m && 1 & a);
                      if (a < f && (E = !E),
                      v = E ? 0 : x % y ? y : x,
                      this._lock = 1,
                      this.render(v || (g ? 0 : ve(a * o)), t, !y)._lock = 0,
                      this._tTime = x,
                      !t && this.parent && pt(this, "onRepeat"),
                      this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1),
                      v && v !== this._time || c !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                          return this;
                      if (y = this._dur,
                      _ = this._tDur,
                      M && (this._lock = 2,
                      v = E ? y : -1e-4,
                      this.render(v, !0),
                      this.vars.repeatRefresh && !g && this.invalidate()),
                      this._lock = 0,
                      !this._ts && !c)
                          return this;
                      It(this, g)
                  }
              }
              if (this._hasPause && !this._forcing && this._lock < 2 && (h = function(e, t, i) {
                  var n;
                  if (i > t)
                      for (n = e._first; n && n._start <= i; ) {
                          if ("isPause" === n.data && n._start > t)
                              return n;
                          n = n._next
                      }
                  else
                      for (n = e._last; n && n._start >= i; ) {
                          if ("isPause" === n.data && n._start < t)
                              return n;
                          n = n._prev
                      }
              }(this, ve(v), ve(n)),
              h && (x -= n - (n = h._start))),
              this._tTime = x,
              this._time = n,
              this._act = !d,
              this._initted || (this._onUpdate = this.vars.onUpdate,
              this._initted = 1,
              this._zTime = e,
              v = 0),
              !v && n && !t && !a && (pt(this, "onStart"),
              this._tTime !== x))
                  return this;
              if (n >= v && e >= 0)
                  for (r = this._first; r; ) {
                      if (s = r._next,
                      (r._act || n >= r._start) && r._ts && h !== r) {
                          if (r.parent !== this)
                              return this.render(e, t, i);
                          if (r.render(r._ts > 0 ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, t, i),
                          n !== this._time || !this._ts && !c) {
                              h = 0,
                              s && (x += this._zTime = -1e-8);
                              break
                          }
                      }
                      r = s
                  }
              else {
                  r = this._last;
                  for (var T = e < 0 ? e : n; r; ) {
                      if (s = r._prev,
                      (r._act || T <= r._end) && r._ts && h !== r) {
                          if (r.parent !== this)
                              return this.render(e, t, i);
                          if (r.render(r._ts > 0 ? (T - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (T - r._start) * r._ts, t, i || l && (r._initted || r._startAt)),
                          n !== this._time || !this._ts && !c) {
                              h = 0,
                              s && (x += this._zTime = T ? -1e-8 : b);
                              break
                          }
                      }
                      r = s
                  }
              }
              if (h && !t && (this.pause(),
              h.render(n >= v ? 0 : -1e-8)._zTime = n >= v ? 1 : -1,
              this._ts))
                  return this._start = p,
                  Be(this),
                  this.render(e, t, i);
              this._onUpdate && !t && pt(this, "onUpdate", !0),
              (x === _ && this._tTime >= this.totalDuration() || !x && v) && (p !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((e || !y) && (x === _ && this._ts > 0 || !x && this._ts < 0) && Re(this, 1),
              t || e < 0 && !v || !x && !v && _ || (pt(this, x === _ && e >= 0 ? "onComplete" : "onReverseComplete", !0),
              this._prom && !(x < _ && this.timeScale() > 0) && this._prom())))
          }
          return this
      }
      ,
      i.add = function(e, t) {
          var i = this;
          if (I(t) || (t = Ke(this, t, e)),
          !(e instanceof kt)) {
              if (k(e))
                  return e.forEach((function(e) {
                      return i.add(e, t)
                  }
                  )),
                  this;
              if (R(e))
                  return this.addLabel(e, t);
              if (!L(e))
                  return this;
              e = Jt.delayedCall(0, e)
          }
          return this !== e ? Ve(this, e, t) : this
      }
      ,
      i.getChildren = function(e, t, i, n) {
          void 0 === e && (e = !0),
          void 0 === t && (t = !0),
          void 0 === i && (i = !0),
          void 0 === n && (n = -M);
          for (var r = [], s = this._first; s; )
              s._start >= n && (s instanceof Jt ? t && r.push(s) : (i && r.push(s),
              e && r.push.apply(r, s.getChildren(!0, t, i)))),
              s = s._next;
          return r
      }
      ,
      i.getById = function(e) {
          for (var t = this.getChildren(1, 1, 1), i = t.length; i--; )
              if (t[i].vars.id === e)
                  return t[i]
      }
      ,
      i.remove = function(e) {
          return R(e) ? this.removeLabel(e) : L(e) ? this.killTweensOf(e) : (Pe(this, e),
          e === this._recent && (this._recent = this._last),
          Le(this))
      }
      ,
      i.totalTime = function(t, i) {
          return arguments.length ? (this._forcing = 1,
          !this._dp && this._ts && (this._start = ve(wt.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))),
          e.prototype.totalTime.call(this, t, i),
          this._forcing = 0,
          this) : this._tTime
      }
      ,
      i.addLabel = function(e, t) {
          return this.labels[e] = Ke(this, t),
          this
      }
      ,
      i.removeLabel = function(e) {
          return delete this.labels[e],
          this
      }
      ,
      i.addPause = function(e, t, i) {
          var n = Jt.delayedCall(0, t || ee, i);
          return n.data = "isPause",
          this._hasPause = 1,
          Ve(this, n, Ke(this, e))
      }
      ,
      i.removePause = function(e) {
          var t = this._first;
          for (e = Ke(this, e); t; )
              t._start === e && "isPause" === t.data && Re(t),
              t = t._next
      }
      ,
      i.killTweensOf = function(e, t, i) {
          for (var n = this.getTweensOf(e, i), r = n.length; r--; )
              Ht !== n[r] && n[r].kill(e, t);
          return this
      }
      ,
      i.getTweensOf = function(e, t) {
          for (var i, n = [], r = it(e), s = this._first, a = I(t); s; )
              s instanceof Jt ? ye(s._targets, r) && (a ? (!Ht || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && n.push(s) : (i = s.getTweensOf(r, t)).length && n.push.apply(n, i),
              s = s._next;
          return n
      }
      ,
      i.tweenTo = function(e, t) {
          t = t || {};
          var i, n = this, r = Ke(n, e), s = t, a = s.startAt, o = s.onStart, l = s.onStartParams, c = s.immediateRender, u = Jt.to(n, be({
              ease: t.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: r,
              overwrite: "auto",
              duration: t.duration || Math.abs((r - (a && "time"in a ? a.time : n._time)) / n.timeScale()) || b,
              onStart: function() {
                  if (n.pause(),
                  !i) {
                      var e = t.duration || Math.abs((r - (a && "time"in a ? a.time : n._time)) / n.timeScale());
                      u._dur !== e && qe(u, e, 0, 1).render(u._time, !0, !0),
                      i = 1
                  }
                  o && o.apply(u, l || [])
              }
          }, t));
          return c ? u.render(0) : u
      }
      ,
      i.tweenFromTo = function(e, t, i) {
          return this.tweenTo(t, be({
              startAt: {
                  time: Ke(this, e)
              }
          }, i))
      }
      ,
      i.recent = function() {
          return this._recent
      }
      ,
      i.nextLabel = function(e) {
          return void 0 === e && (e = this._time),
          dt(this, Ke(this, e))
      }
      ,
      i.previousLabel = function(e) {
          return void 0 === e && (e = this._time),
          dt(this, Ke(this, e), 1)
      }
      ,
      i.currentLabel = function(e) {
          return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + b)
      }
      ,
      i.shiftChildren = function(e, t, i) {
          void 0 === i && (i = 0);
          for (var n, r = this._first, s = this.labels; r; )
              r._start >= i && (r._start += e,
              r._end += e),
              r = r._next;
          if (t)
              for (n in s)
                  s[n] >= i && (s[n] += e);
          return Le(this)
      }
      ,
      i.invalidate = function(t) {
          var i = this._first;
          for (this._lock = 0; i; )
              i.invalidate(t),
              i = i._next;
          return e.prototype.invalidate.call(this, t)
      }
      ,
      i.clear = function(e) {
          void 0 === e && (e = !0);
          for (var t, i = this._first; i; )
              t = i._next,
              this.remove(i),
              i = t;
          return this._dp && (this._time = this._tTime = this._pTime = 0),
          e && (this.labels = {}),
          Le(this)
      }
      ,
      i.totalDuration = function(e) {
          var t, i, n, r = 0, s = this, a = s._last, o = M;
          if (arguments.length)
              return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -e : e));
          if (s._dirty) {
              for (n = s.parent; a; )
                  t = a._prev,
                  a._dirty && a.totalDuration(),
                  (i = a._start) > o && s._sort && a._ts && !s._lock ? (s._lock = 1,
                  Ve(s, a, i - a._delay, 1)._lock = 0) : o = i,
                  i < 0 && a._ts && (r -= i,
                  (!n && !s._dp || n && n.smoothChildTiming) && (s._start += i / s._ts,
                  s._time -= i,
                  s._tTime -= i),
                  s.shiftChildren(-i, !1, -Infinity),
                  o = 0),
                  a._end > r && a._ts && (r = a._end),
                  a = t;
              qe(s, s === u && s._time > r ? s._time : r, 1, 1),
              s._dirty = 0
          }
          return s._tDur
      }
      ,
      t.updateRoot = function(e) {
          if (u._ts && (Se(u, Ue(e, u)),
          m = wt.frame),
          wt.frame >= ce) {
              ce += S.autoSleep || 120;
              var t = u._first;
              if ((!t || !t._ts) && S.autoSleep && wt._listeners.length < 2) {
                  for (; t && !t._ts; )
                      t = t._next;
                  t || wt.sleep()
              }
          }
      }
      ,
      t
  }(kt);
  be(Vt.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0
  });
  var Ht, Gt, Wt = function(e, t, i, n, r, s, a) {
      var o, l, c, u, h, d, p, f, m = new di(this._pt,e,t,0,1,ai,null,r), g = 0, v = 0;
      for (m.b = i,
      m.e = n,
      i += "",
      (p = ~(n += "").indexOf("random(")) && (n = ut(n)),
      s && (s(f = [i, n], e, t),
      i = f[0],
      n = f[1]),
      l = i.match(W) || []; o = W.exec(n); )
          u = o[0],
          h = n.substring(g, o.index),
          c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1),
          u !== l[v++] && (d = parseFloat(l[v - 1]) || 0,
          m._pt = {
              _next: m._pt,
              p: h || 1 === v ? h : ",",
              s: d,
              c: "=" === u.charAt(1) ? _e(d, u) - d : parseFloat(u) - d,
              m: c && c < 4 ? Math.round : 0
          },
          g = W.lastIndex);
      return m.c = g < n.length ? n.substring(g, n.length) : "",
      m.fp = a,
      (X.test(n) || p) && (m.e = 0),
      this._pt = m,
      m
  }, Xt = function(e, t, i, n, r, s, a, o, l, c) {
      L(n) && (n = n(r || 0, e, s));
      var u, h = e[t], d = "get" !== i ? i : L(h) ? l ? e[t.indexOf("set") || !L(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : h, p = L(h) ? l ? ti : ei : Qt;
      if (R(n) && (~n.indexOf("random(") && (n = ut(n)),
      "=" === n.charAt(1) && ((u = _e(d, n) + (Qe(d) || 0)) || 0 === u) && (n = u)),
      !c || d !== n || Gt)
          return isNaN(d * n) || "" === n ? (!h && !(t in e) && $(t, n),
          Wt.call(this, e, t, d, n, p, o || S.stringFilter, l)) : (u = new di(this._pt,e,t,+d || 0,n - (d || 0),"boolean" == typeof h ? si : ri,0,p),
          l && (u.fp = l),
          a && u.modifier(a, this, e),
          this._pt = u)
  }, qt = function(e, t, i, n, r, s) {
      var a, o, l, c;
      if (oe[e] && !1 !== (a = new oe[e]).init(r, a.rawVars ? t[e] : function(e, t, i, n, r) {
          if (L(e) && (e = Kt(e, r, t, i, n)),
          !F(e) || e.style && e.nodeType || k(e) || z(e))
              return R(e) ? Kt(e, r, t, i, n) : e;
          var s, a = {};
          for (s in e)
              a[s] = Kt(e[s], r, t, i, n);
          return a
      }(t[e], n, r, s, i), i, n, s) && (i._pt = o = new di(i._pt,r,e,0,1,a.render,a,0,a.priority),
      i !== g))
          for (l = i._ptLookup[i._targets.indexOf(r)],
          c = a._props.length; c--; )
              l[a._props[c]] = o;
      return a
  }, jt = function e(t, i, n) {
      var r, s, a, c, h, d, p, f, m, g, v, _, y, x = t.vars, S = x.ease, T = x.startAt, w = x.immediateRender, D = x.lazy, C = x.onUpdate, A = x.runBackwards, P = x.yoyoEase, R = x.keyframes, L = x.autoRevert, I = t._dur, N = t._startAt, F = t._targets, U = t.parent, B = U && "nested" === U.data ? U.vars.targets : F, z = "auto" === t._overwrite && !o, k = t.timeline;
      if (k && (!R || !S) && (S = "none"),
      t._ease = Nt(S, E.ease),
      t._yEase = P ? Lt(Nt(!0 === P ? S : P, E.ease)) : 0,
      P && t._yoyo && !t._repeat && (P = t._yEase,
      t._yEase = t._ease,
      t._ease = P),
      t._from = !k && !!x.runBackwards,
      !k || R && !x.stagger) {
          if (_ = (f = F[0] ? pe(F[0]).harness : 0) && x[f.prop],
          r = De(x, re),
          N && (N._zTime < 0 && N.progress(1),
          i < 0 && A && w && !L ? N.render(-1, !0) : N.revert(A && I ? ie : te),
          N._lazy = 0),
          T) {
              if (Re(t._startAt = Jt.set(F, be({
                  data: "isStart",
                  overwrite: !1,
                  parent: U,
                  immediateRender: !0,
                  lazy: !N && O(D),
                  startAt: null,
                  delay: 0,
                  onUpdate: C && function() {
                      return pt(t, "onUpdate")
                  }
                  ,
                  stagger: 0
              }, T))),
              t._startAt._dp = 0,
              t._startAt._sat = t,
              i < 0 && (l || !w && !L) && t._startAt.revert(ie),
              w && I && i <= 0 && n <= 0)
                  return void (i && (t._zTime = i))
          } else if (A && I && !N)
              if (i && (w = !1),
              a = be({
                  overwrite: !1,
                  data: "isFromStart",
                  lazy: w && !N && O(D),
                  immediateRender: w,
                  stagger: 0,
                  parent: U
              }, r),
              _ && (a[f.prop] = _),
              Re(t._startAt = Jt.set(F, a)),
              t._startAt._dp = 0,
              t._startAt._sat = t,
              i < 0 && (l ? t._startAt.revert(ie) : t._startAt.render(-1, !0)),
              t._zTime = i,
              w) {
                  if (!i)
                      return
              } else
                  e(t._startAt, b, b);
          for (t._pt = t._ptCache = 0,
          D = I && O(D) || D && !I,
          s = 0; s < F.length; s++) {
              if (p = (h = F[s])._gsap || de(F)[s]._gsap,
              t._ptLookup[s] = g = {},
              ae[p.id] && se.length && xe(),
              v = B === F ? s : B.indexOf(h),
              f && !1 !== (m = new f).init(h, _ || r, t, v, B) && (t._pt = c = new di(t._pt,h,m.name,0,1,m.render,m,0,m.priority),
              m._props.forEach((function(e) {
                  g[e] = c
              }
              )),
              m.priority && (d = 1)),
              !f || _)
                  for (a in r)
                      oe[a] && (m = qt(a, r, t, v, h, B)) ? m.priority && (d = 1) : g[a] = c = Xt.call(t, h, a, "get", r[a], v, B, 0, x.stringFilter);
              t._op && t._op[s] && t.kill(h, t._op[s]),
              z && t._pt && (Ht = t,
              u.killTweensOf(h, g, t.globalTime(i)),
              y = !t.parent,
              Ht = 0),
              t._pt && D && (ae[p.id] = 1)
          }
          d && hi(t),
          t._onInit && t._onInit(t)
      }
      t._onUpdate = C,
      t._initted = (!t._op || t._pt) && !y,
      R && i <= 0 && k.render(M, !0, !0)
  }, Yt = function(e, t, i, n) {
      var r, s, a = t.ease || n || "power1.inOut";
      if (k(t))
          s = i[e] || (i[e] = []),
          t.forEach((function(e, i) {
              return s.push({
                  t: i / (t.length - 1) * 100,
                  v: e,
                  e: a
              })
          }
          ));
      else
          for (r in t)
              s = i[r] || (i[r] = []),
              "ease" === r || s.push({
                  t: parseFloat(e),
                  v: t[r],
                  e: a
              })
  }, Kt = function(e, t, i, n, r) {
      return L(e) ? e.call(t, i, n, r) : R(e) && ~e.indexOf("random(") ? ut(e) : e
  }, Zt = he + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", $t = {};
  me(Zt + ",id,stagger,delay,duration,paused,scrollTrigger", (function(e) {
      return $t[e] = 1
  }
  ));
  var Jt = function(e) {
      function t(t, i, n, r) {
          var a;
          "number" == typeof i && (n.duration = i,
          i = n,
          n = null);
          var l, c, h, d, p, f, m, g, v = (a = e.call(this, r ? i : Ce(i)) || this).vars, _ = v.duration, y = v.delay, x = v.immediateRender, E = v.stagger, M = v.overwrite, b = v.keyframes, T = v.defaults, w = v.scrollTrigger, D = v.yoyoEase, C = i.parent || u, A = (k(t) || z(t) ? I(t[0]) : "length"in i) ? [t] : it(t);
          if (a._targets = A.length ? de(A) : J("GSAP target " + t + " not found. https://gsap.com", !S.nullTargetWarn) || [],
          a._ptLookup = [],
          a._overwrite = M,
          b || E || B(_) || B(y)) {
              if (i = a.vars,
              (l = a.timeline = new Vt({
                  data: "nested",
                  defaults: T || {},
                  targets: C && "nested" === C.data ? C.vars.targets : A
              })).kill(),
              l.parent = l._dp = s(a),
              l._start = 0,
              E || B(_) || B(y)) {
                  if (d = A.length,
                  m = E && st(E),
                  F(E))
                      for (p in E)
                          ~Zt.indexOf(p) && (g || (g = {}),
                          g[p] = E[p]);
                  for (c = 0; c < d; c++)
                      (h = De(i, $t)).stagger = 0,
                      D && (h.yoyoEase = D),
                      g && Te(h, g),
                      f = A[c],
                      h.duration = +Kt(_, s(a), c, f, A),
                      h.delay = (+Kt(y, s(a), c, f, A) || 0) - a._delay,
                      !E && 1 === d && h.delay && (a._delay = y = h.delay,
                      a._start += y,
                      h.delay = 0),
                      l.to(f, h, m ? m(c, f, A) : 0),
                      l._ease = Ct.none;
                  l.duration() ? _ = y = 0 : a.timeline = 0
              } else if (b) {
                  Ce(be(l.vars.defaults, {
                      ease: "none"
                  })),
                  l._ease = Nt(b.ease || i.ease || "none");
                  var P, R, L, N = 0;
                  if (k(b))
                      b.forEach((function(e) {
                          return l.to(A, e, ">")
                      }
                      )),
                      l.duration();
                  else {
                      for (p in h = {},
                      b)
                          "ease" === p || "easeEach" === p || Yt(p, b[p], h, b.easeEach);
                      for (p in h)
                          for (P = h[p].sort((function(e, t) {
                              return e.t - t.t
                          }
                          )),
                          N = 0,
                          c = 0; c < P.length; c++)
                              (L = {
                                  ease: (R = P[c]).e,
                                  duration: (R.t - (c ? P[c - 1].t : 0)) / 100 * _
                              })[p] = R.v,
                              l.to(A, L, N),
                              N += L.duration;
                      l.duration() < _ && l.to({}, {
                          duration: _ - l.duration()
                      })
                  }
              }
              _ || a.duration(_ = l.duration())
          } else
              a.timeline = 0;
          return !0 !== M || o || (Ht = s(a),
          u.killTweensOf(A),
          Ht = 0),
          Ve(C, s(a), n),
          i.reversed && a.reverse(),
          i.paused && a.paused(!0),
          (x || !_ && !b && a._start === ve(C._time) && O(x) && Ne(s(a)) && "nested" !== C.data) && (a._tTime = -1e-8,
          a.render(Math.max(0, -y) || 0)),
          w && He(s(a), w),
          a
      }
      a(t, e);
      var i = t.prototype;
      return i.render = function(e, t, i) {
          var n, r, s, a, o, c, u, h, d, p = this._time, f = this._tDur, m = this._dur, g = e < 0, v = e > f - b && !g ? f : e < b ? 0 : e;
          if (m) {
              if (v !== this._tTime || !e || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
                  if (n = v,
                  h = this.timeline,
                  this._repeat) {
                      if (a = m + this._rDelay,
                      this._repeat < -1 && g)
                          return this.totalTime(100 * a + e, t, i);
                      if (n = ve(v % a),
                      v === f ? (s = this._repeat,
                      n = m) : ((s = ~~(v / a)) && s === ve(v / a) && (n = m,
                      s--),
                      n > m && (n = m)),
                      (c = this._yoyo && 1 & s) && (d = this._yEase,
                      n = m - n),
                      o = Oe(this._tTime, a),
                      n === p && !i && this._initted && s === o)
                          return this._tTime = v,
                          this;
                      s !== o && (h && this._yEase && It(h, c),
                      this.vars.repeatRefresh && !c && !this._lock && this._time !== a && this._initted && (this._lock = i = 1,
                      this.render(ve(a * s), !0).invalidate()._lock = 0))
                  }
                  if (!this._initted) {
                      if (Ge(this, g ? e : n, i, t, v))
                          return this._tTime = 0,
                          this;
                      if (!(p === this._time || i && this.vars.repeatRefresh && s !== o))
                          return this;
                      if (m !== this._dur)
                          return this.render(e, t, i)
                  }
                  if (this._tTime = v,
                  this._time = n,
                  !this._act && this._ts && (this._act = 1,
                  this._lazy = 0),
                  this.ratio = u = (d || this._ease)(n / m),
                  this._from && (this.ratio = u = 1 - u),
                  n && !p && !t && !s && (pt(this, "onStart"),
                  this._tTime !== v))
                      return this;
                  for (r = this._pt; r; )
                      r.r(u, r.d),
                      r = r._next;
                  h && h.render(e < 0 ? e : h._dur * h._ease(n / this._dur), t, i) || this._startAt && (this._zTime = e),
                  this._onUpdate && !t && (g && Ie(this, e, 0, i),
                  pt(this, "onUpdate")),
                  this._repeat && s !== o && this.vars.onRepeat && !t && this.parent && pt(this, "onRepeat"),
                  v !== this._tDur && v || this._tTime !== v || (g && !this._onUpdate && Ie(this, e, 0, !0),
                  (e || !m) && (v === this._tDur && this._ts > 0 || !v && this._ts < 0) && Re(this, 1),
                  t || g && !p || !(v || p || c) || (pt(this, v === f ? "onComplete" : "onReverseComplete", !0),
                  this._prom && !(v < f && this.timeScale() > 0) && this._prom()))
              }
          } else
              !function(e, t, i, n) {
                  var r, s, a, o = e.ratio, c = t < 0 || !t && (!e._start && We(e) && (e._initted || !Xe(e)) || (e._ts < 0 || e._dp._ts < 0) && !Xe(e)) ? 0 : 1, u = e._rDelay, h = 0;
                  if (u && e._repeat && (h = Je(0, e._tDur, t),
                  s = Oe(h, u),
                  e._yoyo && 1 & s && (c = 1 - c),
                  s !== Oe(e._tTime, u) && (o = 1 - c,
                  e.vars.repeatRefresh && e._initted && e.invalidate())),
                  c !== o || l || n || e._zTime === b || !t && e._zTime) {
                      if (!e._initted && Ge(e, t, n, i, h))
                          return;
                      for (a = e._zTime,
                      e._zTime = t || (i ? b : 0),
                      i || (i = t && !a),
                      e.ratio = c,
                      e._from && (c = 1 - c),
                      e._time = 0,
                      e._tTime = h,
                      r = e._pt; r; )
                          r.r(c, r.d),
                          r = r._next;
                      t < 0 && Ie(e, t, 0, !0),
                      e._onUpdate && !i && pt(e, "onUpdate"),
                      h && e._repeat && !i && e.parent && pt(e, "onRepeat"),
                      (t >= e._tDur || t < 0) && e.ratio === c && (c && Re(e, 1),
                      i || l || (pt(e, c ? "onComplete" : "onReverseComplete", !0),
                      e._prom && e._prom()))
                  } else
                      e._zTime || (e._zTime = t)
              }(this, e, t, i);
          return this
      }
      ,
      i.targets = function() {
          return this._targets
      }
      ,
      i.invalidate = function(t) {
          return (!t || !this.vars.runBackwards) && (this._startAt = 0),
          this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
          this._ptLookup = [],
          this.timeline && this.timeline.invalidate(t),
          e.prototype.invalidate.call(this, t)
      }
      ,
      i.resetTo = function(e, t, i, n, r) {
          v || wt.wake(),
          this._ts || this.play();
          var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
          return this._initted || jt(this, s),
          function(e, t, i, n, r, s, a, o) {
              var l, c, u, h, d = (e._pt && e._ptCache || (e._ptCache = {}))[t];
              if (!d)
                  for (d = e._ptCache[t] = [],
                  u = e._ptLookup,
                  h = e._targets.length; h--; ) {
                      if ((l = u[h][t]) && l.d && l.d._pt)
                          for (l = l.d._pt; l && l.p !== t && l.fp !== t; )
                              l = l._next;
                      if (!l)
                          return Gt = 1,
                          e.vars[t] = "+=0",
                          jt(e, a),
                          Gt = 0,
                          o ? J(t + " not eligible for reset") : 1;
                      d.push(l)
                  }
              for (h = d.length; h--; )
                  (l = (c = d[h])._pt || c).s = !n && 0 !== n || r ? l.s + (n || 0) + s * l.c : n,
                  l.c = i - l.s,
                  c.e && (c.e = ge(i) + Qe(c.e)),
                  c.b && (c.b = l.s + Qe(c.b))
          }(this, e, t, i, n, this._ease(s / this._dur), s, r) ? this.resetTo(e, t, i, n, 1) : (ze(this, 0),
          this.parent || Ae(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
          this.render(0))
      }
      ,
      i.kill = function(e, t) {
          if (void 0 === t && (t = "all"),
          !(e || t && "all" !== t))
              return this._lazy = this._pt = 0,
              this.parent ? ft(this) : this;
          if (this.timeline) {
              var i = this.timeline.totalDuration();
              return this.timeline.killTweensOf(e, t, Ht && !0 !== Ht.vars.overwrite)._first || ft(this),
              this.parent && i !== this.timeline.totalDuration() && qe(this, this._dur * this.timeline._tDur / i, 0, 1),
              this
          }
          var n, r, s, a, o, l, c, u = this._targets, h = e ? it(e) : u, d = this._ptLookup, p = this._pt;
          if ((!t || "all" === t) && function(e, t) {
              for (var i = e.length, n = i === t.length; n && i-- && e[i] === t[i]; )
                  ;
              return i < 0
          }(u, h))
              return "all" === t && (this._pt = 0),
              ft(this);
          for (n = this._op = this._op || [],
          "all" !== t && (R(t) && (o = {},
          me(t, (function(e) {
              return o[e] = 1
          }
          )),
          t = o),
          t = function(e, t) {
              var i, n, r, s, a = e[0] ? pe(e[0]).harness : 0, o = a && a.aliases;
              if (!o)
                  return t;
              for (n in i = Te({}, t),
              o)
                  if (n in i)
                      for (r = (s = o[n].split(",")).length; r--; )
                          i[s[r]] = i[n];
              return i
          }(u, t)),
          c = u.length; c--; )
              if (~h.indexOf(u[c]))
                  for (o in r = d[c],
                  "all" === t ? (n[c] = t,
                  a = r,
                  s = {}) : (s = n[c] = n[c] || {},
                  a = t),
                  a)
                      (l = r && r[o]) && ("kill"in l.d && !0 !== l.d.kill(o) || Pe(this, l, "_pt"),
                      delete r[o]),
                      "all" !== s && (s[o] = 1);
          return this._initted && !this._pt && p && ft(this),
          this
      }
      ,
      t.to = function(e, i) {
          return new t(e,i,arguments[2])
      }
      ,
      t.from = function(e, t) {
          return Ze(1, arguments)
      }
      ,
      t.delayedCall = function(e, i, n, r) {
          return new t(i,0,{
              immediateRender: !1,
              lazy: !1,
              overwrite: !1,
              delay: e,
              onComplete: i,
              onReverseComplete: i,
              onCompleteParams: n,
              onReverseCompleteParams: n,
              callbackScope: r
          })
      }
      ,
      t.fromTo = function(e, t, i) {
          return Ze(2, arguments)
      }
      ,
      t.set = function(e, i) {
          return i.duration = 0,
          i.repeatDelay || (i.repeat = 0),
          new t(e,i)
      }
      ,
      t.killTweensOf = function(e, t, i) {
          return u.killTweensOf(e, t, i)
      }
      ,
      t
  }(kt);
  be(Jt.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
  }),
  me("staggerTo,staggerFrom,staggerFromTo", (function(e) {
      Jt[e] = function() {
          var t = new Vt
            , i = et.call(arguments, 0);
          return i.splice("staggerFromTo" === e ? 5 : 4, 0, 0),
          t[e].apply(t, i)
      }
  }
  ));
  var Qt = function(e, t, i) {
      return e[t] = i
  }
    , ei = function(e, t, i) {
      return e[t](i)
  }
    , ti = function(e, t, i, n) {
      return e[t](n.fp, i)
  }
    , ii = function(e, t, i) {
      return e.setAttribute(t, i)
  }
    , ni = function(e, t) {
      return L(e[t]) ? ei : N(e[t]) && e.setAttribute ? ii : Qt
  }
    , ri = function(e, t) {
      return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
  }
    , si = function(e, t) {
      return t.set(t.t, t.p, !!(t.s + t.c * e), t)
  }
    , ai = function(e, t) {
      var i = t._pt
        , n = "";
      if (!e && t.b)
          n = t.b;
      else if (1 === e && t.e)
          n = t.e;
      else {
          for (; i; )
              n = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round(1e4 * (i.s + i.c * e)) / 1e4) + n,
              i = i._next;
          n += t.c
      }
      t.set(t.t, t.p, n, t)
  }
    , oi = function(e, t) {
      for (var i = t._pt; i; )
          i.r(e, i.d),
          i = i._next
  }
    , li = function(e, t, i, n) {
      for (var r, s = this._pt; s; )
          r = s._next,
          s.p === n && s.modifier(e, t, i),
          s = r
  }
    , ci = function(e) {
      for (var t, i, n = this._pt; n; )
          i = n._next,
          n.p === e && !n.op || n.op === e ? Pe(this, n, "_pt") : n.dep || (t = 1),
          n = i;
      return !t
  }
    , ui = function(e, t, i, n) {
      n.mSet(e, t, n.m.call(n.tween, i, n.mt), n)
  }
    , hi = function(e) {
      for (var t, i, n, r, s = e._pt; s; ) {
          for (t = s._next,
          i = n; i && i.pr > s.pr; )
              i = i._next;
          (s._prev = i ? i._prev : r) ? s._prev._next = s : n = s,
          (s._next = i) ? i._prev = s : r = s,
          s = t
      }
      e._pt = n
  }
    , di = function() {
      function e(e, t, i, n, r, s, a, o, l) {
          this.t = t,
          this.s = n,
          this.c = r,
          this.p = i,
          this.r = s || ri,
          this.d = a || this,
          this.set = o || Qt,
          this.pr = l || 0,
          this._next = e,
          e && (e._prev = this)
      }
      return e.prototype.modifier = function(e, t, i) {
          this.mSet = this.mSet || this.set,
          this.set = ui,
          this.m = e,
          this.mt = i,
          this.tween = t
      }
      ,
      e
  }();
  me(he + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(e) {
      return re[e] = 1
  }
  )),
  Y.TweenMax = Y.TweenLite = Jt,
  Y.TimelineLite = Y.TimelineMax = Vt,
  u = new Vt({
      sortChildren: !1,
      defaults: E,
      autoRemoveChildren: !0,
      id: "root",
      smoothChildTiming: !0
  }),
  S.stringFilter = Tt;
  var pi = []
    , fi = {}
    , mi = []
    , gi = 0
    , vi = 0
    , _i = function(e) {
      return (fi[e] || mi).map((function(e) {
          return e()
      }
      ))
  }
    , yi = function() {
      var e = Date.now()
        , t = [];
      e - gi > 2 && (_i("matchMediaInit"),
      pi.forEach((function(e) {
          var i, n, r, s, a = e.queries, o = e.conditions;
          for (n in a)
              (i = h.matchMedia(a[n]).matches) && (r = 1),
              i !== o[n] && (o[n] = i,
              s = 1);
          s && (e.revert(),
          r && t.push(e))
      }
      )),
      _i("matchMediaRevert"),
      t.forEach((function(e) {
          return e.onMatch(e, (function(t) {
              return e.add(null, t)
          }
          ))
      }
      )),
      gi = e,
      _i("matchMedia"))
  }
    , xi = function() {
      function e(e, t) {
          this.selector = t && nt(t),
          this.data = [],
          this._r = [],
          this.isReverted = !1,
          this.id = vi++,
          e && this.add(e)
      }
      var t = e.prototype;
      return t.add = function(e, t, i) {
          L(e) && (i = t,
          t = e,
          e = L);
          var n = this
            , r = function() {
              var e, r = c, s = n.selector;
              return r && r !== n && r.data.push(n),
              i && (n.selector = nt(i)),
              c = n,
              e = t.apply(n, arguments),
              L(e) && n._r.push(e),
              c = r,
              n.selector = s,
              n.isReverted = !1,
              e
          };
          return n.last = r,
          e === L ? r(n, (function(e) {
              return n.add(null, e)
          }
          )) : e ? n[e] = r : r
      }
      ,
      t.ignore = function(e) {
          var t = c;
          c = null,
          e(this),
          c = t
      }
      ,
      t.getTweens = function() {
          var t = [];
          return this.data.forEach((function(i) {
              return i instanceof e ? t.push.apply(t, i.getTweens()) : i instanceof Jt && !(i.parent && "nested" === i.parent.data) && t.push(i)
          }
          )),
          t
      }
      ,
      t.clear = function() {
          this._r.length = this.data.length = 0
      }
      ,
      t.kill = function(e, t) {
          var i = this;
          if (e ? function() {
              for (var t, n = i.getTweens(), r = i.data.length; r--; )
                  "isFlip" === (t = i.data[r]).data && (t.revert(),
                  t.getChildren(!0, !0, !1).forEach((function(e) {
                      return n.splice(n.indexOf(e), 1)
                  }
                  )));
              for (n.map((function(e) {
                  return {
                      g: e._dur || e._delay || e._sat && !e._sat.vars.immediateRender ? e.globalTime(0) : -1 / 0,
                      t: e
                  }
              }
              )).sort((function(e, t) {
                  return t.g - e.g || -1 / 0
              }
              )).forEach((function(t) {
                  return t.t.revert(e)
              }
              )),
              r = i.data.length; r--; )
                  (t = i.data[r])instanceof Vt ? "nested" !== t.data && (t.scrollTrigger && t.scrollTrigger.revert(),
                  t.kill()) : !(t instanceof Jt) && t.revert && t.revert(e);
              i._r.forEach((function(t) {
                  return t(e, i)
              }
              )),
              i.isReverted = !0
          }() : this.data.forEach((function(e) {
              return e.kill && e.kill()
          }
          )),
          this.clear(),
          t)
              for (var n = pi.length; n--; )
                  pi[n].id === this.id && pi.splice(n, 1)
      }
      ,
      t.revert = function(e) {
          this.kill(e || {})
      }
      ,
      e
  }()
    , Si = function() {
      function e(e) {
          this.contexts = [],
          this.scope = e,
          c && c.data.push(this)
      }
      var t = e.prototype;
      return t.add = function(e, t, i) {
          F(e) || (e = {
              matches: e
          });
          var n, r, s, a = new xi(0,i || this.scope), o = a.conditions = {};
          for (r in c && !a.selector && (a.selector = c.selector),
          this.contexts.push(a),
          t = a.add("onMatch", t),
          a.queries = e,
          e)
              "all" === r ? s = 1 : (n = h.matchMedia(e[r])) && (pi.indexOf(a) < 0 && pi.push(a),
              (o[r] = n.matches) && (s = 1),
              n.addListener ? n.addListener(yi) : n.addEventListener("change", yi));
          return s && t(a, (function(e) {
              return a.add(null, e)
          }
          )),
          this
      }
      ,
      t.revert = function(e) {
          this.kill(e || {})
      }
      ,
      t.kill = function(e) {
          this.contexts.forEach((function(t) {
              return t.kill(e, !0)
          }
          ))
      }
      ,
      e
  }()
    , Ei = {
      registerPlugin: function() {
          for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
              t[i] = arguments[i];
          t.forEach((function(e) {
              return gt(e)
          }
          ))
      },
      timeline: function(e) {
          return new Vt(e)
      },
      getTweensOf: function(e, t) {
          return u.getTweensOf(e, t)
      },
      getProperty: function(e, t, i, n) {
          R(e) && (e = it(e)[0]);
          var r = pe(e || {}).get
            , s = i ? Me : Ee;
          return "native" === i && (i = ""),
          e ? t ? s((oe[t] && oe[t].get || r)(e, t, i, n)) : function(t, i, n) {
              return s((oe[t] && oe[t].get || r)(e, t, i, n))
          }
          : e
      },
      quickSetter: function(e, t, i) {
          if ((e = it(e)).length > 1) {
              var n = e.map((function(e) {
                  return Ti.quickSetter(e, t, i)
              }
              ))
                , r = n.length;
              return function(e) {
                  for (var t = r; t--; )
                      n[t](e)
              }
          }
          e = e[0] || {};
          var s = oe[t]
            , a = pe(e)
            , o = a.harness && (a.harness.aliases || {})[t] || t
            , l = s ? function(t) {
              var n = new s;
              g._pt = 0,
              n.init(e, i ? t + i : t, g, 0, [e]),
              n.render(1, n),
              g._pt && oi(1, g)
          }
          : a.set(e, o);
          return s ? l : function(t) {
              return l(e, o, i ? t + i : t, a, 1)
          }
      },
      quickTo: function(e, t, i) {
          var n, r = Ti.to(e, Te(((n = {})[t] = "+=0.1",
          n.paused = !0,
          n), i || {})), s = function(e, i, n) {
              return r.resetTo(t, e, i, n)
          };
          return s.tween = r,
          s
      },
      isTweening: function(e) {
          return u.getTweensOf(e, !0).length > 0
      },
      defaults: function(e) {
          return e && e.ease && (e.ease = Nt(e.ease, E.ease)),
          we(E, e || {})
      },
      config: function(e) {
          return we(S, e || {})
      },
      registerEffect: function(e) {
          var t = e.name
            , i = e.effect
            , n = e.plugins
            , r = e.defaults
            , s = e.extendTimeline;
          (n || "").split(",").forEach((function(e) {
              return e && !oe[e] && !Y[e] && J(t + " effect requires " + e + " plugin.")
          }
          )),
          le[t] = function(e, t, n) {
              return i(it(e), be(t || {}, r), n)
          }
          ,
          s && (Vt.prototype[t] = function(e, i, n) {
              return this.add(le[t](e, F(i) ? i : (n = i) && {}, this), n)
          }
          )
      },
      registerEase: function(e, t) {
          Ct[e] = Nt(t)
      },
      parseEase: function(e, t) {
          return arguments.length ? Nt(e, t) : Ct
      },
      getById: function(e) {
          return u.getById(e)
      },
      exportRoot: function(e, t) {
          void 0 === e && (e = {});
          var i, n, r = new Vt(e);
          for (r.smoothChildTiming = O(e.smoothChildTiming),
          u.remove(r),
          r._dp = 0,
          r._time = r._tTime = u._time,
          i = u._first; i; )
              n = i._next,
              !t && !i._dur && i instanceof Jt && i.vars.onComplete === i._targets[0] || Ve(r, i, i._start - i._delay),
              i = n;
          return Ve(u, r, 0),
          r
      },
      context: function(e, t) {
          return e ? new xi(e,t) : c
      },
      matchMedia: function(e) {
          return new Si(e)
      },
      matchMediaRefresh: function() {
          return pi.forEach((function(e) {
              var t, i, n = e.conditions;
              for (i in n)
                  n[i] && (n[i] = !1,
                  t = 1);
              t && e.revert()
          }
          )) || yi()
      },
      addEventListener: function(e, t) {
          var i = fi[e] || (fi[e] = []);
          ~i.indexOf(t) || i.push(t)
      },
      removeEventListener: function(e, t) {
          var i = fi[e]
            , n = i && i.indexOf(t);
          n >= 0 && i.splice(n, 1)
      },
      utils: {
          wrap: function e(t, i, n) {
              var r = i - t;
              return k(t) ? ct(t, e(0, t.length), i) : $e(n, (function(e) {
                  return (r + (e - t) % r) % r + t
              }
              ))
          },
          wrapYoyo: function e(t, i, n) {
              var r = i - t
                , s = 2 * r;
              return k(t) ? ct(t, e(0, t.length - 1), i) : $e(n, (function(e) {
                  return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e)
              }
              ))
          },
          distribute: st,
          random: lt,
          snap: ot,
          normalize: function(e, t, i) {
              return ht(e, t, 0, 1, i)
          },
          getUnit: Qe,
          clamp: function(e, t, i) {
              return $e(i, (function(i) {
                  return Je(e, t, i)
              }
              ))
          },
          splitColor: xt,
          toArray: it,
          selector: nt,
          mapRange: ht,
          pipe: function() {
              for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                  t[i] = arguments[i];
              return function(e) {
                  return t.reduce((function(e, t) {
                      return t(e)
                  }
                  ), e)
              }
          },
          unitize: function(e, t) {
              return function(i) {
                  return e(parseFloat(i)) + (t || Qe(i))
              }
          },
          interpolate: function e(t, i, n, r) {
              var s = isNaN(t + i) ? 0 : function(e) {
                  return (1 - e) * t + e * i
              }
              ;
              if (!s) {
                  var a, o, l, c, u, h = R(t), d = {};
                  if (!0 === n && (r = 1) && (n = null),
                  h)
                      t = {
                          p: t
                      },
                      i = {
                          p: i
                      };
                  else if (k(t) && !k(i)) {
                      for (l = [],
                      c = t.length,
                      u = c - 2,
                      o = 1; o < c; o++)
                          l.push(e(t[o - 1], t[o]));
                      c--,
                      s = function(e) {
                          e *= c;
                          var t = Math.min(u, ~~e);
                          return l[t](e - t)
                      }
                      ,
                      n = i
                  } else
                      r || (t = Te(k(t) ? [] : {}, t));
                  if (!l) {
                      for (a in i)
                          Xt.call(d, t, a, "get", i[a]);
                      s = function(e) {
                          return oi(e, d) || (h ? t.p : t)
                      }
                  }
              }
              return $e(n, s)
          },
          shuffle: rt
      },
      install: Z,
      effects: le,
      ticker: wt,
      updateRoot: Vt.updateRoot,
      plugins: oe,
      globalTimeline: u,
      core: {
          PropTween: di,
          globals: Q,
          Tween: Jt,
          Timeline: Vt,
          Animation: kt,
          getCache: pe,
          _removeLinkedListItem: Pe,
          reverting: function() {
              return l
          },
          context: function(e) {
              return e && c && (c.data.push(e),
              e._ctx = c),
              c
          },
          suppressOverwrites: function(e) {
              return o = e
          }
      }
  };
  me("to,from,fromTo,delayedCall,set,killTweensOf", (function(e) {
      return Ei[e] = Jt[e]
  }
  )),
  wt.add(Vt.updateRoot),
  g = Ei.to({}, {
      duration: 0
  });
  var Mi = function(e, t) {
      for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
          i = i._next;
      return i
  }
    , bi = function(e, t) {
      return {
          name: e,
          rawVars: 1,
          init: function(e, i, n) {
              n._onInit = function(e) {
                  var n, r;
                  if (R(i) && (n = {},
                  me(i, (function(e) {
                      return n[e] = 1
                  }
                  )),
                  i = n),
                  t) {
                      for (r in n = {},
                      i)
                          n[r] = t(i[r]);
                      i = n
                  }
                  !function(e, t) {
                      var i, n, r, s = e._targets;
                      for (i in t)
                          for (n = s.length; n--; )
                              (r = e._ptLookup[n][i]) && (r = r.d) && (r._pt && (r = Mi(r, i)),
                              r && r.modifier && r.modifier(t[i], e, s[n], i))
                  }(e, i)
              }
          }
      }
  }
    , Ti = Ei.registerPlugin({
      name: "attr",
      init: function(e, t, i, n, r) {
          var s, a, o;
          for (s in this.tween = i,
          t)
              o = e.getAttribute(s) || "",
              (a = this.add(e, "setAttribute", (o || 0) + "", t[s], n, r, 0, 0, s)).op = s,
              a.b = o,
              this._props.push(s)
      },
      render: function(e, t) {
          for (var i = t._pt; i; )
              l ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d),
              i = i._next
      }
  }, {
      name: "endArray",
      init: function(e, t) {
          for (var i = t.length; i--; )
              this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1)
      }
  }, bi("roundProps", at), bi("modifiers"), bi("snap", ot)) || Ei;
  Jt.version = Vt.version = Ti.version = "3.12.5",
  f = 1,
  U() && Dt(),
  Ct.Power0,
  Ct.Power1,
  Ct.Power2,
  Ct.Power3,
  Ct.Power4,
  Ct.Linear,
  Ct.Quad,
  Ct.Cubic,
  Ct.Quart,
  Ct.Quint,
  Ct.Strong,
  Ct.Elastic,
  Ct.Back,
  Ct.SteppedEase,
  Ct.Bounce,
  Ct.Sine,
  Ct.Expo,
  Ct.Circ;
  var wi, Di, Ci, Ai, Pi, Ri, Li, Ii, Ni = {}, Fi = 180 / Math.PI, Oi = Math.PI / 180, Ui = Math.atan2, Bi = /([A-Z])/g, zi = /(left|right|width|margin|padding|x)/i, ki = /[\s,\(]\S/, Vi = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
  }, Hi = function(e, t) {
      return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
  }, Gi = function(e, t) {
      return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
  }, Wi = function(e, t) {
      return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
  }, Xi = function(e, t) {
      var i = t.s + t.c * e;
      t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
  }, qi = function(e, t) {
      return t.set(t.t, t.p, e ? t.e : t.b, t)
  }, ji = function(e, t) {
      return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
  }, Yi = function(e, t, i) {
      return e.style[t] = i
  }, Ki = function(e, t, i) {
      return e.style.setProperty(t, i)
  }, Zi = function(e, t, i) {
      return e._gsap[t] = i
  }, $i = function(e, t, i) {
      return e._gsap.scaleX = e._gsap.scaleY = i
  }, Ji = function(e, t, i, n, r) {
      var s = e._gsap;
      s.scaleX = s.scaleY = i,
      s.renderTransform(r, s)
  }, Qi = function(e, t, i, n, r) {
      var s = e._gsap;
      s[t] = i,
      s.renderTransform(r, s)
  }, en = "transform", tn = en + "Origin", nn = function e(t, i) {
      var n = this
        , r = this.target
        , s = r.style
        , a = r._gsap;
      if (t in Ni && s) {
          if (this.tfm = this.tfm || {},
          "transform" === t)
              return Vi.transform.split(",").forEach((function(t) {
                  return e.call(n, t, i)
              }
              ));
          if (~(t = Vi[t] || t).indexOf(",") ? t.split(",").forEach((function(e) {
              return n.tfm[e] = Sn(r, e)
          }
          )) : this.tfm[t] = a.x ? a[t] : Sn(r, t),
          t === tn && (this.tfm.zOrigin = a.zOrigin),
          this.props.indexOf(en) >= 0)
              return;
          a.svg && (this.svgo = r.getAttribute("data-svg-origin"),
          this.props.push(tn, i, "")),
          t = en
      }
      (s || i) && this.props.push(t, i, s[t])
  }, rn = function(e) {
      e.translate && (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"))
  }, sn = function() {
      var e, t, i = this.props, n = this.target, r = n.style, s = n._gsap;
      for (e = 0; e < i.length; e += 3)
          i[e + 1] ? n[i[e]] = i[e + 2] : i[e + 2] ? r[i[e]] = i[e + 2] : r.removeProperty("--" === i[e].substr(0, 2) ? i[e] : i[e].replace(Bi, "-$1").toLowerCase());
      if (this.tfm) {
          for (t in this.tfm)
              s[t] = this.tfm[t];
          s.svg && (s.renderTransform(),
          n.setAttribute("data-svg-origin", this.svgo || "")),
          (e = Li()) && e.isStart || r[en] || (rn(r),
          s.zOrigin && r[tn] && (r[tn] += " " + s.zOrigin + "px",
          s.zOrigin = 0,
          s.renderTransform()),
          s.uncache = 1)
      }
  }, an = function(e, t) {
      var i = {
          target: e,
          props: [],
          revert: sn,
          save: nn
      };
      return e._gsap || Ti.core.getCache(e),
      t && t.split(",").forEach((function(e) {
          return i.save(e)
      }
      )),
      i
  }, on = function(e, t) {
      var i = Di.createElementNS ? Di.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Di.createElement(e);
      return i && i.style ? i : Di.createElement(e)
  }, ln = function e(t, i, n) {
      var r = getComputedStyle(t);
      return r[i] || r.getPropertyValue(i.replace(Bi, "-$1").toLowerCase()) || r.getPropertyValue(i) || !n && e(t, un(i) || i, 1) || ""
  }, cn = "O,Moz,ms,Ms,Webkit".split(","), un = function(e, t, i) {
      var n = (t || Pi).style
        , r = 5;
      if (e in n && !i)
          return e;
      for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(cn[r] + e in n); )
          ;
      return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? cn[r] : "") + e
  }, hn = function() {
      "undefined" != typeof window && window.document && (wi = window,
      Di = wi.document,
      Ci = Di.documentElement,
      Pi = on("div") || {
          style: {}
      },
      on("div"),
      en = un(en),
      tn = en + "Origin",
      Pi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
      Ii = !!un("perspective"),
      Li = Ti.core.reverting,
      Ai = 1)
  }, dn = function e(t) {
      var i, n = on("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
      if (Ci.appendChild(n),
      n.appendChild(this),
      this.style.display = "block",
      t)
          try {
              i = this.getBBox(),
              this._gsapBBox = this.getBBox,
              this.getBBox = e
          } catch (e) {}
      else
          this._gsapBBox && (i = this._gsapBBox());
      return r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
      Ci.removeChild(n),
      this.style.cssText = a,
      i
  }, pn = function(e, t) {
      for (var i = t.length; i--; )
          if (e.hasAttribute(t[i]))
              return e.getAttribute(t[i])
  }, fn = function(e) {
      var t;
      try {
          t = e.getBBox()
      } catch (i) {
          t = dn.call(e, !0)
      }
      return t && (t.width || t.height) || e.getBBox === dn || (t = dn.call(e, !0)),
      !t || t.width || t.x || t.y ? t : {
          x: +pn(e, ["x", "cx", "x1"]) || 0,
          y: +pn(e, ["y", "cy", "y1"]) || 0,
          width: 0,
          height: 0
      }
  }, mn = function(e) {
      return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !fn(e))
  }, gn = function(e, t) {
      if (t) {
          var i, n = e.style;
          t in Ni && t !== tn && (t = en),
          n.removeProperty ? ("ms" !== (i = t.substr(0, 2)) && "webkit" !== t.substr(0, 6) || (t = "-" + t),
          n.removeProperty("--" === i ? t : t.replace(Bi, "-$1").toLowerCase())) : n.removeAttribute(t)
      }
  }, vn = function(e, t, i, n, r, s) {
      var a = new di(e._pt,t,i,0,1,s ? ji : qi);
      return e._pt = a,
      a.b = n,
      a.e = r,
      e._props.push(i),
      a
  }, _n = {
      deg: 1,
      rad: 1,
      turn: 1
  }, yn = {
      grid: 1,
      flex: 1
  }, xn = function e(t, i, n, r) {
      var s, a, o, l, c = parseFloat(n) || 0, u = (n + "").trim().substr((c + "").length) || "px", h = Pi.style, d = zi.test(i), p = "svg" === t.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
      if (r === u || !c || _n[r] || _n[u])
          return c;
      if ("px" !== u && !g && (c = e(t, i, n, "px")),
      l = t.getCTM && mn(t),
      (v || "%" === u) && (Ni[i] || ~i.indexOf("adius")))
          return s = l ? t.getBBox()[d ? "width" : "height"] : t[f],
          ge(v ? c / s * m : c / 100 * s);
      if (h[d ? "width" : "height"] = m + (g ? u : r),
      a = ~i.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode,
      l && (a = (t.ownerSVGElement || {}).parentNode),
      a && a !== Di && a.appendChild || (a = Di.body),
      (o = a._gsap) && v && o.width && d && o.time === wt.time && !o.uncache)
          return ge(c / o.width * m);
      if (!v || "height" !== i && "width" !== i)
          (v || "%" === u) && !yn[ln(a, "display")] && (h.position = ln(t, "position")),
          a === t && (h.position = "static"),
          a.appendChild(Pi),
          s = Pi[f],
          a.removeChild(Pi),
          h.position = "absolute";
      else {
          var _ = t.style[i];
          t.style[i] = m + r,
          s = t[f],
          _ ? t.style[i] = _ : gn(t, i)
      }
      return d && v && ((o = pe(a)).time = wt.time,
      o.width = a[f]),
      ge(g ? s * c / m : s && c ? m / s * c : 0)
  }, Sn = function(e, t, i, n) {
      var r;
      return Ai || hn(),
      t in Vi && "transform" !== t && ~(t = Vi[t]).indexOf(",") && (t = t.split(",")[0]),
      Ni[t] && "transform" !== t ? (r = Ln(e, n),
      r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : In(ln(e, tn)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || n || ~(r + "").indexOf("calc(")) && (r = Tn[t] && Tn[t](e, t, i) || ln(e, t) || fe(e, t) || ("opacity" === t ? 1 : 0)),
      i && !~(r + "").trim().indexOf(" ") ? xn(e, t, r, i) + i : r
  }, En = function(e, t, i, n) {
      if (!i || "none" === i) {
          var r = un(t, e, 1)
            , s = r && ln(e, r, 1);
          s && s !== i ? (t = r,
          i = s) : "borderColor" === t && (i = ln(e, "borderTopColor"))
      }
      var a, o, l, c, u, h, d, p, f, m, g, v = new di(this._pt,e.style,t,0,1,ai), _ = 0, y = 0;
      if (v.b = i,
      v.e = n,
      i += "",
      "auto" == (n += "") && (h = e.style[t],
      e.style[t] = n,
      n = ln(e, t) || n,
      h ? e.style[t] = h : gn(e, t)),
      Tt(a = [i, n]),
      n = a[1],
      l = (i = a[0]).match(G) || [],
      (n.match(G) || []).length) {
          for (; o = G.exec(n); )
              d = o[0],
              f = n.substring(_, o.index),
              u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1),
              d !== (h = l[y++] || "") && (c = parseFloat(h) || 0,
              g = h.substr((c + "").length),
              "=" === d.charAt(1) && (d = _e(c, d) + g),
              p = parseFloat(d),
              m = d.substr((p + "").length),
              _ = G.lastIndex - m.length,
              m || (m = m || S.units[t] || g,
              _ === n.length && (n += m,
              v.e += m)),
              g !== m && (c = xn(e, t, h, m) || 0),
              v._pt = {
                  _next: v._pt,
                  p: f || 1 === y ? f : ",",
                  s: c,
                  c: p - c,
                  m: u && u < 4 || "zIndex" === t ? Math.round : 0
              });
          v.c = _ < n.length ? n.substring(_, n.length) : ""
      } else
          v.r = "display" === t && "none" === n ? ji : qi;
      return X.test(n) && (v.e = 0),
      this._pt = v,
      v
  }, Mn = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
  }, bn = function(e, t) {
      if (t.tween && t.tween._time === t.tween._dur) {
          var i, n, r, s = t.t, a = s.style, o = t.u, l = s._gsap;
          if ("all" === o || !0 === o)
              a.cssText = "",
              n = 1;
          else
              for (r = (o = o.split(",")).length; --r > -1; )
                  i = o[r],
                  Ni[i] && (n = 1,
                  i = "transformOrigin" === i ? tn : en),
                  gn(s, i);
          n && (gn(s, en),
          l && (l.svg && s.removeAttribute("transform"),
          Ln(s, 1),
          l.uncache = 1,
          rn(a)))
      }
  }, Tn = {
      clearProps: function(e, t, i, n, r) {
          if ("isFromStart" !== r.data) {
              var s = e._pt = new di(e._pt,t,i,0,0,bn);
              return s.u = n,
              s.pr = -10,
              s.tween = r,
              e._props.push(i),
              1
          }
      }
  }, wn = [1, 0, 0, 1, 0, 0], Dn = {}, Cn = function(e) {
      return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
  }, An = function(e) {
      var t = ln(e, en);
      return Cn(t) ? wn : t.substr(7).match(H).map(ge)
  }, Pn = function(e, t) {
      var i, n, r, s, a = e._gsap || pe(e), o = e.style, l = An(e);
      return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? wn : l : (l !== wn || e.offsetParent || e === Ci || a.svg || (r = o.display,
      o.display = "block",
      (i = e.parentNode) && e.offsetParent || (s = 1,
      n = e.nextElementSibling,
      Ci.appendChild(e)),
      l = An(e),
      r ? o.display = r : gn(e, "display"),
      s && (n ? i.insertBefore(e, n) : i ? i.appendChild(e) : Ci.removeChild(e))),
      t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
  }, Rn = function(e, t, i, n, r, s) {
      var a, o, l, c = e._gsap, u = r || Pn(e, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = u[0], g = u[1], v = u[2], _ = u[3], y = u[4], x = u[5], S = t.split(" "), E = parseFloat(S[0]) || 0, M = parseFloat(S[1]) || 0;
      i ? u !== wn && (o = m * _ - g * v) && (l = E * (-g / o) + M * (m / o) - (m * x - g * y) / o,
      E = E * (_ / o) + M * (-v / o) + (v * x - _ * y) / o,
      M = l) : (E = (a = fn(e)).x + (~S[0].indexOf("%") ? E / 100 * a.width : E),
      M = a.y + (~(S[1] || S[0]).indexOf("%") ? M / 100 * a.height : M)),
      n || !1 !== n && c.smooth ? (y = E - h,
      x = M - d,
      c.xOffset = p + (y * m + x * v) - y,
      c.yOffset = f + (y * g + x * _) - x) : c.xOffset = c.yOffset = 0,
      c.xOrigin = E,
      c.yOrigin = M,
      c.smooth = !!n,
      c.origin = t,
      c.originIsAbsolute = !!i,
      e.style[tn] = "0px 0px",
      s && (vn(s, c, "xOrigin", h, E),
      vn(s, c, "yOrigin", d, M),
      vn(s, c, "xOffset", p, c.xOffset),
      vn(s, c, "yOffset", f, c.yOffset)),
      e.setAttribute("data-svg-origin", E + " " + M)
  }, Ln = function(e, t) {
      var i = e._gsap || new zt(e);
      if ("x"in i && !t && !i.uncache)
          return i;
      var n, r, s, a, o, l, c, u, h, d, p, f, m, g, v, _, y, x, E, M, b, T, w, D, C, A, P, R, L, I, N, F, O = e.style, U = i.scaleX < 0, B = "px", z = "deg", k = getComputedStyle(e), V = ln(e, tn) || "0";
      return n = r = s = l = c = u = h = d = p = 0,
      a = o = 1,
      i.svg = !(!e.getCTM || !mn(e)),
      k.translate && ("none" === k.translate && "none" === k.scale && "none" === k.rotate || (O[en] = ("none" !== k.translate ? "translate3d(" + (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") + ("none" !== k.scale ? "scale(" + k.scale.split(" ").join(",") + ") " : "") + ("none" !== k[en] ? k[en] : "")),
      O.scale = O.rotate = O.translate = "none"),
      g = Pn(e, i.svg),
      i.svg && (i.uncache ? (C = e.getBBox(),
      V = i.xOrigin - C.x + "px " + (i.yOrigin - C.y) + "px",
      D = "") : D = !t && e.getAttribute("data-svg-origin"),
      Rn(e, D || V, !!D || i.originIsAbsolute, !1 !== i.smooth, g)),
      f = i.xOrigin || 0,
      m = i.yOrigin || 0,
      g !== wn && (x = g[0],
      E = g[1],
      M = g[2],
      b = g[3],
      n = T = g[4],
      r = w = g[5],
      6 === g.length ? (a = Math.sqrt(x * x + E * E),
      o = Math.sqrt(b * b + M * M),
      l = x || E ? Ui(E, x) * Fi : 0,
      (h = M || b ? Ui(M, b) * Fi + l : 0) && (o *= Math.abs(Math.cos(h * Oi))),
      i.svg && (n -= f - (f * x + m * M),
      r -= m - (f * E + m * b))) : (F = g[6],
      I = g[7],
      P = g[8],
      R = g[9],
      L = g[10],
      N = g[11],
      n = g[12],
      r = g[13],
      s = g[14],
      c = (v = Ui(F, L)) * Fi,
      v && (D = T * (_ = Math.cos(-v)) + P * (y = Math.sin(-v)),
      C = w * _ + R * y,
      A = F * _ + L * y,
      P = T * -y + P * _,
      R = w * -y + R * _,
      L = F * -y + L * _,
      N = I * -y + N * _,
      T = D,
      w = C,
      F = A),
      u = (v = Ui(-M, L)) * Fi,
      v && (_ = Math.cos(-v),
      N = b * (y = Math.sin(-v)) + N * _,
      x = D = x * _ - P * y,
      E = C = E * _ - R * y,
      M = A = M * _ - L * y),
      l = (v = Ui(E, x)) * Fi,
      v && (D = x * (_ = Math.cos(v)) + E * (y = Math.sin(v)),
      C = T * _ + w * y,
      E = E * _ - x * y,
      w = w * _ - T * y,
      x = D,
      T = C),
      c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
      u = 180 - u),
      a = ge(Math.sqrt(x * x + E * E + M * M)),
      o = ge(Math.sqrt(w * w + F * F)),
      v = Ui(T, w),
      h = Math.abs(v) > 2e-4 ? v * Fi : 0,
      p = N ? 1 / (N < 0 ? -N : N) : 0),
      i.svg && (D = e.getAttribute("transform"),
      i.forceCSS = e.setAttribute("transform", "") || !Cn(ln(e, en)),
      D && e.setAttribute("transform", D))),
      Math.abs(h) > 90 && Math.abs(h) < 270 && (U ? (a *= -1,
      h += l <= 0 ? 180 : -180,
      l += l <= 0 ? 180 : -180) : (o *= -1,
      h += h <= 0 ? 180 : -180)),
      t = t || i.uncache,
      i.x = n - ((i.xPercent = n && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + B,
      i.y = r - ((i.yPercent = r && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + B,
      i.z = s + B,
      i.scaleX = ge(a),
      i.scaleY = ge(o),
      i.rotation = ge(l) + z,
      i.rotationX = ge(c) + z,
      i.rotationY = ge(u) + z,
      i.skewX = h + z,
      i.skewY = d + z,
      i.transformPerspective = p + B,
      (i.zOrigin = parseFloat(V.split(" ")[2]) || !t && i.zOrigin || 0) && (O[tn] = In(V)),
      i.xOffset = i.yOffset = 0,
      i.force3D = S.force3D,
      i.renderTransform = i.svg ? kn : Ii ? zn : Fn,
      i.uncache = 0,
      i
  }, In = function(e) {
      return (e = e.split(" "))[0] + " " + e[1]
  }, Nn = function(e, t, i) {
      var n = Qe(t);
      return ge(parseFloat(t) + parseFloat(xn(e, "x", i + "px", n))) + n
  }, Fn = function(e, t) {
      t.z = "0px",
      t.rotationY = t.rotationX = "0deg",
      t.force3D = 0,
      zn(e, t)
  }, On = "0deg", Un = "0px", Bn = ") ", zn = function(e, t) {
      var i = t || this
        , n = i.xPercent
        , r = i.yPercent
        , s = i.x
        , a = i.y
        , o = i.z
        , l = i.rotation
        , c = i.rotationY
        , u = i.rotationX
        , h = i.skewX
        , d = i.skewY
        , p = i.scaleX
        , f = i.scaleY
        , m = i.transformPerspective
        , g = i.force3D
        , v = i.target
        , _ = i.zOrigin
        , y = ""
        , x = "auto" === g && e && 1 !== e || !0 === g;
      if (_ && (u !== On || c !== On)) {
          var S, E = parseFloat(c) * Oi, M = Math.sin(E), b = Math.cos(E);
          E = parseFloat(u) * Oi,
          S = Math.cos(E),
          s = Nn(v, s, M * S * -_),
          a = Nn(v, a, -Math.sin(E) * -_),
          o = Nn(v, o, b * S * -_ + _)
      }
      m !== Un && (y += "perspective(" + m + Bn),
      (n || r) && (y += "translate(" + n + "%, " + r + "%) "),
      (x || s !== Un || a !== Un || o !== Un) && (y += o !== Un || x ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + Bn),
      l !== On && (y += "rotate(" + l + Bn),
      c !== On && (y += "rotateY(" + c + Bn),
      u !== On && (y += "rotateX(" + u + Bn),
      h === On && d === On || (y += "skew(" + h + ", " + d + Bn),
      1 === p && 1 === f || (y += "scale(" + p + ", " + f + Bn),
      v.style[en] = y || "translate(0, 0)"
  }, kn = function(e, t) {
      var i, n, r, s, a, o = t || this, l = o.xPercent, c = o.yPercent, u = o.x, h = o.y, d = o.rotation, p = o.skewX, f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, _ = o.xOrigin, y = o.yOrigin, x = o.xOffset, S = o.yOffset, E = o.forceCSS, M = parseFloat(u), b = parseFloat(h);
      d = parseFloat(d),
      p = parseFloat(p),
      (f = parseFloat(f)) && (p += f = parseFloat(f),
      d += f),
      d || p ? (d *= Oi,
      p *= Oi,
      i = Math.cos(d) * m,
      n = Math.sin(d) * m,
      r = Math.sin(d - p) * -g,
      s = Math.cos(d - p) * g,
      p && (f *= Oi,
      a = Math.tan(p - f),
      r *= a = Math.sqrt(1 + a * a),
      s *= a,
      f && (a = Math.tan(f),
      i *= a = Math.sqrt(1 + a * a),
      n *= a)),
      i = ge(i),
      n = ge(n),
      r = ge(r),
      s = ge(s)) : (i = m,
      s = g,
      n = r = 0),
      (M && !~(u + "").indexOf("px") || b && !~(h + "").indexOf("px")) && (M = xn(v, "x", u, "px"),
      b = xn(v, "y", h, "px")),
      (_ || y || x || S) && (M = ge(M + _ - (_ * i + y * r) + x),
      b = ge(b + y - (_ * n + y * s) + S)),
      (l || c) && (a = v.getBBox(),
      M = ge(M + l / 100 * a.width),
      b = ge(b + c / 100 * a.height)),
      a = "matrix(" + i + "," + n + "," + r + "," + s + "," + M + "," + b + ")",
      v.setAttribute("transform", a),
      E && (v.style[en] = a)
  }, Vn = function(e, t, i, n, r) {
      var s, a, o = 360, l = R(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? Fi : 1) - n, u = n + c + "deg";
      return l && ("short" === (s = r.split("_")[1]) && (c %= o) != c % 180 && (c += c < 0 ? o : -360),
      "cw" === s && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === s && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)),
      e._pt = a = new di(e._pt,t,i,n,c,Gi),
      a.e = u,
      a.u = "deg",
      e._props.push(i),
      a
  }, Hn = function(e, t) {
      for (var i in t)
          e[i] = t[i];
      return e
  }, Gn = function(e, t, i) {
      var n, r, s, a, o, l, c, u = Hn({}, i._gsap), h = i.style;
      for (r in u.svg ? (s = i.getAttribute("transform"),
      i.setAttribute("transform", ""),
      h[en] = t,
      n = Ln(i, 1),
      gn(i, en),
      i.setAttribute("transform", s)) : (s = getComputedStyle(i)[en],
      h[en] = t,
      n = Ln(i, 1),
      h[en] = s),
      Ni)
          (s = u[r]) !== (a = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = Qe(s) !== (c = Qe(a)) ? xn(i, r, s, c) : parseFloat(s),
          l = parseFloat(a),
          e._pt = new di(e._pt,n,r,o,l - o,Hi),
          e._pt.u = c || 0,
          e._props.push(r));
      Hn(n, u)
  };
  me("padding,margin,Width,Radius", (function(e, t) {
      var i = "Top"
        , n = "Right"
        , r = "Bottom"
        , s = "Left"
        , a = (t < 3 ? [i, n, r, s] : [i + s, i + n, r + n, r + s]).map((function(i) {
          return t < 2 ? e + i : "border" + i + e
      }
      ));
      Tn[t > 1 ? "border" + e : e] = function(e, t, i, n, r) {
          var s, o;
          if (arguments.length < 4)
              return s = a.map((function(t) {
                  return Sn(e, t, i)
              }
              )),
              5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
          s = (n + "").split(" "),
          o = {},
          a.forEach((function(e, t) {
              return o[e] = s[t] = s[t] || s[(t - 1) / 2 | 0]
          }
          )),
          e.init(t, o, r)
      }
  }
  ));
  var Wn, Xn, qn = {
      name: "css",
      register: hn,
      targetTest: function(e) {
          return e.style && e.nodeType
      },
      init: function(e, t, i, n, r) {
          var s, a, o, l, c, u, h, d, p, f, m, g, v, _, y, x, E, M, b, T, w = this._props, D = e.style, C = i.vars.startAt;
          for (h in Ai || hn(),
          this.styles = this.styles || an(e),
          x = this.styles.props,
          this.tween = i,
          t)
              if ("autoRound" !== h && (a = t[h],
              !oe[h] || !qt(h, t, i, n, e, r)))
                  if (c = typeof a,
                  u = Tn[h],
                  "function" === c && (c = typeof (a = a.call(i, n, e, r))),
                  "string" === c && ~a.indexOf("random(") && (a = ut(a)),
                  u)
                      u(this, e, h, a, i) && (y = 1);
                  else if ("--" === h.substr(0, 2))
                      s = (getComputedStyle(e).getPropertyValue(h) + "").trim(),
                      a += "",
                      Mt.lastIndex = 0,
                      Mt.test(s) || (d = Qe(s),
                      p = Qe(a)),
                      p ? d !== p && (s = xn(e, h, s, p) + p) : d && (a += d),
                      this.add(D, "setProperty", s, a, n, r, 0, 0, h),
                      w.push(h),
                      x.push(h, 0, D[h]);
                  else if ("undefined" !== c) {
                      if (C && h in C ? (s = "function" == typeof C[h] ? C[h].call(i, n, e, r) : C[h],
                      R(s) && ~s.indexOf("random(") && (s = ut(s)),
                      Qe(s + "") || "auto" === s || (s += S.units[h] || Qe(Sn(e, h)) || ""),
                      "=" === (s + "").charAt(1) && (s = Sn(e, h))) : s = Sn(e, h),
                      l = parseFloat(s),
                      (f = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)),
                      o = parseFloat(a),
                      h in Vi && ("autoAlpha" === h && (1 === l && "hidden" === Sn(e, "visibility") && o && (l = 0),
                      x.push("visibility", 0, D.visibility),
                      vn(this, D, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)),
                      "scale" !== h && "transform" !== h && ~(h = Vi[h]).indexOf(",") && (h = h.split(",")[0])),
                      m = h in Ni)
                          if (this.styles.save(h),
                          g || ((v = e._gsap).renderTransform && !t.parseTransform || Ln(e, t.parseTransform),
                          _ = !1 !== t.smoothOrigin && v.smooth,
                          (g = this._pt = new di(this._pt,D,en,0,1,v.renderTransform,v,0,-1)).dep = 1),
                          "scale" === h)
                              this._pt = new di(this._pt,v,"scaleY",v.scaleY,(f ? _e(v.scaleY, f + o) : o) - v.scaleY || 0,Hi),
                              this._pt.u = 0,
                              w.push("scaleY", h),
                              h += "X";
                          else {
                              if ("transformOrigin" === h) {
                                  x.push(tn, 0, D[tn]),
                                  M = void 0,
                                  b = void 0,
                                  T = void 0,
                                  b = (M = (E = a).split(" "))[0],
                                  T = M[1] || "50%",
                                  "top" !== b && "bottom" !== b && "left" !== T && "right" !== T || (E = b,
                                  b = T,
                                  T = E),
                                  M[0] = Mn[b] || b,
                                  M[1] = Mn[T] || T,
                                  a = M.join(" "),
                                  v.svg ? Rn(e, a, 0, _, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== v.zOrigin && vn(this, v, "zOrigin", v.zOrigin, p),
                                  vn(this, D, h, In(s), In(a)));
                                  continue
                              }
                              if ("svgOrigin" === h) {
                                  Rn(e, a, 1, _, 0, this);
                                  continue
                              }
                              if (h in Dn) {
                                  Vn(this, v, h, l, f ? _e(l, f + a) : a);
                                  continue
                              }
                              if ("smoothOrigin" === h) {
                                  vn(this, v, "smooth", v.smooth, a);
                                  continue
                              }
                              if ("force3D" === h) {
                                  v[h] = a;
                                  continue
                              }
                              if ("transform" === h) {
                                  Gn(this, a, e);
                                  continue
                              }
                          }
                      else
                          h in D || (h = un(h) || h);
                      if (m || (o || 0 === o) && (l || 0 === l) && !ki.test(a) && h in D)
                          o || (o = 0),
                          (d = (s + "").substr((l + "").length)) !== (p = Qe(a) || (h in S.units ? S.units[h] : d)) && (l = xn(e, h, s, p)),
                          this._pt = new di(this._pt,m ? v : D,h,l,(f ? _e(l, f + o) : o) - l,m || "px" !== p && "zIndex" !== h || !1 === t.autoRound ? Hi : Xi),
                          this._pt.u = p || 0,
                          d !== p && "%" !== p && (this._pt.b = s,
                          this._pt.r = Wi);
                      else if (h in D)
                          En.call(this, e, h, s, f ? f + a : a);
                      else if (h in e)
                          this.add(e, h, s || e[h], f ? f + a : a, n, r);
                      else if ("parseTransform" !== h) {
                          $(h, a);
                          continue
                      }
                      m || (h in D ? x.push(h, 0, D[h]) : x.push(h, 1, s || e[h])),
                      w.push(h)
                  }
          y && hi(this)
      },
      render: function(e, t) {
          if (t.tween._time || !Li())
              for (var i = t._pt; i; )
                  i.r(e, i.d),
                  i = i._next;
          else
              t.styles.revert()
      },
      get: Sn,
      aliases: Vi,
      getSetter: function(e, t, i) {
          var n = Vi[t];
          return n && n.indexOf(",") < 0 && (t = n),
          t in Ni && t !== tn && (e._gsap.x || Sn(e, "x")) ? i && Ri === i ? "scale" === t ? $i : Zi : (Ri = i || {}) && ("scale" === t ? Ji : Qi) : e.style && !N(e.style[t]) ? Yi : ~t.indexOf("-") ? Ki : ni(e, t)
      },
      core: {
          _removeProperty: gn,
          _getMatrix: Pn
      }
  };
  Ti.utils.checkPrefix = un,
  Ti.core.getStyleSaver = an,
  Xn = me("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (Wn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(e) {
      Ni[e] = 1
  }
  )),
  me(Wn, (function(e) {
      S.units[e] = "deg",
      Dn[e] = 1
  }
  )),
  Vi[Xn[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Wn,
  me("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(e) {
      var t = e.split(":");
      Vi[t[1]] = Xn[t[0]]
  }
  )),
  me("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(e) {
      S.units[e] = "px"
  }
  )),
  Ti.registerPlugin(qn);
  var jn = Ti.registerPlugin(qn) || Ti;
  function Yn(e, t) {
      for (var i = 0; i < t.length; i++) {
          var n = t[i];
          n.enumerable = n.enumerable || !1,
          n.configurable = !0,
          "value"in n && (n.writable = !0),
          Object.defineProperty(e, n.key, n)
      }
  }
  jn.core.Tween;
  var Kn, Zn, $n, Jn, Qn, er, tr, ir, nr, rr, sr, ar, or, lr = function() {
      return Kn || "undefined" != typeof window && (Kn = window.gsap) && Kn.registerPlugin && Kn
  }, cr = 1, ur = [], hr = [], dr = [], pr = Date.now, fr = function(e, t) {
      return t
  }, mr = function(e, t) {
      return ~dr.indexOf(e) && dr[dr.indexOf(e) + 1][t]
  }, gr = function(e) {
      return !!~rr.indexOf(e)
  }, vr = function(e, t, i, n, r) {
      return e.addEventListener(t, i, {
          passive: !1 !== n,
          capture: !!r
      })
  }, _r = function(e, t, i, n) {
      return e.removeEventListener(t, i, !!n)
  }, yr = "scrollLeft", xr = "scrollTop", Sr = function() {
      return sr && sr.isPressed || hr.cache++
  }, Er = function(e, t) {
      var i = function i(n) {
          if (n || 0 === n) {
              cr && ($n.history.scrollRestoration = "manual");
              var r = sr && sr.isPressed;
              n = i.v = Math.round(n) || (sr && sr.iOS ? 1 : 0),
              e(n),
              i.cacheID = hr.cache,
              r && fr("ss", n)
          } else
              (t || hr.cache !== i.cacheID || fr("ref")) && (i.cacheID = hr.cache,
              i.v = e());
          return i.v + i.offset
      };
      return i.offset = 0,
      e && i
  }, Mr = {
      s: yr,
      p: "left",
      p2: "Left",
      os: "right",
      os2: "Right",
      d: "width",
      d2: "Width",
      a: "x",
      sc: Er((function(e) {
          return arguments.length ? $n.scrollTo(e, br.sc()) : $n.pageXOffset || Jn[yr] || Qn[yr] || er[yr] || 0
      }
      ))
  }, br = {
      s: xr,
      p: "top",
      p2: "Top",
      os: "bottom",
      os2: "Bottom",
      d: "height",
      d2: "Height",
      a: "y",
      op: Mr,
      sc: Er((function(e) {
          return arguments.length ? $n.scrollTo(Mr.sc(), e) : $n.pageYOffset || Jn[xr] || Qn[xr] || er[xr] || 0
      }
      ))
  }, Tr = function(e, t) {
      return (t && t._ctx && t._ctx.selector || Kn.utils.toArray)(e)[0] || ("string" == typeof e && !1 !== Kn.config().nullTargetWarn ? console.warn("Element not found:", e) : null)
  }, wr = function(e, t) {
      var i = t.s
        , n = t.sc;
      gr(e) && (e = Jn.scrollingElement || Qn);
      var r = hr.indexOf(e)
        , s = n === br.sc ? 1 : 2;
      !~r && (r = hr.push(e) - 1),
      hr[r + s] || vr(e, "scroll", Sr);
      var a = hr[r + s]
        , o = a || (hr[r + s] = Er(mr(e, i), !0) || (gr(e) ? n : Er((function(t) {
          return arguments.length ? e[i] = t : e[i]
      }
      ))));
      return o.target = e,
      a || (o.smooth = "smooth" === Kn.getProperty(e, "scrollBehavior")),
      o
  }, Dr = function(e, t, i) {
      var n = e
        , r = e
        , s = pr()
        , a = s
        , o = t || 50
        , l = Math.max(500, 3 * o)
        , c = function(e, t) {
          var l = pr();
          t || l - s > o ? (r = n,
          n = e,
          a = s,
          s = l) : i ? n += e : n = r + (e - r) / (l - a) * (s - a)
      };
      return {
          update: c,
          reset: function() {
              r = n = i ? 0 : n,
              a = s = 0
          },
          getVelocity: function(e) {
              var t = a
                , o = r
                , u = pr();
              return (e || 0 === e) && e !== n && c(e),
              s === a || u - a > l ? 0 : (n + (i ? o : -o)) / ((i ? u : s) - t) * 1e3
          }
      }
  }, Cr = function(e, t) {
      return t && !e._gsapAllow && e.preventDefault(),
      e.changedTouches ? e.changedTouches[0] : e
  }, Ar = function(e) {
      var t = Math.max.apply(Math, e)
        , i = Math.min.apply(Math, e);
      return Math.abs(t) >= Math.abs(i) ? t : i
  }, Pr = function() {
      var e, t, i, n;
      (nr = Kn.core.globals().ScrollTrigger) && nr.core && (e = nr.core,
      t = e.bridge || {},
      i = e._scrollers,
      n = e._proxies,
      i.push.apply(i, hr),
      n.push.apply(n, dr),
      hr = i,
      dr = n,
      fr = function(e, i) {
          return t[e](i)
      }
      )
  }, Rr = function(e) {
      return Kn = e || lr(),
      !Zn && Kn && "undefined" != typeof document && document.body && ($n = window,
      Jn = document,
      Qn = Jn.documentElement,
      er = Jn.body,
      rr = [$n, Jn, Qn, er],
      Kn.utils.clamp,
      or = Kn.core.context || function() {}
      ,
      ir = "onpointerenter"in er ? "pointer" : "mouse",
      tr = Lr.isTouch = $n.matchMedia && $n.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in $n || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
      ar = Lr.eventTypes = ("ontouchstart"in Qn ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in Qn ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
      setTimeout((function() {
          return cr = 0
      }
      ), 500),
      Pr(),
      Zn = 1),
      Zn
  };
  Mr.op = br,
  hr.cache = 0;
  var Lr = function() {
      function e(e) {
          this.init(e)
      }
      var t, i;
      return e.prototype.init = function(e) {
          Zn || Rr(Kn) || console.warn("Please gsap.registerPlugin(Observer)"),
          nr || Pr();
          var t = e.tolerance
            , i = e.dragMinimum
            , n = e.type
            , r = e.target
            , s = e.lineHeight
            , a = e.debounce
            , o = e.preventDefault
            , l = e.onStop
            , c = e.onStopDelay
            , u = e.ignore
            , h = e.wheelSpeed
            , d = e.event
            , p = e.onDragStart
            , f = e.onDragEnd
            , m = e.onDrag
            , g = e.onPress
            , v = e.onRelease
            , _ = e.onRight
            , y = e.onLeft
            , x = e.onUp
            , S = e.onDown
            , E = e.onChangeX
            , M = e.onChangeY
            , b = e.onChange
            , T = e.onToggleX
            , w = e.onToggleY
            , D = e.onHover
            , C = e.onHoverEnd
            , A = e.onMove
            , P = e.ignoreCheck
            , R = e.isNormalizer
            , L = e.onGestureStart
            , I = e.onGestureEnd
            , N = e.onWheel
            , F = e.onEnable
            , O = e.onDisable
            , U = e.onClick
            , B = e.scrollSpeed
            , z = e.capture
            , k = e.allowClicks
            , V = e.lockAxis
            , H = e.onLockAxis;
          this.target = r = Tr(r) || Qn,
          this.vars = e,
          u && (u = Kn.utils.toArray(u)),
          t = t || 1e-9,
          i = i || 0,
          h = h || 1,
          B = B || 1,
          n = n || "wheel,touch,pointer",
          a = !1 !== a,
          s || (s = parseFloat($n.getComputedStyle(er).lineHeight) || 22);
          var G, W, X, q, j, Y, K, Z = this, $ = 0, J = 0, Q = e.passive || !o, ee = wr(r, Mr), te = wr(r, br), ie = ee(), ne = te(), re = ~n.indexOf("touch") && !~n.indexOf("pointer") && "pointerdown" === ar[0], se = gr(r), ae = r.ownerDocument || Jn, oe = [0, 0, 0], le = [0, 0, 0], ce = 0, ue = function() {
              return ce = pr()
          }, he = function(e, t) {
              return (Z.event = e) && u && ~u.indexOf(e.target) || t && re && "touch" !== e.pointerType || P && P(e, t)
          }, de = function() {
              var e = Z.deltaX = Ar(oe)
                , i = Z.deltaY = Ar(le)
                , n = Math.abs(e) >= t
                , r = Math.abs(i) >= t;
              b && (n || r) && b(Z, e, i, oe, le),
              n && (_ && Z.deltaX > 0 && _(Z),
              y && Z.deltaX < 0 && y(Z),
              E && E(Z),
              T && Z.deltaX < 0 != $ < 0 && T(Z),
              $ = Z.deltaX,
              oe[0] = oe[1] = oe[2] = 0),
              r && (S && Z.deltaY > 0 && S(Z),
              x && Z.deltaY < 0 && x(Z),
              M && M(Z),
              w && Z.deltaY < 0 != J < 0 && w(Z),
              J = Z.deltaY,
              le[0] = le[1] = le[2] = 0),
              (q || X) && (A && A(Z),
              X && (m(Z),
              X = !1),
              q = !1),
              Y && !(Y = !1) && H && H(Z),
              j && (N(Z),
              j = !1),
              G = 0
          }, pe = function(e, t, i) {
              oe[i] += e,
              le[i] += t,
              Z._vx.update(e),
              Z._vy.update(t),
              a ? G || (G = requestAnimationFrame(de)) : de()
          }, fe = function(e, t) {
              V && !K && (Z.axis = K = Math.abs(e) > Math.abs(t) ? "x" : "y",
              Y = !0),
              "y" !== K && (oe[2] += e,
              Z._vx.update(e, !0)),
              "x" !== K && (le[2] += t,
              Z._vy.update(t, !0)),
              a ? G || (G = requestAnimationFrame(de)) : de()
          }, me = function(e) {
              if (!he(e, 1)) {
                  var t = (e = Cr(e, o)).clientX
                    , n = e.clientY
                    , r = t - Z.x
                    , s = n - Z.y
                    , a = Z.isDragging;
                  Z.x = t,
                  Z.y = n,
                  (a || Math.abs(Z.startX - t) >= i || Math.abs(Z.startY - n) >= i) && (m && (X = !0),
                  a || (Z.isDragging = !0),
                  fe(r, s),
                  a || p && p(Z))
              }
          }, ge = Z.onPress = function(e) {
              he(e, 1) || e && e.button || (Z.axis = K = null,
              W.pause(),
              Z.isPressed = !0,
              e = Cr(e),
              $ = J = 0,
              Z.startX = Z.x = e.clientX,
              Z.startY = Z.y = e.clientY,
              Z._vx.reset(),
              Z._vy.reset(),
              vr(R ? r : ae, ar[1], me, Q, !0),
              Z.deltaX = Z.deltaY = 0,
              g && g(Z))
          }
          , ve = Z.onRelease = function(e) {
              if (!he(e, 1)) {
                  _r(R ? r : ae, ar[1], me, !0);
                  var t = !isNaN(Z.y - Z.startY)
                    , i = Z.isDragging
                    , n = i && (Math.abs(Z.x - Z.startX) > 3 || Math.abs(Z.y - Z.startY) > 3)
                    , s = Cr(e);
                  !n && t && (Z._vx.reset(),
                  Z._vy.reset(),
                  o && k && Kn.delayedCall(.08, (function() {
                      if (pr() - ce > 300 && !e.defaultPrevented)
                          if (e.target.click)
                              e.target.click();
                          else if (ae.createEvent) {
                              var t = ae.createEvent("MouseEvents");
                              t.initMouseEvent("click", !0, !0, $n, 1, s.screenX, s.screenY, s.clientX, s.clientY, !1, !1, !1, !1, 0, null),
                              e.target.dispatchEvent(t)
                          }
                  }
                  ))),
                  Z.isDragging = Z.isGesturing = Z.isPressed = !1,
                  l && i && !R && W.restart(!0),
                  f && i && f(Z),
                  v && v(Z, n)
              }
          }
          , _e = function(e) {
              return e.touches && e.touches.length > 1 && (Z.isGesturing = !0) && L(e, Z.isDragging)
          }, ye = function() {
              return (Z.isGesturing = !1) || I(Z)
          }, xe = function(e) {
              if (!he(e)) {
                  var t = ee()
                    , i = te();
                  pe((t - ie) * B, (i - ne) * B, 1),
                  ie = t,
                  ne = i,
                  l && W.restart(!0)
              }
          }, Se = function(e) {
              if (!he(e)) {
                  e = Cr(e, o),
                  N && (j = !0);
                  var t = (1 === e.deltaMode ? s : 2 === e.deltaMode ? $n.innerHeight : 1) * h;
                  pe(e.deltaX * t, e.deltaY * t, 0),
                  l && !R && W.restart(!0)
              }
          }, Ee = function(e) {
              if (!he(e)) {
                  var t = e.clientX
                    , i = e.clientY
                    , n = t - Z.x
                    , r = i - Z.y;
                  Z.x = t,
                  Z.y = i,
                  q = !0,
                  l && W.restart(!0),
                  (n || r) && fe(n, r)
              }
          }, Me = function(e) {
              Z.event = e,
              D(Z)
          }, be = function(e) {
              Z.event = e,
              C(Z)
          }, Te = function(e) {
              return he(e) || Cr(e, o) && U(Z)
          };
          W = Z._dc = Kn.delayedCall(c || .25, (function() {
              Z._vx.reset(),
              Z._vy.reset(),
              W.pause(),
              l && l(Z)
          }
          )).pause(),
          Z.deltaX = Z.deltaY = 0,
          Z._vx = Dr(0, 50, !0),
          Z._vy = Dr(0, 50, !0),
          Z.scrollX = ee,
          Z.scrollY = te,
          Z.isDragging = Z.isGesturing = Z.isPressed = !1,
          or(this),
          Z.enable = function(e) {
              return Z.isEnabled || (vr(se ? ae : r, "scroll", Sr),
              n.indexOf("scroll") >= 0 && vr(se ? ae : r, "scroll", xe, Q, z),
              n.indexOf("wheel") >= 0 && vr(r, "wheel", Se, Q, z),
              (n.indexOf("touch") >= 0 && tr || n.indexOf("pointer") >= 0) && (vr(r, ar[0], ge, Q, z),
              vr(ae, ar[2], ve),
              vr(ae, ar[3], ve),
              k && vr(r, "click", ue, !0, !0),
              U && vr(r, "click", Te),
              L && vr(ae, "gesturestart", _e),
              I && vr(ae, "gestureend", ye),
              D && vr(r, ir + "enter", Me),
              C && vr(r, ir + "leave", be),
              A && vr(r, ir + "move", Ee)),
              Z.isEnabled = !0,
              e && e.type && ge(e),
              F && F(Z)),
              Z
          }
          ,
          Z.disable = function() {
              Z.isEnabled && (ur.filter((function(e) {
                  return e !== Z && gr(e.target)
              }
              )).length || _r(se ? ae : r, "scroll", Sr),
              Z.isPressed && (Z._vx.reset(),
              Z._vy.reset(),
              _r(R ? r : ae, ar[1], me, !0)),
              _r(se ? ae : r, "scroll", xe, z),
              _r(r, "wheel", Se, z),
              _r(r, ar[0], ge, z),
              _r(ae, ar[2], ve),
              _r(ae, ar[3], ve),
              _r(r, "click", ue, !0),
              _r(r, "click", Te),
              _r(ae, "gesturestart", _e),
              _r(ae, "gestureend", ye),
              _r(r, ir + "enter", Me),
              _r(r, ir + "leave", be),
              _r(r, ir + "move", Ee),
              Z.isEnabled = Z.isPressed = Z.isDragging = !1,
              O && O(Z))
          }
          ,
          Z.kill = Z.revert = function() {
              Z.disable();
              var e = ur.indexOf(Z);
              e >= 0 && ur.splice(e, 1),
              sr === Z && (sr = 0)
          }
          ,
          ur.push(Z),
          R && gr(r) && (sr = Z),
          Z.enable(d)
      }
      ,
      t = e,
      (i = [{
          key: "velocityX",
          get: function() {
              return this._vx.getVelocity()
          }
      }, {
          key: "velocityY",
          get: function() {
              return this._vy.getVelocity()
          }
      }]) && Yn(t.prototype, i),
      e
  }();
  Lr.version = "3.12.5",
  Lr.create = function(e) {
      return new Lr(e)
  }
  ,
  Lr.register = Rr,
  Lr.getAll = function() {
      return ur.slice()
  }
  ,
  Lr.getById = function(e) {
      return ur.filter((function(t) {
          return t.vars.id === e
      }
      ))[0]
  }
  ,
  lr() && Kn.registerPlugin(Lr);
  var Ir, Nr, Fr, Or, Ur, Br, zr, kr, Vr, Hr, Gr, Wr, Xr, qr, jr, Yr, Kr, Zr, $r, Jr, Qr, es, ts, is, ns, rs, ss, as, os, ls, cs, us, hs, ds, ps, fs, ms, gs, vs = 1, _s = Date.now, ys = _s(), xs = 0, Ss = 0, Es = function(e, t, i) {
      var n = Os(e) && ("clamp(" === e.substr(0, 6) || e.indexOf("max") > -1);
      return i["_" + t + "Clamp"] = n,
      n ? e.substr(6, e.length - 7) : e
  }, Ms = function(e, t) {
      return !t || Os(e) && "clamp(" === e.substr(0, 6) ? e : "clamp(" + e + ")"
  }, bs = function e() {
      return Ss && requestAnimationFrame(e)
  }, Ts = function() {
      return qr = 1
  }, ws = function() {
      return qr = 0
  }, Ds = function(e) {
      return e
  }, Cs = function(e) {
      return Math.round(1e5 * e) / 1e5 || 0
  }, As = function() {
      return "undefined" != typeof window
  }, Ps = function() {
      return Ir || As() && (Ir = window.gsap) && Ir.registerPlugin && Ir
  }, Rs = function(e) {
      return !!~zr.indexOf(e)
  }, Ls = function(e) {
      return ("Height" === e ? cs : Fr["inner" + e]) || Ur["client" + e] || Br["client" + e]
  }, Is = function(e) {
      return mr(e, "getBoundingClientRect") || (Rs(e) ? function() {
          return qa.width = Fr.innerWidth,
          qa.height = cs,
          qa
      }
      : function() {
          return sa(e)
      }
      )
  }, Ns = function(e, t) {
      var i = t.s
        , n = t.d2
        , r = t.d
        , s = t.a;
      return Math.max(0, (i = "scroll" + n) && (s = mr(e, i)) ? s() - Is(e)()[r] : Rs(e) ? (Ur[i] || Br[i]) - Ls(n) : e[i] - e["offset" + n])
  }, Fs = function(e, t) {
      for (var i = 0; i < $r.length; i += 3)
          (!t || ~t.indexOf($r[i + 1])) && e($r[i], $r[i + 1], $r[i + 2])
  }, Os = function(e) {
      return "string" == typeof e
  }, Us = function(e) {
      return "function" == typeof e
  }, Bs = function(e) {
      return "number" == typeof e
  }, zs = function(e) {
      return "object" == typeof e
  }, ks = function(e, t, i) {
      return e && e.progress(t ? 0 : 1) && i && e.pause()
  }, Vs = function(e, t) {
      if (e.enabled) {
          var i = e._ctx ? e._ctx.add((function() {
              return t(e)
          }
          )) : t(e);
          i && i.totalTime && (e.callbackAnimation = i)
      }
  }, Hs = Math.abs, Gs = "left", Ws = "right", Xs = "bottom", qs = "width", js = "height", Ys = "Right", Ks = "Left", Zs = "Top", $s = "Bottom", Js = "padding", Qs = "margin", ea = "Width", ta = "Height", ia = "px", na = function(e) {
      return Fr.getComputedStyle(e)
  }, ra = function(e, t) {
      for (var i in t)
          i in e || (e[i] = t[i]);
      return e
  }, sa = function(e, t) {
      var i = t && "matrix(1, 0, 0, 1, 0, 0)" !== na(e)[jr] && Ir.to(e, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0
      }).progress(1)
        , n = e.getBoundingClientRect();
      return i && i.progress(0).kill(),
      n
  }, aa = function(e, t) {
      var i = t.d2;
      return e["offset" + i] || e["client" + i] || 0
  }, oa = function(e) {
      var t, i = [], n = e.labels, r = e.duration();
      for (t in n)
          i.push(n[t] / r);
      return i
  }, la = function(e) {
      var t = Ir.utils.snap(e)
        , i = Array.isArray(e) && e.slice(0).sort((function(e, t) {
          return e - t
      }
      ));
      return i ? function(e, n, r) {
          var s;
          if (void 0 === r && (r = .001),
          !n)
              return t(e);
          if (n > 0) {
              for (e -= r,
              s = 0; s < i.length; s++)
                  if (i[s] >= e)
                      return i[s];
              return i[s - 1]
          }
          for (s = i.length,
          e += r; s--; )
              if (i[s] <= e)
                  return i[s];
          return i[0]
      }
      : function(i, n, r) {
          void 0 === r && (r = .001);
          var s = t(i);
          return !n || Math.abs(s - i) < r || s - i < 0 == n < 0 ? s : t(n < 0 ? i - e : i + e)
      }
  }, ca = function(e, t, i, n) {
      return i.split(",").forEach((function(i) {
          return e(t, i, n)
      }
      ))
  }, ua = function(e, t, i, n, r) {
      return e.addEventListener(t, i, {
          passive: !n,
          capture: !!r
      })
  }, ha = function(e, t, i, n) {
      return e.removeEventListener(t, i, !!n)
  }, da = function(e, t, i) {
      (i = i && i.wheelHandler) && (e(t, "wheel", i),
      e(t, "touchmove", i))
  }, pa = {
      startColor: "green",
      endColor: "red",
      indent: 0,
      fontSize: "16px",
      fontWeight: "normal"
  }, fa = {
      toggleActions: "play",
      anticipatePin: 0
  }, ma = {
      top: 0,
      left: 0,
      center: .5,
      bottom: 1,
      right: 1
  }, ga = function(e, t) {
      if (Os(e)) {
          var i = e.indexOf("=")
            , n = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
          ~i && (e.indexOf("%") > i && (n *= t / 100),
          e = e.substr(0, i - 1)),
          e = n + (e in ma ? ma[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
      }
      return e
  }, va = function(e, t, i, n, r, s, a, o) {
      var l = r.startColor
        , c = r.endColor
        , u = r.fontSize
        , h = r.indent
        , d = r.fontWeight
        , p = Or.createElement("div")
        , f = Rs(i) || "fixed" === mr(i, "pinType")
        , m = -1 !== e.indexOf("scroller")
        , g = f ? Br : i
        , v = -1 !== e.indexOf("start")
        , _ = v ? l : c
        , y = "border-color:" + _ + ";font-size:" + u + ";color:" + _ + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
      return y += "position:" + ((m || o) && f ? "fixed;" : "absolute;"),
      (m || o || !f) && (y += (n === br ? Ws : Xs) + ":" + (s + parseFloat(h)) + "px;"),
      a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
      p._isStart = v,
      p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
      p.style.cssText = y,
      p.innerText = t || 0 === t ? e + "-" + t : e,
      g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
      p._offset = p["offset" + n.op.d2],
      _a(p, 0, n, v),
      p
  }, _a = function(e, t, i, n) {
      var r = {
          display: "block"
      }
        , s = i[n ? "os2" : "p2"]
        , a = i[n ? "p2" : "os2"];
      e._isFlipped = n,
      r[i.a + "Percent"] = n ? -100 : 0,
      r[i.a] = n ? "1px" : 0,
      r["border" + s + ea] = 1,
      r["border" + a + ea] = 0,
      r[i.p] = t + "px",
      Ir.set(e, r)
  }, ya = [], xa = {}, Sa = function() {
      return _s() - xs > 34 && (ps || (ps = requestAnimationFrame(za)))
  }, Ea = function() {
      (!ts || !ts.isPressed || ts.startX > Br.clientWidth) && (hr.cache++,
      ts ? ps || (ps = requestAnimationFrame(za)) : za(),
      xs || Ca("scrollStart"),
      xs = _s())
  }, Ma = function() {
      rs = Fr.innerWidth,
      ns = Fr.innerHeight
  }, ba = function() {
      hr.cache++,
      !Xr && !es && !Or.fullscreenElement && !Or.webkitFullscreenElement && (!is || rs !== Fr.innerWidth || Math.abs(Fr.innerHeight - ns) > .25 * Fr.innerHeight) && kr.restart(!0)
  }, Ta = {}, wa = [], Da = function e() {
      return ha(Qa, "scrollEnd", e) || Oa(!0)
  }, Ca = function(e) {
      return Ta[e] && Ta[e].map((function(e) {
          return e()
      }
      )) || wa
  }, Aa = [], Pa = function(e) {
      for (var t = 0; t < Aa.length; t += 5)
          (!e || Aa[t + 4] && Aa[t + 4].query === e) && (Aa[t].style.cssText = Aa[t + 1],
          Aa[t].getBBox && Aa[t].setAttribute("transform", Aa[t + 2] || ""),
          Aa[t + 3].uncache = 1)
  }, Ra = function(e, t) {
      var i;
      for (Yr = 0; Yr < ya.length; Yr++)
          !(i = ya[Yr]) || t && i._ctx !== t || (e ? i.kill(1) : i.revert(!0, !0));
      us = !0,
      t && Pa(t),
      t || Ca("revert")
  }, La = function(e, t) {
      hr.cache++,
      (t || !fs) && hr.forEach((function(e) {
          return Us(e) && e.cacheID++ && (e.rec = 0)
      }
      )),
      Os(e) && (Fr.history.scrollRestoration = os = e)
  }, Ia = 0, Na = function() {
      Br.appendChild(ls),
      cs = !ts && ls.offsetHeight || Fr.innerHeight,
      Br.removeChild(ls)
  }, Fa = function(e) {
      return Vr(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach((function(t) {
          return t.style.display = e ? "none" : "block"
      }
      ))
  }, Oa = function(e, t) {
      if (!xs || e || us) {
          Na(),
          fs = Qa.isRefreshing = !0,
          hr.forEach((function(e) {
              return Us(e) && ++e.cacheID && (e.rec = e())
          }
          ));
          var i = Ca("refreshInit");
          Jr && Qa.sort(),
          t || Ra(),
          hr.forEach((function(e) {
              Us(e) && (e.smooth && (e.target.style.scrollBehavior = "auto"),
              e(0))
          }
          )),
          ya.slice(0).forEach((function(e) {
              return e.refresh()
          }
          )),
          us = !1,
          ya.forEach((function(e) {
              if (e._subPinOffset && e.pin) {
                  var t = e.vars.horizontal ? "offsetWidth" : "offsetHeight"
                    , i = e.pin[t];
                  e.revert(!0, 1),
                  e.adjustPinSpacing(e.pin[t] - i),
                  e.refresh()
              }
          }
          )),
          hs = 1,
          Fa(!0),
          ya.forEach((function(e) {
              var t = Ns(e.scroller, e._dir)
                , i = "max" === e.vars.end || e._endClamp && e.end > t
                , n = e._startClamp && e.start >= t;
              (i || n) && e.setPositions(n ? t - 1 : e.start, i ? Math.max(n ? t : e.start + 1, t) : e.end, !0)
          }
          )),
          Fa(!1),
          hs = 0,
          i.forEach((function(e) {
              return e && e.render && e.render(-1)
          }
          )),
          hr.forEach((function(e) {
              Us(e) && (e.smooth && requestAnimationFrame((function() {
                  return e.target.style.scrollBehavior = "smooth"
              }
              )),
              e.rec && e(e.rec))
          }
          )),
          La(os, 1),
          kr.pause(),
          Ia++,
          fs = 2,
          za(2),
          ya.forEach((function(e) {
              return Us(e.vars.onRefresh) && e.vars.onRefresh(e)
          }
          )),
          fs = Qa.isRefreshing = !1,
          Ca("refresh")
      } else
          ua(Qa, "scrollEnd", Da)
  }, Ua = 0, Ba = 1, za = function(e) {
      if (2 === e || !fs && !us) {
          Qa.isUpdating = !0,
          gs && gs.update(0);
          var t = ya.length
            , i = _s()
            , n = i - ys >= 50
            , r = t && ya[0].scroll();
          if (Ba = Ua > r ? -1 : 1,
          fs || (Ua = r),
          n && (xs && !qr && i - xs > 200 && (xs = 0,
          Ca("scrollEnd")),
          Gr = ys,
          ys = i),
          Ba < 0) {
              for (Yr = t; Yr-- > 0; )
                  ya[Yr] && ya[Yr].update(0, n);
              Ba = 1
          } else
              for (Yr = 0; Yr < t; Yr++)
                  ya[Yr] && ya[Yr].update(0, n);
          Qa.isUpdating = !1
      }
      ps = 0
  }, ka = [Gs, "top", Xs, Ws, Qs + $s, Qs + Ys, Qs + Zs, Qs + Ks, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], Va = ka.concat([qs, js, "boxSizing", "max" + ea, "max" + ta, "position", Qs, Js, Js + Zs, Js + Ys, Js + $s, Js + Ks]), Ha = function(e, t, i, n) {
      if (!e._gsap.swappedIn) {
          for (var r, s = ka.length, a = t.style, o = e.style; s--; )
              a[r = ka[s]] = i[r];
          a.position = "absolute" === i.position ? "absolute" : "relative",
          "inline" === i.display && (a.display = "inline-block"),
          o[Xs] = o[Ws] = "auto",
          a.flexBasis = i.flexBasis || "auto",
          a.overflow = "visible",
          a.boxSizing = "border-box",
          a[qs] = aa(e, Mr) + ia,
          a[js] = aa(e, br) + ia,
          a[Js] = o[Qs] = o.top = o[Gs] = "0",
          Wa(n),
          o[qs] = o["max" + ea] = i[qs],
          o[js] = o["max" + ta] = i[js],
          o[Js] = i[Js],
          e.parentNode !== t && (e.parentNode.insertBefore(t, e),
          t.appendChild(e)),
          e._gsap.swappedIn = !0
      }
  }, Ga = /([A-Z])/g, Wa = function(e) {
      if (e) {
          var t, i, n = e.t.style, r = e.length, s = 0;
          for ((e.t._gsap || Ir.core.getCache(e.t)).uncache = 1; s < r; s += 2)
              i = e[s + 1],
              t = e[s],
              i ? n[t] = i : n[t] && n.removeProperty(t.replace(Ga, "-$1").toLowerCase())
      }
  }, Xa = function(e) {
      for (var t = Va.length, i = e.style, n = [], r = 0; r < t; r++)
          n.push(Va[r], i[Va[r]]);
      return n.t = e,
      n
  }, qa = {
      left: 0,
      top: 0
  }, ja = function(e, t, i, n, r, s, a, o, l, c, u, h, d, p) {
      Us(e) && (e = e(o)),
      Os(e) && "max" === e.substr(0, 3) && (e = h + ("=" === e.charAt(4) ? ga("0" + e.substr(3), i) : 0));
      var f, m, g, v = d ? d.time() : 0;
      if (d && d.seek(0),
      isNaN(e) || (e = +e),
      Bs(e))
          d && (e = Ir.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, h, e)),
          a && _a(a, i, n, !0);
      else {
          Us(t) && (t = t(o));
          var _, y, x, S, E = (e || "0").split(" ");
          g = Tr(t, o) || Br,
          (_ = sa(g) || {}) && (_.left || _.top) || "none" !== na(g).display || (S = g.style.display,
          g.style.display = "block",
          _ = sa(g),
          S ? g.style.display = S : g.style.removeProperty("display")),
          y = ga(E[0], _[n.d]),
          x = ga(E[1] || "0", i),
          e = _[n.p] - l[n.p] - c + y + r - x,
          a && _a(a, x, n, i - x < 20 || a._isStart && x > 20),
          i -= i - x
      }
      if (p && (o[p] = e || -.001,
      e < 0 && (e = 0)),
      s) {
          var M = e + i
            , b = s._isStart;
          f = "scroll" + n.d2,
          _a(s, M, n, b && M > 20 || !b && (u ? Math.max(Br[f], Ur[f]) : s.parentNode[f]) <= M + 1),
          u && (l = sa(a),
          u && (s.style[n.op.p] = l[n.op.p] - n.op.m - s._offset + ia))
      }
      return d && g && (f = sa(g),
      d.seek(h),
      m = sa(g),
      d._caScrollDist = f[n.p] - m[n.p],
      e = e / d._caScrollDist * h),
      d && d.seek(v),
      d ? e : Math.round(e)
  }, Ya = /(webkit|moz|length|cssText|inset)/i, Ka = function(e, t, i, n) {
      if (e.parentNode !== t) {
          var r, s, a = e.style;
          if (t === Br) {
              for (r in e._stOrig = a.cssText,
              s = na(e))
                  +r || Ya.test(r) || !s[r] || "string" != typeof a[r] || "0" === r || (a[r] = s[r]);
              a.top = i,
              a.left = n
          } else
              a.cssText = e._stOrig;
          Ir.core.getCache(e).uncache = 1,
          t.appendChild(e)
      }
  }, Za = function(e, t, i) {
      var n = t
        , r = n;
      return function(t) {
          var s = Math.round(e());
          return s !== n && s !== r && Math.abs(s - n) > 3 && Math.abs(s - r) > 3 && (t = s,
          i && i()),
          r = n,
          n = t,
          t
      }
  }, $a = function(e, t, i) {
      var n = {};
      n[t.p] = "+=" + i,
      Ir.set(e, n)
  }, Ja = function(e, t) {
      var i = wr(e, t)
        , n = "_scroll" + t.p2
        , r = function t(r, s, a, o, l) {
          var c = t.tween
            , u = s.onComplete
            , h = {};
          a = a || i();
          var d = Za(i, a, (function() {
              c.kill(),
              t.tween = 0
          }
          ));
          return l = o && l || 0,
          o = o || r - a,
          c && c.kill(),
          s[n] = r,
          s.inherit = !1,
          s.modifiers = h,
          h[n] = function() {
              return d(a + o * c.ratio + l * c.ratio * c.ratio)
          }
          ,
          s.onUpdate = function() {
              hr.cache++,
              t.tween && za()
          }
          ,
          s.onComplete = function() {
              t.tween = 0,
              u && u.call(c)
          }
          ,
          c = t.tween = Ir.to(e, s)
      };
      return e[n] = i,
      i.wheelHandler = function() {
          return r.tween && r.tween.kill() && (r.tween = 0)
      }
      ,
      ua(e, "wheel", i.wheelHandler),
      Qa.isTouch && ua(e, "touchmove", i.wheelHandler),
      r
  }, Qa = function() {
      function e(t, i) {
          Nr || e.register(Ir) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
          as(this),
          this.init(t, i)
      }
      return e.prototype.init = function(t, i) {
          if (this.progress = this.start = 0,
          this.vars && this.kill(!0, !0),
          Ss) {
              var n, r, s, a, o, l, c, u, h, d, p, f, m, g, v, _, y, x, S, E, M, b, T, w, D, C, A, P, R, L, I, N, F, O, U, B, z, k, V, H, G = t = ra(Os(t) || Bs(t) || t.nodeType ? {
                  trigger: t
              } : t, fa), W = G.onUpdate, X = G.toggleClass, q = G.id, j = G.onToggle, Y = G.onRefresh, K = G.scrub, Z = G.trigger, $ = G.pin, J = G.pinSpacing, Q = G.invalidateOnRefresh, ee = G.anticipatePin, te = G.onScrubComplete, ie = G.onSnapComplete, ne = G.once, re = G.snap, se = G.pinReparent, ae = G.pinSpacer, oe = G.containerAnimation, le = G.fastScrollEnd, ce = G.preventOverlaps, ue = t.horizontal || t.containerAnimation && !1 !== t.horizontal ? Mr : br, he = !K && 0 !== K, de = Tr(t.scroller || Fr), pe = Ir.core.getCache(de), fe = Rs(de), me = "fixed" === ("pinType"in t ? t.pinType : mr(de, "pinType") || fe && "fixed"), ge = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack], ve = he && t.toggleActions.split(" "), _e = "markers"in t ? t.markers : fa.markers, ye = fe ? 0 : parseFloat(na(de)["border" + ue.p2 + ea]) || 0, xe = this, Se = t.onRefreshInit && function() {
                  return t.onRefreshInit(xe)
              }
              , Ee = function(e, t, i) {
                  var n = i.d
                    , r = i.d2
                    , s = i.a;
                  return (s = mr(e, "getBoundingClientRect")) ? function() {
                      return s()[n]
                  }
                  : function() {
                      return (t ? Ls(r) : e["client" + r]) || 0
                  }
              }(de, fe, ue), Me = function(e, t) {
                  return !t || ~dr.indexOf(e) ? Is(e) : function() {
                      return qa
                  }
              }(de, fe), be = 0, Te = 0, we = 0, De = wr(de, ue);
              if (xe._startClamp = xe._endClamp = !1,
              xe._dir = ue,
              ee *= 45,
              xe.scroller = de,
              xe.scroll = oe ? oe.time.bind(oe) : De,
              a = De(),
              xe.vars = t,
              i = i || t.animation,
              "refreshPriority"in t && (Jr = 1,
              -9999 === t.refreshPriority && (gs = xe)),
              pe.tweenScroll = pe.tweenScroll || {
                  top: Ja(de, br),
                  left: Ja(de, Mr)
              },
              xe.tweenTo = n = pe.tweenScroll[ue.p],
              xe.scrubDuration = function(e) {
                  (F = Bs(e) && e) ? N ? N.duration(e) : N = Ir.to(i, {
                      ease: "expo",
                      totalProgress: "+=0",
                      inherit: !1,
                      duration: F,
                      paused: !0,
                      onComplete: function() {
                          return te && te(xe)
                      }
                  }) : (N && N.progress(1).kill(),
                  N = 0)
              }
              ,
              i && (i.vars.lazy = !1,
              i._initted && !xe.isReverted || !1 !== i.vars.immediateRender && !1 !== t.immediateRender && i.duration() && i.render(0, !0, !0),
              xe.animation = i.pause(),
              i.scrollTrigger = xe,
              xe.scrubDuration(K),
              L = 0,
              q || (q = i.vars.id)),
              re && (zs(re) && !re.push || (re = {
                  snapTo: re
              }),
              "scrollBehavior"in Br.style && Ir.set(fe ? [Br, Ur] : de, {
                  scrollBehavior: "auto"
              }),
              hr.forEach((function(e) {
                  return Us(e) && e.target === (fe ? Or.scrollingElement || Ur : de) && (e.smooth = !1)
              }
              )),
              s = Us(re.snapTo) ? re.snapTo : "labels" === re.snapTo ? function(e) {
                  return function(t) {
                      return Ir.utils.snap(oa(e), t)
                  }
              }(i) : "labelsDirectional" === re.snapTo ? (H = i,
              function(e, t) {
                  return la(oa(H))(e, t.direction)
              }
              ) : !1 !== re.directional ? function(e, t) {
                  return la(re.snapTo)(e, _s() - Te < 500 ? 0 : t.direction)
              }
              : Ir.utils.snap(re.snapTo),
              O = re.duration || {
                  min: .1,
                  max: 2
              },
              O = zs(O) ? Hr(O.min, O.max) : Hr(O, O),
              U = Ir.delayedCall(re.delay || F / 2 || .1, (function() {
                  var e = De()
                    , t = _s() - Te < 500
                    , r = n.tween;
                  if (!(t || Math.abs(xe.getVelocity()) < 10) || r || qr || be === e)
                      xe.isActive && be !== e && U.restart(!0);
                  else {
                      var a, o, u = (e - l) / g, h = i && !he ? i.totalProgress() : u, d = t ? 0 : (h - I) / (_s() - Gr) * 1e3 || 0, p = Ir.utils.clamp(-u, 1 - u, Hs(d / 2) * d / .185), f = u + (!1 === re.inertia ? 0 : p), m = re, v = m.onStart, _ = m.onInterrupt, y = m.onComplete;
                      if (a = s(f, xe),
                      Bs(a) || (a = f),
                      o = Math.round(l + a * g),
                      e <= c && e >= l && o !== e) {
                          if (r && !r._initted && r.data <= Hs(o - e))
                              return;
                          !1 === re.inertia && (p = a - u),
                          n(o, {
                              duration: O(Hs(.185 * Math.max(Hs(f - h), Hs(a - h)) / d / .05 || 0)),
                              ease: re.ease || "power3",
                              data: Hs(o - e),
                              onInterrupt: function() {
                                  return U.restart(!0) && _ && _(xe)
                              },
                              onComplete: function() {
                                  xe.update(),
                                  be = De(),
                                  i && (N ? N.resetTo("totalProgress", a, i._tTime / i._tDur) : i.progress(a)),
                                  L = I = i && !he ? i.totalProgress() : xe.progress,
                                  ie && ie(xe),
                                  y && y(xe)
                              }
                          }, e, p * g, o - e - p * g),
                          v && v(xe, n.tween)
                      }
                  }
              }
              )).pause()),
              q && (xa[q] = xe),
              (V = (Z = xe.trigger = Tr(Z || !0 !== $ && $)) && Z._gsap && Z._gsap.stRevert) && (V = V(xe)),
              $ = !0 === $ ? Z : Tr($),
              Os(X) && (X = {
                  targets: Z,
                  className: X
              }),
              $ && (!1 === J || J === Qs || (J = !(!J && $.parentNode && $.parentNode.style && "flex" === na($.parentNode).display) && Js),
              xe.pin = $,
              (r = Ir.core.getCache($)).spacer ? v = r.pinState : (ae && ((ae = Tr(ae)) && !ae.nodeType && (ae = ae.current || ae.nativeElement),
              r.spacerIsNative = !!ae,
              ae && (r.spacerState = Xa(ae))),
              r.spacer = x = ae || Or.createElement("div"),
              x.classList.add("pin-spacer"),
              q && x.classList.add("pin-spacer-" + q),
              r.pinState = v = Xa($)),
              !1 !== t.force3D && Ir.set($, {
                  force3D: !0
              }),
              xe.spacer = x = r.spacer,
              R = na($),
              w = R[J + ue.os2],
              E = Ir.getProperty($),
              M = Ir.quickSetter($, ue.a, ia),
              Ha($, x, R),
              y = Xa($)),
              _e) {
                  f = zs(_e) ? ra(_e, pa) : pa,
                  d = va("scroller-start", q, de, ue, f, 0),
                  p = va("scroller-end", q, de, ue, f, 0, d),
                  S = d["offset" + ue.op.d2];
                  var Ce = Tr(mr(de, "content") || de);
                  u = this.markerStart = va("start", q, Ce, ue, f, S, 0, oe),
                  h = this.markerEnd = va("end", q, Ce, ue, f, S, 0, oe),
                  oe && (k = Ir.quickSetter([u, h], ue.a, ia)),
                  me || dr.length && !0 === mr(de, "fixedMarkers") || (function(e) {
                      var t = na(e).position;
                      e.style.position = "absolute" === t || "fixed" === t ? t : "relative"
                  }(fe ? Br : de),
                  Ir.set([d, p], {
                      force3D: !0
                  }),
                  C = Ir.quickSetter(d, ue.a, ia),
                  P = Ir.quickSetter(p, ue.a, ia))
              }
              if (oe) {
                  var Ae = oe.vars.onUpdate
                    , Pe = oe.vars.onUpdateParams;
                  oe.eventCallback("onUpdate", (function() {
                      xe.update(0, 0, 1),
                      Ae && Ae.apply(oe, Pe || [])
                  }
                  ))
              }
              if (xe.previous = function() {
                  return ya[ya.indexOf(xe) - 1]
              }
              ,
              xe.next = function() {
                  return ya[ya.indexOf(xe) + 1]
              }
              ,
              xe.revert = function(e, t) {
                  if (!t)
                      return xe.kill(!0);
                  var n = !1 !== e || !xe.enabled
                    , r = Xr;
                  n !== xe.isReverted && (n && (B = Math.max(De(), xe.scroll.rec || 0),
                  we = xe.progress,
                  z = i && i.progress()),
                  u && [u, h, d, p].forEach((function(e) {
                      return e.style.display = n ? "none" : "block"
                  }
                  )),
                  n && (Xr = xe,
                  xe.update(n)),
                  !$ || se && xe.isActive || (n ? function(e, t, i) {
                      Wa(i);
                      var n = e._gsap;
                      if (n.spacerIsNative)
                          Wa(n.spacerState);
                      else if (e._gsap.swappedIn) {
                          var r = t.parentNode;
                          r && (r.insertBefore(e, t),
                          r.removeChild(t))
                      }
                      e._gsap.swappedIn = !1
                  }($, x, v) : Ha($, x, na($), D)),
                  n || xe.update(n),
                  Xr = r,
                  xe.isReverted = n)
              }
              ,
              xe.refresh = function(r, s, f, S) {
                  if (!Xr && xe.enabled || s)
                      if ($ && r && xs)
                          ua(e, "scrollEnd", Da);
                      else {
                          !fs && Se && Se(xe),
                          Xr = xe,
                          n.tween && !f && (n.tween.kill(),
                          n.tween = 0),
                          N && N.pause(),
                          Q && i && i.revert({
                              kill: !1
                          }).invalidate(),
                          xe.isReverted || xe.revert(!0, !0),
                          xe._subPinOffset = !1;
                          var M, w, C, P, R, L, I, F, O, k, V, H, G, W = Ee(), X = Me(), q = oe ? oe.duration() : Ns(de, ue), j = g <= .01, K = 0, ee = S || 0, te = zs(f) ? f.end : t.end, ie = t.endTrigger || Z, ne = zs(f) ? f.start : t.start || (0 !== t.start && Z ? $ ? "0 0" : "0 100%" : 0), re = xe.pinnedContainer = t.pinnedContainer && Tr(t.pinnedContainer, xe), ae = Z && Math.max(0, ya.indexOf(xe)) || 0, le = ae;
                          for (_e && zs(f) && (H = Ir.getProperty(d, ue.p),
                          G = Ir.getProperty(p, ue.p)); le--; )
                              (L = ya[le]).end || L.refresh(0, 1) || (Xr = xe),
                              !(I = L.pin) || I !== Z && I !== $ && I !== re || L.isReverted || (k || (k = []),
                              k.unshift(L),
                              L.revert(!0, !0)),
                              L !== ya[le] && (ae--,
                              le--);
                          for (Us(ne) && (ne = ne(xe)),
                          ne = Es(ne, "start", xe),
                          l = ja(ne, Z, W, ue, De(), u, d, xe, X, ye, me, q, oe, xe._startClamp && "_startClamp") || ($ ? -.001 : 0),
                          Us(te) && (te = te(xe)),
                          Os(te) && !te.indexOf("+=") && (~te.indexOf(" ") ? te = (Os(ne) ? ne.split(" ")[0] : "") + te : (K = ga(te.substr(2), W),
                          te = Os(ne) ? ne : (oe ? Ir.utils.mapRange(0, oe.duration(), oe.scrollTrigger.start, oe.scrollTrigger.end, l) : l) + K,
                          ie = Z)),
                          te = Es(te, "end", xe),
                          c = Math.max(l, ja(te || (ie ? "100% 0" : q), ie, W, ue, De() + K, h, p, xe, X, ye, me, q, oe, xe._endClamp && "_endClamp")) || -.001,
                          K = 0,
                          le = ae; le--; )
                              (I = (L = ya[le]).pin) && L.start - L._pinPush <= l && !oe && L.end > 0 && (M = L.end - (xe._startClamp ? Math.max(0, L.start) : L.start),
                              (I === Z && L.start - L._pinPush < l || I === re) && isNaN(ne) && (K += M * (1 - L.progress)),
                              I === $ && (ee += M));
                          if (l += K,
                          c += K,
                          xe._startClamp && (xe._startClamp += K),
                          xe._endClamp && !fs && (xe._endClamp = c || -.001,
                          c = Math.min(c, Ns(de, ue))),
                          g = c - l || (l -= .01) && .001,
                          j && (we = Ir.utils.clamp(0, 1, Ir.utils.normalize(l, c, B))),
                          xe._pinPush = ee,
                          u && K && ((M = {})[ue.a] = "+=" + K,
                          re && (M[ue.p] = "-=" + De()),
                          Ir.set([u, h], M)),
                          !$ || hs && xe.end >= Ns(de, ue)) {
                              if (Z && De() && !oe)
                                  for (w = Z.parentNode; w && w !== Br; )
                                      w._pinOffset && (l -= w._pinOffset,
                                      c -= w._pinOffset),
                                      w = w.parentNode
                          } else
                              M = na($),
                              P = ue === br,
                              C = De(),
                              b = parseFloat(E(ue.a)) + ee,
                              !q && c > 1 && (V = {
                                  style: V = (fe ? Or.scrollingElement || Ur : de).style,
                                  value: V["overflow" + ue.a.toUpperCase()]
                              },
                              fe && "scroll" !== na(Br)["overflow" + ue.a.toUpperCase()] && (V.style["overflow" + ue.a.toUpperCase()] = "scroll")),
                              Ha($, x, M),
                              y = Xa($),
                              w = sa($, !0),
                              F = me && wr(de, P ? Mr : br)(),
                              J ? ((D = [J + ue.os2, g + ee + ia]).t = x,
                              (le = J === Js ? aa($, ue) + g + ee : 0) && (D.push(ue.d, le + ia),
                              "auto" !== x.style.flexBasis && (x.style.flexBasis = le + ia)),
                              Wa(D),
                              re && ya.forEach((function(e) {
                                  e.pin === re && !1 !== e.vars.pinSpacing && (e._subPinOffset = !0)
                              }
                              )),
                              me && De(B)) : (le = aa($, ue)) && "auto" !== x.style.flexBasis && (x.style.flexBasis = le + ia),
                              me && ((R = {
                                  top: w.top + (P ? C - l : F) + ia,
                                  left: w.left + (P ? F : C - l) + ia,
                                  boxSizing: "border-box",
                                  position: "fixed"
                              })[qs] = R["max" + ea] = Math.ceil(w.width) + ia,
                              R[js] = R["max" + ta] = Math.ceil(w.height) + ia,
                              R[Qs] = R[Qs + Zs] = R[Qs + Ys] = R[Qs + $s] = R[Qs + Ks] = "0",
                              R[Js] = M[Js],
                              R[Js + Zs] = M[Js + Zs],
                              R[Js + Ys] = M[Js + Ys],
                              R[Js + $s] = M[Js + $s],
                              R[Js + Ks] = M[Js + Ks],
                              _ = function(e, t, i) {
                                  for (var n, r = [], s = e.length, a = i ? 8 : 0; a < s; a += 2)
                                      n = e[a],
                                      r.push(n, n in t ? t[n] : e[a + 1]);
                                  return r.t = e.t,
                                  r
                              }(v, R, se),
                              fs && De(0)),
                              i ? (O = i._initted,
                              Qr(1),
                              i.render(i.duration(), !0, !0),
                              T = E(ue.a) - b + g + ee,
                              A = Math.abs(g - T) > 1,
                              me && A && _.splice(_.length - 2, 2),
                              i.render(0, !0, !0),
                              O || i.invalidate(!0),
                              i.parent || i.totalTime(i.totalTime()),
                              Qr(0)) : T = g,
                              V && (V.value ? V.style["overflow" + ue.a.toUpperCase()] = V.value : V.style.removeProperty("overflow-" + ue.a));
                          k && k.forEach((function(e) {
                              return e.revert(!1, !0)
                          }
                          )),
                          xe.start = l,
                          xe.end = c,
                          a = o = fs ? B : De(),
                          oe || fs || (a < B && De(B),
                          xe.scroll.rec = 0),
                          xe.revert(!1, !0),
                          Te = _s(),
                          U && (be = -1,
                          U.restart(!0)),
                          Xr = 0,
                          i && he && (i._initted || z) && i.progress() !== z && i.progress(z || 0, !0).render(i.time(), !0, !0),
                          (j || we !== xe.progress || oe || Q) && (i && !he && i.totalProgress(oe && l < -.001 && !we ? Ir.utils.normalize(l, c, 0) : we, !0),
                          xe.progress = j || (a - l) / g === we ? 0 : we),
                          $ && J && (x._pinOffset = Math.round(xe.progress * T)),
                          N && N.invalidate(),
                          isNaN(H) || (H -= Ir.getProperty(d, ue.p),
                          G -= Ir.getProperty(p, ue.p),
                          $a(d, ue, H),
                          $a(u, ue, H - (S || 0)),
                          $a(p, ue, G),
                          $a(h, ue, G - (S || 0))),
                          j && !fs && xe.update(),
                          !Y || fs || m || (m = !0,
                          Y(xe),
                          m = !1)
                      }
              }
              ,
              xe.getVelocity = function() {
                  return (De() - o) / (_s() - Gr) * 1e3 || 0
              }
              ,
              xe.endAnimation = function() {
                  ks(xe.callbackAnimation),
                  i && (N ? N.progress(1) : i.paused() ? he || ks(i, xe.direction < 0, 1) : ks(i, i.reversed()))
              }
              ,
              xe.labelToScroll = function(e) {
                  return i && i.labels && (l || xe.refresh() || l) + i.labels[e] / i.duration() * g || 0
              }
              ,
              xe.getTrailing = function(e) {
                  var t = ya.indexOf(xe)
                    , i = xe.direction > 0 ? ya.slice(0, t).reverse() : ya.slice(t + 1);
                  return (Os(e) ? i.filter((function(t) {
                      return t.vars.preventOverlaps === e
                  }
                  )) : i).filter((function(e) {
                      return xe.direction > 0 ? e.end <= l : e.start >= c
                  }
                  ))
              }
              ,
              xe.update = function(e, t, r) {
                  if (!oe || r || e) {
                      var s, u, h, p, f, m, v, S = !0 === fs ? B : xe.scroll(), E = e ? 0 : (S - l) / g, D = E < 0 ? 0 : E > 1 ? 1 : E || 0, R = xe.progress;
                      if (t && (o = a,
                      a = oe ? De() : S,
                      re && (I = L,
                      L = i && !he ? i.totalProgress() : D)),
                      ee && $ && !Xr && !vs && xs && (!D && l < S + (S - o) / (_s() - Gr) * ee ? D = 1e-4 : 1 === D && c > S + (S - o) / (_s() - Gr) * ee && (D = .9999)),
                      D !== R && xe.enabled) {
                          if (p = (f = (s = xe.isActive = !!D && D < 1) != (!!R && R < 1)) || !!D != !!R,
                          xe.direction = D > R ? 1 : -1,
                          xe.progress = D,
                          p && !Xr && (u = D && !R ? 0 : 1 === D ? 1 : 1 === R ? 2 : 3,
                          he && (h = !f && "none" !== ve[u + 1] && ve[u + 1] || ve[u],
                          v = i && ("complete" === h || "reset" === h || h in i))),
                          ce && (f || v) && (v || K || !i) && (Us(ce) ? ce(xe) : xe.getTrailing(ce).forEach((function(e) {
                              return e.endAnimation()
                          }
                          ))),
                          he || (!N || Xr || vs ? i && i.totalProgress(D, !(!Xr || !Te && !e)) : (N._dp._time - N._start !== N._time && N.render(N._dp._time - N._start),
                          N.resetTo ? N.resetTo("totalProgress", D, i._tTime / i._tDur) : (N.vars.totalProgress = D,
                          N.invalidate().restart()))),
                          $)
                              if (e && J && (x.style[J + ue.os2] = w),
                              me) {
                                  if (p) {
                                      if (m = !e && D > R && c + 1 > S && S + 1 >= Ns(de, ue),
                                      se)
                                          if (e || !s && !m)
                                              Ka($, x);
                                          else {
                                              var F = sa($, !0)
                                                , O = S - l;
                                              Ka($, Br, F.top + (ue === br ? O : 0) + ia, F.left + (ue === br ? 0 : O) + ia)
                                          }
                                      Wa(s || m ? _ : y),
                                      A && D < 1 && s || M(b + (1 !== D || m ? 0 : T))
                                  }
                              } else
                                  M(Cs(b + T * D));
                          re && !n.tween && !Xr && !vs && U.restart(!0),
                          X && (f || ne && D && (D < 1 || !ds)) && Vr(X.targets).forEach((function(e) {
                              return e.classList[s || ne ? "add" : "remove"](X.className)
                          }
                          )),
                          W && !he && !e && W(xe),
                          p && !Xr ? (he && (v && ("complete" === h ? i.pause().totalProgress(1) : "reset" === h ? i.restart(!0).pause() : "restart" === h ? i.restart(!0) : i[h]()),
                          W && W(xe)),
                          !f && ds || (j && f && Vs(xe, j),
                          ge[u] && Vs(xe, ge[u]),
                          ne && (1 === D ? xe.kill(!1, 1) : ge[u] = 0),
                          f || ge[u = 1 === D ? 1 : 3] && Vs(xe, ge[u])),
                          le && !s && Math.abs(xe.getVelocity()) > (Bs(le) ? le : 2500) && (ks(xe.callbackAnimation),
                          N ? N.progress(1) : ks(i, "reverse" === h ? 1 : !D, 1))) : he && W && !Xr && W(xe)
                      }
                      if (P) {
                          var z = oe ? S / oe.duration() * (oe._caScrollDist || 0) : S;
                          C(z + (d._isFlipped ? 1 : 0)),
                          P(z)
                      }
                      k && k(-S / oe.duration() * (oe._caScrollDist || 0))
                  }
              }
              ,
              xe.enable = function(t, i) {
                  xe.enabled || (xe.enabled = !0,
                  ua(de, "resize", ba),
                  fe || ua(de, "scroll", Ea),
                  Se && ua(e, "refreshInit", Se),
                  !1 !== t && (xe.progress = we = 0,
                  a = o = be = De()),
                  !1 !== i && xe.refresh())
              }
              ,
              xe.getTween = function(e) {
                  return e && n ? n.tween : N
              }
              ,
              xe.setPositions = function(e, t, i, n) {
                  if (oe) {
                      var r = oe.scrollTrigger
                        , s = oe.duration()
                        , a = r.end - r.start;
                      e = r.start + a * e / s,
                      t = r.start + a * t / s
                  }
                  xe.refresh(!1, !1, {
                      start: Ms(e, i && !!xe._startClamp),
                      end: Ms(t, i && !!xe._endClamp)
                  }, n),
                  xe.update()
              }
              ,
              xe.adjustPinSpacing = function(e) {
                  if (D && e) {
                      var t = D.indexOf(ue.d) + 1;
                      D[t] = parseFloat(D[t]) + e + ia,
                      D[1] = parseFloat(D[1]) + e + ia,
                      Wa(D)
                  }
              }
              ,
              xe.disable = function(t, i) {
                  if (xe.enabled && (!1 !== t && xe.revert(!0, !0),
                  xe.enabled = xe.isActive = !1,
                  i || N && N.pause(),
                  B = 0,
                  r && (r.uncache = 1),
                  Se && ha(e, "refreshInit", Se),
                  U && (U.pause(),
                  n.tween && n.tween.kill() && (n.tween = 0)),
                  !fe)) {
                      for (var s = ya.length; s--; )
                          if (ya[s].scroller === de && ya[s] !== xe)
                              return;
                      ha(de, "resize", ba),
                      fe || ha(de, "scroll", Ea)
                  }
              }
              ,
              xe.kill = function(e, n) {
                  xe.disable(e, n),
                  N && !n && N.kill(),
                  q && delete xa[q];
                  var s = ya.indexOf(xe);
                  s >= 0 && ya.splice(s, 1),
                  s === Yr && Ba > 0 && Yr--,
                  s = 0,
                  ya.forEach((function(e) {
                      return e.scroller === xe.scroller && (s = 1)
                  }
                  )),
                  s || fs || (xe.scroll.rec = 0),
                  i && (i.scrollTrigger = null,
                  e && i.revert({
                      kill: !1
                  }),
                  n || i.kill()),
                  u && [u, h, d, p].forEach((function(e) {
                      return e.parentNode && e.parentNode.removeChild(e)
                  }
                  )),
                  gs === xe && (gs = 0),
                  $ && (r && (r.uncache = 1),
                  s = 0,
                  ya.forEach((function(e) {
                      return e.pin === $ && s++
                  }
                  )),
                  s || (r.spacer = 0)),
                  t.onKill && t.onKill(xe)
              }
              ,
              ya.push(xe),
              xe.enable(!1, !1),
              V && V(xe),
              i && i.add && !g) {
                  var Re = xe.update;
                  xe.update = function() {
                      xe.update = Re,
                      l || c || xe.refresh()
                  }
                  ,
                  Ir.delayedCall(.01, xe.update),
                  g = .01,
                  l = c = 0
              } else
                  xe.refresh();
              $ && function() {
                  if (ms !== Ia) {
                      var e = ms = Ia;
                      requestAnimationFrame((function() {
                          return e === Ia && Oa(!0)
                      }
                      ))
                  }
              }()
          } else
              this.update = this.refresh = this.kill = Ds
      }
      ,
      e.register = function(t) {
          return Nr || (Ir = t || Ps(),
          As() && window.document && e.enable(),
          Nr = Ss),
          Nr
      }
      ,
      e.defaults = function(e) {
          if (e)
              for (var t in e)
                  fa[t] = e[t];
          return fa
      }
      ,
      e.disable = function(e, t) {
          Ss = 0,
          ya.forEach((function(i) {
              return i[t ? "kill" : "disable"](e)
          }
          )),
          ha(Fr, "wheel", Ea),
          ha(Or, "scroll", Ea),
          clearInterval(Wr),
          ha(Or, "touchcancel", Ds),
          ha(Br, "touchstart", Ds),
          ca(ha, Or, "pointerdown,touchstart,mousedown", Ts),
          ca(ha, Or, "pointerup,touchend,mouseup", ws),
          kr.kill(),
          Fs(ha);
          for (var i = 0; i < hr.length; i += 3)
              da(ha, hr[i], hr[i + 1]),
              da(ha, hr[i], hr[i + 2])
      }
      ,
      e.enable = function() {
          if (Fr = window,
          Or = document,
          Ur = Or.documentElement,
          Br = Or.body,
          Ir && (Vr = Ir.utils.toArray,
          Hr = Ir.utils.clamp,
          as = Ir.core.context || Ds,
          Qr = Ir.core.suppressOverwrites || Ds,
          os = Fr.history.scrollRestoration || "auto",
          Ua = Fr.pageYOffset,
          Ir.core.globals("ScrollTrigger", e),
          Br)) {
              Ss = 1,
              (ls = document.createElement("div")).style.height = "100vh",
              ls.style.position = "absolute",
              Na(),
              bs(),
              Lr.register(Ir),
              e.isTouch = Lr.isTouch,
              ss = Lr.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
              is = 1 === Lr.isTouch,
              ua(Fr, "wheel", Ea),
              zr = [Fr, Or, Ur, Br],
              Ir.matchMedia ? (e.matchMedia = function(e) {
                  var t, i = Ir.matchMedia();
                  for (t in e)
                      i.add(t, e[t]);
                  return i
              }
              ,
              Ir.addEventListener("matchMediaInit", (function() {
                  return Ra()
              }
              )),
              Ir.addEventListener("matchMediaRevert", (function() {
                  return Pa()
              }
              )),
              Ir.addEventListener("matchMedia", (function() {
                  Oa(0, 1),
                  Ca("matchMedia")
              }
              )),
              Ir.matchMedia("(orientation: portrait)", (function() {
                  return Ma(),
                  Ma
              }
              ))) : console.warn("Requires GSAP 3.11.0 or later"),
              Ma(),
              ua(Or, "scroll", Ea);
              var t, i, n = Br.style, r = n.borderTopStyle, s = Ir.core.Animation.prototype;
              for (s.revert || Object.defineProperty(s, "revert", {
                  value: function() {
                      return this.time(-.01, !0)
                  }
              }),
              n.borderTopStyle = "solid",
              t = sa(Br),
              br.m = Math.round(t.top + br.sc()) || 0,
              Mr.m = Math.round(t.left + Mr.sc()) || 0,
              r ? n.borderTopStyle = r : n.removeProperty("border-top-style"),
              Wr = setInterval(Sa, 250),
              Ir.delayedCall(.9, (function() {
                  return vs = 0
              }
              )),
              ua(Or, "touchcancel", Ds),
              ua(Br, "touchstart", Ds),
              ca(ua, Or, "pointerdown,touchstart,mousedown", Ts),
              ca(ua, Or, "pointerup,touchend,mouseup", ws),
              jr = Ir.utils.checkPrefix("transform"),
              Va.push(jr),
              Nr = _s(),
              kr = Ir.delayedCall(.2, Oa).pause(),
              $r = [Or, "visibilitychange", function() {
                  var e = Fr.innerWidth
                    , t = Fr.innerHeight;
                  Or.hidden ? (Kr = e,
                  Zr = t) : Kr === e && Zr === t || ba()
              }
              , Or, "DOMContentLoaded", Oa, Fr, "load", Oa, Fr, "resize", ba],
              Fs(ua),
              ya.forEach((function(e) {
                  return e.enable(0, 1)
              }
              )),
              i = 0; i < hr.length; i += 3)
                  da(ha, hr[i], hr[i + 1]),
                  da(ha, hr[i], hr[i + 2])
          }
      }
      ,
      e.config = function(t) {
          "limitCallbacks"in t && (ds = !!t.limitCallbacks);
          var i = t.syncInterval;
          i && clearInterval(Wr) || (Wr = i) && setInterval(Sa, i),
          "ignoreMobileResize"in t && (is = 1 === e.isTouch && t.ignoreMobileResize),
          "autoRefreshEvents"in t && (Fs(ha) || Fs(ua, t.autoRefreshEvents || "none"),
          es = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
      }
      ,
      e.scrollerProxy = function(e, t) {
          var i = Tr(e)
            , n = hr.indexOf(i)
            , r = Rs(i);
          ~n && hr.splice(n, r ? 6 : 2),
          t && (r ? dr.unshift(Fr, t, Br, t, Ur, t) : dr.unshift(i, t))
      }
      ,
      e.clearMatchMedia = function(e) {
          ya.forEach((function(t) {
              return t._ctx && t._ctx.query === e && t._ctx.kill(!0, !0)
          }
          ))
      }
      ,
      e.isInViewport = function(e, t, i) {
          var n = (Os(e) ? Tr(e) : e).getBoundingClientRect()
            , r = n[i ? qs : js] * t || 0;
          return i ? n.right - r > 0 && n.left + r < Fr.innerWidth : n.bottom - r > 0 && n.top + r < Fr.innerHeight
      }
      ,
      e.positionInViewport = function(e, t, i) {
          Os(e) && (e = Tr(e));
          var n = e.getBoundingClientRect()
            , r = n[i ? qs : js]
            , s = null == t ? r / 2 : t in ma ? ma[t] * r : ~t.indexOf("%") ? parseFloat(t) * r / 100 : parseFloat(t) || 0;
          return i ? (n.left + s) / Fr.innerWidth : (n.top + s) / Fr.innerHeight
      }
      ,
      e.killAll = function(e) {
          if (ya.slice(0).forEach((function(e) {
              return "ScrollSmoother" !== e.vars.id && e.kill()
          }
          )),
          !0 !== e) {
              var t = Ta.killAll || [];
              Ta = {},
              t.forEach((function(e) {
                  return e()
              }
              ))
          }
      }
      ,
      e
  }();
  Qa.version = "3.12.5",
  Qa.saveStyles = function(e) {
      return e ? Vr(e).forEach((function(e) {
          if (e && e.style) {
              var t = Aa.indexOf(e);
              t >= 0 && Aa.splice(t, 5),
              Aa.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Ir.core.getCache(e), as())
          }
      }
      )) : Aa
  }
  ,
  Qa.revert = function(e, t) {
      return Ra(!e, t)
  }
  ,
  Qa.create = function(e, t) {
      return new Qa(e,t)
  }
  ,
  Qa.refresh = function(e) {
      return e ? ba() : (Nr || Qa.register()) && Oa(!0)
  }
  ,
  Qa.update = function(e) {
      return ++hr.cache && za(!0 === e ? 2 : 0)
  }
  ,
  Qa.clearScrollMemory = La,
  Qa.maxScroll = function(e, t) {
      return Ns(e, t ? Mr : br)
  }
  ,
  Qa.getScrollFunc = function(e, t) {
      return wr(Tr(e), t ? Mr : br)
  }
  ,
  Qa.getById = function(e) {
      return xa[e]
  }
  ,
  Qa.getAll = function() {
      return ya.filter((function(e) {
          return "ScrollSmoother" !== e.vars.id
      }
      ))
  }
  ,
  Qa.isScrolling = function() {
      return !!xs
  }
  ,
  Qa.snapDirectional = la,
  Qa.addEventListener = function(e, t) {
      var i = Ta[e] || (Ta[e] = []);
      ~i.indexOf(t) || i.push(t)
  }
  ,
  Qa.removeEventListener = function(e, t) {
      var i = Ta[e]
        , n = i && i.indexOf(t);
      n >= 0 && i.splice(n, 1)
  }
  ,
  Qa.batch = function(e, t) {
      var i, n = [], r = {}, s = t.interval || .016, a = t.batchMax || 1e9, o = function(e, t) {
          var i = []
            , n = []
            , r = Ir.delayedCall(s, (function() {
              t(i, n),
              i = [],
              n = []
          }
          )).pause();
          return function(e) {
              i.length || r.restart(!0),
              i.push(e.trigger),
              n.push(e),
              a <= i.length && r.progress(1)
          }
      };
      for (i in t)
          r[i] = "on" === i.substr(0, 2) && Us(t[i]) && "onRefreshInit" !== i ? o(0, t[i]) : t[i];
      return Us(a) && (a = a(),
      ua(Qa, "refresh", (function() {
          return a = t.batchMax()
      }
      ))),
      Vr(e).forEach((function(e) {
          var t = {};
          for (i in r)
              t[i] = r[i];
          t.trigger = e,
          n.push(Qa.create(t))
      }
      )),
      n
  }
  ;
  var eo, to = function(e, t, i, n) {
      return t > n ? e(n) : t < 0 && e(0),
      i > n ? (n - t) / (i - t) : i < 0 ? t / (t - i) : 1
  }, io = function e(t, i) {
      !0 === i ? t.style.removeProperty("touch-action") : t.style.touchAction = !0 === i ? "auto" : i ? "pan-" + i + (Lr.isTouch ? " pinch-zoom" : "") : "none",
      t === Ur && e(Br, i)
  }, no = {
      auto: 1,
      scroll: 1
  }, ro = function(e) {
      var t, i = e.event, n = e.target, r = e.axis, s = (i.changedTouches ? i.changedTouches[0] : i).target, a = s._gsap || Ir.core.getCache(s), o = _s();
      if (!a._isScrollT || o - a._isScrollT > 2e3) {
          for (; s && s !== Br && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !no[(t = na(s)).overflowY] && !no[t.overflowX]); )
              s = s.parentNode;
          a._isScroll = s && s !== n && !Rs(s) && (no[(t = na(s)).overflowY] || no[t.overflowX]),
          a._isScrollT = o
      }
      (a._isScroll || "x" === r) && (i.stopPropagation(),
      i._gsapAllow = !0)
  }, so = function(e, t, i, n) {
      return Lr.create({
          target: e,
          capture: !0,
          debounce: !1,
          lockAxis: !0,
          type: t,
          onWheel: n = n && ro,
          onPress: n,
          onDrag: n,
          onScroll: n,
          onEnable: function() {
              return i && ua(Or, Lr.eventTypes[0], oo, !1, !0)
          },
          onDisable: function() {
              return ha(Or, Lr.eventTypes[0], oo, !0)
          }
      })
  }, ao = /(input|label|select|textarea)/i, oo = function(e) {
      var t = ao.test(e.target.tagName);
      (t || eo) && (e._gsapAllow = !0,
      eo = t)
  };
  Qa.sort = function(e) {
      return ya.sort(e || function(e, t) {
          return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0))
      }
      )
  }
  ,
  Qa.observe = function(e) {
      return new Lr(e)
  }
  ,
  Qa.normalizeScroll = function(e) {
      if (void 0 === e)
          return ts;
      if (!0 === e && ts)
          return ts.enable();
      if (!1 === e)
          return ts && ts.kill(),
          void (ts = e);
      var t = e instanceof Lr ? e : function(e) {
          zs(e) || (e = {}),
          e.preventDefault = e.isNormalizer = e.allowClicks = !0,
          e.type || (e.type = "wheel,touch"),
          e.debounce = !!e.debounce,
          e.id = e.id || "normalizer";
          var t, i, n, r, s, a, o, l, c = e, u = c.normalizeScrollX, h = c.momentum, d = c.allowNestedScroll, p = c.onRelease, f = Tr(e.target) || Ur, m = Ir.core.globals().ScrollSmoother, g = m && m.get(), v = ss && (e.content && Tr(e.content) || g && !1 !== e.content && !g.smooth() && g.content()), _ = wr(f, br), y = wr(f, Mr), x = 1, S = (Lr.isTouch && Fr.visualViewport ? Fr.visualViewport.scale * Fr.visualViewport.width : Fr.outerWidth) / Fr.innerWidth, E = 0, M = Us(h) ? function() {
              return h(t)
          }
          : function() {
              return h || 2.8
          }
          , b = so(f, e.type, !0, d), T = function() {
              return r = !1
          }, w = Ds, D = Ds, C = function() {
              i = Ns(f, br),
              D = Hr(ss ? 1 : 0, i),
              u && (w = Hr(0, Ns(f, Mr))),
              n = Ia
          }, A = function() {
              v._gsap.y = Cs(parseFloat(v._gsap.y) + _.offset) + "px",
              v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)",
              _.offset = _.cacheID = 0
          }, P = function() {
              C(),
              s.isActive() && s.vars.scrollY > i && (_() > i ? s.progress(1) && _(i) : s.resetTo("scrollY", i))
          };
          return v && Ir.set(v, {
              y: "+=0"
          }),
          e.ignoreCheck = function(e) {
              return ss && "touchmove" === e.type && function() {
                  if (r) {
                      requestAnimationFrame(T);
                      var e = Cs(t.deltaY / 2)
                        , i = D(_.v - e);
                      if (v && i !== _.v + _.offset) {
                          _.offset = i - _.v;
                          var n = Cs((parseFloat(v && v._gsap.y) || 0) - _.offset);
                          v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + n + ", 0, 1)",
                          v._gsap.y = n + "px",
                          _.cacheID = hr.cache,
                          za()
                      }
                      return !0
                  }
                  _.offset && A(),
                  r = !0
              }() || x > 1.05 && "touchstart" !== e.type || t.isGesturing || e.touches && e.touches.length > 1
          }
          ,
          e.onPress = function() {
              r = !1;
              var e = x;
              x = Cs((Fr.visualViewport && Fr.visualViewport.scale || 1) / S),
              s.pause(),
              e !== x && io(f, x > 1.01 || !u && "x"),
              a = y(),
              o = _(),
              C(),
              n = Ia
          }
          ,
          e.onRelease = e.onGestureStart = function(e, t) {
              if (_.offset && A(),
              t) {
                  hr.cache++;
                  var n, r, a = M();
                  u && (r = (n = y()) + .05 * a * -e.velocityX / .227,
                  a *= to(y, n, r, Ns(f, Mr)),
                  s.vars.scrollX = w(r)),
                  r = (n = _()) + .05 * a * -e.velocityY / .227,
                  a *= to(_, n, r, Ns(f, br)),
                  s.vars.scrollY = D(r),
                  s.invalidate().duration(a).play(.01),
                  (ss && s.vars.scrollY >= i || n >= i - 1) && Ir.to({}, {
                      onUpdate: P,
                      duration: a
                  })
              } else
                  l.restart(!0);
              p && p(e)
          }
          ,
          e.onWheel = function() {
              s._ts && s.pause(),
              _s() - E > 1e3 && (n = 0,
              E = _s())
          }
          ,
          e.onChange = function(e, t, i, r, s) {
              if (Ia !== n && C(),
              t && u && y(w(r[2] === t ? a + (e.startX - e.x) : y() + t - r[1])),
              i) {
                  _.offset && A();
                  var l = s[2] === i
                    , c = l ? o + e.startY - e.y : _() + i - s[1]
                    , h = D(c);
                  l && c !== h && (o += h - c),
                  _(h)
              }
              (i || t) && za()
          }
          ,
          e.onEnable = function() {
              io(f, !u && "x"),
              Qa.addEventListener("refresh", P),
              ua(Fr, "resize", P),
              _.smooth && (_.target.style.scrollBehavior = "auto",
              _.smooth = y.smooth = !1),
              b.enable()
          }
          ,
          e.onDisable = function() {
              io(f, !0),
              ha(Fr, "resize", P),
              Qa.removeEventListener("refresh", P),
              b.kill()
          }
          ,
          e.lockAxis = !1 !== e.lockAxis,
          (t = new Lr(e)).iOS = ss,
          ss && !_() && _(1),
          ss && Ir.ticker.add(Ds),
          l = t._dc,
          s = Ir.to(t, {
              ease: "power4",
              paused: !0,
              inherit: !1,
              scrollX: u ? "+=0.1" : "+=0",
              scrollY: "+=0.1",
              modifiers: {
                  scrollY: Za(_, _(), (function() {
                      return s.pause()
                  }
                  ))
              },
              onUpdate: za,
              onComplete: l.vars.onComplete
          }),
          t
      }(e);
      return ts && ts.target === t.target && ts.kill(),
      Rs(t.target) && (ts = t),
      t
  }
  ,
  Qa.core = {
      _getVelocityProp: Dr,
      _inputObserver: so,
      _scrollers: hr,
      _proxies: dr,
      bridge: {
          ss: function() {
              xs || Ca("scrollStart"),
              xs = _s()
          },
          ref: function() {
              return Xr
          }
      }
  },
  Ps() && Ir.registerPlugin(Qa);
  var lo, co, uo, ho, po, fo, mo, go, vo = function() {
      return "undefined" != typeof window
  }, _o = function() {
      return lo || vo() && (lo = window.gsap) && lo.registerPlugin && lo
  }, yo = function(e) {
      return "string" == typeof e
  }, xo = function(e) {
      return "function" == typeof e
  }, So = function(e, t) {
      var i = "x" === t ? "Width" : "Height"
        , n = "scroll" + i
        , r = "client" + i;
      return e === uo || e === ho || e === po ? Math.max(ho[n], po[n]) - (uo["inner" + i] || ho[r] || po[r]) : e[n] - e["offset" + i]
  }, Eo = function(e, t) {
      var i = "scroll" + ("x" === t ? "Left" : "Top");
      return e === uo && (null != e.pageXOffset ? i = "page" + t.toUpperCase() + "Offset" : e = null != ho[i] ? ho : po),
      function() {
          return e[i]
      }
  }, Mo = function(e, t) {
      if (!(e = fo(e)[0]) || !e.getBoundingClientRect)
          return console.warn("scrollTo target doesn't exist. Using 0") || {
              x: 0,
              y: 0
          };
      var i = e.getBoundingClientRect()
        , n = !t || t === uo || t === po
        , r = n ? {
          top: ho.clientTop - (uo.pageYOffset || ho.scrollTop || po.scrollTop || 0),
          left: ho.clientLeft - (uo.pageXOffset || ho.scrollLeft || po.scrollLeft || 0)
      } : t.getBoundingClientRect()
        , s = {
          x: i.left - r.left,
          y: i.top - r.top
      };
      return !n && t && (s.x += Eo(t, "x")(),
      s.y += Eo(t, "y")()),
      s
  }, bo = function(e, t, i, n, r) {
      return isNaN(e) || "object" == typeof e ? yo(e) && "=" === e.charAt(1) ? parseFloat(e.substr(2)) * ("-" === e.charAt(0) ? -1 : 1) + n - r : "max" === e ? So(t, i) - r : Math.min(So(t, i), Mo(e, t)[i] - r) : parseFloat(e) - r
  }, To = function() {
      lo = _o(),
      vo() && lo && "undefined" != typeof document && document.body && (uo = window,
      po = document.body,
      ho = document.documentElement,
      fo = lo.utils.toArray,
      lo.config({
          autoKillThreshold: 7
      }),
      mo = lo.config(),
      co = 1)
  }, wo = {
      version: "3.12.5",
      name: "scrollTo",
      rawVars: 1,
      register: function(e) {
          lo = e,
          To()
      },
      init: function(e, t, i, n, r) {
          co || To();
          var s = this
            , a = lo.getProperty(e, "scrollSnapType");
          s.isWin = e === uo,
          s.target = e,
          s.tween = i,
          t = function(e, t, i, n) {
              if (xo(e) && (e = e(t, i, n)),
              "object" != typeof e)
                  return yo(e) && "max" !== e && "=" !== e.charAt(1) ? {
                      x: e,
                      y: e
                  } : {
                      y: e
                  };
              if (e.nodeType)
                  return {
                      y: e,
                      x: e
                  };
              var r, s = {};
              for (r in e)
                  s[r] = "onAutoKill" !== r && xo(e[r]) ? e[r](t, i, n) : e[r];
              return s
          }(t, n, e, r),
          s.vars = t,
          s.autoKill = !!t.autoKill,
          s.getX = Eo(e, "x"),
          s.getY = Eo(e, "y"),
          s.x = s.xPrev = s.getX(),
          s.y = s.yPrev = s.getY(),
          go || (go = lo.core.globals().ScrollTrigger),
          "smooth" === lo.getProperty(e, "scrollBehavior") && lo.set(e, {
              scrollBehavior: "auto"
          }),
          a && "none" !== a && (s.snap = 1,
          s.snapInline = e.style.scrollSnapType,
          e.style.scrollSnapType = "none"),
          null != t.x ? (s.add(s, "x", s.x, bo(t.x, e, "x", s.x, t.offsetX || 0), n, r),
          s._props.push("scrollTo_x")) : s.skipX = 1,
          null != t.y ? (s.add(s, "y", s.y, bo(t.y, e, "y", s.y, t.offsetY || 0), n, r),
          s._props.push("scrollTo_y")) : s.skipY = 1
      },
      render: function(e, t) {
          for (var i, n, r, s, a, o = t._pt, l = t.target, c = t.tween, u = t.autoKill, h = t.xPrev, d = t.yPrev, p = t.isWin, f = t.snap, m = t.snapInline; o; )
              o.r(e, o.d),
              o = o._next;
          i = p || !t.skipX ? t.getX() : h,
          r = (n = p || !t.skipY ? t.getY() : d) - d,
          s = i - h,
          a = mo.autoKillThreshold,
          t.x < 0 && (t.x = 0),
          t.y < 0 && (t.y = 0),
          u && (!t.skipX && (s > a || s < -a) && i < So(l, "x") && (t.skipX = 1),
          !t.skipY && (r > a || r < -a) && n < So(l, "y") && (t.skipY = 1),
          t.skipX && t.skipY && (c.kill(),
          t.vars.onAutoKill && t.vars.onAutoKill.apply(c, t.vars.onAutoKillParams || []))),
          p ? uo.scrollTo(t.skipX ? i : t.x, t.skipY ? n : t.y) : (t.skipY || (l.scrollTop = t.y),
          t.skipX || (l.scrollLeft = t.x)),
          !f || 1 !== e && 0 !== e || (n = l.scrollTop,
          i = l.scrollLeft,
          m ? l.style.scrollSnapType = m : l.style.removeProperty("scroll-snap-type"),
          l.scrollTop = n + 1,
          l.scrollLeft = i + 1,
          l.scrollTop = n,
          l.scrollLeft = i),
          t.xPrev = t.x,
          t.yPrev = t.y,
          go && go.update()
      },
      kill: function(e) {
          var t = "scrollTo" === e
            , i = this._props.indexOf(e);
          return (t || "scrollTo_x" === e) && (this.skipX = 1),
          (t || "scrollTo_y" === e) && (this.skipY = 1),
          i > -1 && this._props.splice(i, 1),
          !this._props.length
      }
  };
  function Do(e, t, i) {
      return Math.max(e, Math.min(t, i))
  }
  wo.max = So,
  wo.getOffset = Mo,
  wo.buildGetter = Eo,
  _o() && lo.registerPlugin(wo);
  class Co {
      constructor() {
          this.isRunning = !1,
          this.value = 0,
          this.from = 0,
          this.to = 0,
          this.duration = 0,
          this.currentTime = 0
      }
      advance(e) {
          var t;
          if (!this.isRunning)
              return;
          let i = !1;
          if (this.duration && this.easing) {
              this.currentTime += e;
              const t = Do(0, this.currentTime / this.duration, 1);
              i = t >= 1;
              const n = i ? 1 : this.easing(t);
              this.value = this.from + (this.to - this.from) * n
          } else
              this.lerp ? (this.value = function(e, t, i, n) {
                  return function(e, t, i) {
                      return (1 - i) * e + i * t
                  }(e, t, 1 - Math.exp(-i * n))
              }(this.value, this.to, 60 * this.lerp, e),
              Math.round(this.value) === this.to && (this.value = this.to,
              i = !0)) : (this.value = this.to,
              i = !0);
          i && this.stop(),
          null === (t = this.onUpdate) || void 0 === t || t.call(this, this.value, i)
      }
      stop() {
          this.isRunning = !1
      }
      fromTo(e, t, {lerp: i, duration: n, easing: r, onStart: s, onUpdate: a}) {
          this.from = this.value = e,
          this.to = t,
          this.lerp = i,
          this.duration = n,
          this.easing = r,
          this.currentTime = 0,
          this.isRunning = !0,
          null == s || s(),
          this.onUpdate = a
      }
  }
  class Ao {
      constructor({wrapper: e, content: t, autoResize: i=!0, debounce: n=250}={}) {
          this.width = 0,
          this.height = 0,
          this.scrollWidth = 0,
          this.scrollHeight = 0,
          this.resize = () => {
              this.onWrapperResize(),
              this.onContentResize()
          }
          ,
          this.onWrapperResize = () => {
              this.wrapper === window ? (this.width = window.innerWidth,
              this.height = window.innerHeight) : this.wrapper instanceof HTMLElement && (this.width = this.wrapper.clientWidth,
              this.height = this.wrapper.clientHeight)
          }
          ,
          this.onContentResize = () => {
              this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight,
              this.scrollWidth = this.content.scrollWidth) : this.wrapper instanceof HTMLElement && (this.scrollHeight = this.wrapper.scrollHeight,
              this.scrollWidth = this.wrapper.scrollWidth)
          }
          ,
          this.wrapper = e,
          this.content = t,
          i && (this.debouncedResize = function(e, t) {
              let i;
              return function() {
                  let n = arguments
                    , r = this;
                  clearTimeout(i),
                  i = setTimeout((function() {
                      e.apply(r, n)
                  }
                  ), t)
              }
          }(this.resize, n),
          this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize),
          this.wrapperResizeObserver.observe(this.wrapper)),
          this.contentResizeObserver = new ResizeObserver(this.debouncedResize),
          this.contentResizeObserver.observe(this.content)),
          this.resize()
      }
      destroy() {
          var e, t;
          null === (e = this.wrapperResizeObserver) || void 0 === e || e.disconnect(),
          null === (t = this.contentResizeObserver) || void 0 === t || t.disconnect(),
          window.removeEventListener("resize", this.debouncedResize, !1)
      }
      get limit() {
          return {
              x: this.scrollWidth - this.width,
              y: this.scrollHeight - this.height
          }
      }
  }
  class Po {
      constructor() {
          this.events = {}
      }
      emit(e, ...t) {
          let i = this.events[e] || [];
          for (let e = 0, n = i.length; e < n; e++)
              i[e](...t)
      }
      on(e, t) {
          var i;
          return (null === (i = this.events[e]) || void 0 === i ? void 0 : i.push(t)) || (this.events[e] = [t]),
          () => {
              var i;
              this.events[e] = null === (i = this.events[e]) || void 0 === i ? void 0 : i.filter((e => t !== e))
          }
      }
      off(e, t) {
          var i;
          this.events[e] = null === (i = this.events[e]) || void 0 === i ? void 0 : i.filter((e => t !== e))
      }
      destroy() {
          this.events = {}
      }
  }
  const Ro = 100 / 6;
  class Lo {
      constructor(e, {wheelMultiplier: t=1, touchMultiplier: i=1}) {
          this.lastDelta = {
              x: 0,
              y: 0
          },
          this.windowWidth = 0,
          this.windowHeight = 0,
          this.onTouchStart = e => {
              const {clientX: t, clientY: i} = e.targetTouches ? e.targetTouches[0] : e;
              this.touchStart.x = t,
              this.touchStart.y = i,
              this.lastDelta = {
                  x: 0,
                  y: 0
              },
              this.emitter.emit("scroll", {
                  deltaX: 0,
                  deltaY: 0,
                  event: e
              })
          }
          ,
          this.onTouchMove = e => {
              var t, i, n, r;
              const {clientX: s, clientY: a} = e.targetTouches ? e.targetTouches[0] : e
                , o = -(s - (null !== (i = null === (t = this.touchStart) || void 0 === t ? void 0 : t.x) && void 0 !== i ? i : 0)) * this.touchMultiplier
                , l = -(a - (null !== (r = null === (n = this.touchStart) || void 0 === n ? void 0 : n.y) && void 0 !== r ? r : 0)) * this.touchMultiplier;
              this.touchStart.x = s,
              this.touchStart.y = a,
              this.lastDelta = {
                  x: o,
                  y: l
              },
              this.emitter.emit("scroll", {
                  deltaX: o,
                  deltaY: l,
                  event: e
              })
          }
          ,
          this.onTouchEnd = e => {
              this.emitter.emit("scroll", {
                  deltaX: this.lastDelta.x,
                  deltaY: this.lastDelta.y,
                  event: e
              })
          }
          ,
          this.onWheel = e => {
              let {deltaX: t, deltaY: i, deltaMode: n} = e;
              t *= 1 === n ? Ro : 2 === n ? this.windowWidth : 1,
              i *= 1 === n ? Ro : 2 === n ? this.windowHeight : 1,
              t *= this.wheelMultiplier,
              i *= this.wheelMultiplier,
              this.emitter.emit("scroll", {
                  deltaX: t,
                  deltaY: i,
                  event: e
              })
          }
          ,
          this.onWindowResize = () => {
              this.windowWidth = window.innerWidth,
              this.windowHeight = window.innerHeight
          }
          ,
          this.element = e,
          this.wheelMultiplier = t,
          this.touchMultiplier = i,
          this.touchStart = {
              x: null,
              y: null
          },
          this.emitter = new Po,
          window.addEventListener("resize", this.onWindowResize, !1),
          this.onWindowResize(),
          this.element.addEventListener("wheel", this.onWheel, {
              passive: !1
          }),
          this.element.addEventListener("touchstart", this.onTouchStart, {
              passive: !1
          }),
          this.element.addEventListener("touchmove", this.onTouchMove, {
              passive: !1
          }),
          this.element.addEventListener("touchend", this.onTouchEnd, {
              passive: !1
          })
      }
      on(e, t) {
          return this.emitter.on(e, t)
      }
      destroy() {
          this.emitter.destroy(),
          window.removeEventListener("resize", this.onWindowResize, !1),
          this.element.removeEventListener("wheel", this.onWheel),
          this.element.removeEventListener("touchstart", this.onTouchStart),
          this.element.removeEventListener("touchmove", this.onTouchMove),
          this.element.removeEventListener("touchend", this.onTouchEnd)
      }
  }
  class Io {
      constructor({wrapper: e=window, content: t=document.documentElement, wheelEventsTarget: i=e, eventsTarget: n=i, smoothWheel: r=!0, syncTouch: s=!1, syncTouchLerp: a=.075, touchInertiaMultiplier: o=35, duration: l, easing: c=(e => Math.min(1, 1.001 - Math.pow(2, -10 * e))), lerp: u=.1, infinite: h=!1, orientation: d="vertical", gestureOrientation: p="vertical", touchMultiplier: f=1, wheelMultiplier: m=1, autoResize: g=!0, prevent: v, virtualScroll: _, __experimental__naiveDimensions: y=!1}={}) {
          this.__isScrolling = !1,
          this.__isStopped = !1,
          this.__isLocked = !1,
          this.userData = {},
          this.lastVelocity = 0,
          this.velocity = 0,
          this.direction = 0,
          this.onPointerDown = e => {
              1 === e.button && this.reset()
          }
          ,
          this.onVirtualScroll = e => {
              if ("function" == typeof this.options.virtualScroll && !1 === this.options.virtualScroll(e))
                  return;
              const {deltaX: t, deltaY: i, event: n} = e;
              if (this.emitter.emit("virtual-scroll", {
                  deltaX: t,
                  deltaY: i,
                  event: n
              }),
              n.ctrlKey)
                  return;
              const r = n.type.includes("touch")
                , s = n.type.includes("wheel");
              if (this.isTouching = "touchstart" === n.type || "touchmove" === n.type,
              this.options.syncTouch && r && "touchstart" === n.type && !this.isStopped && !this.isLocked)
                  return void this.reset();
              const a = 0 === t && 0 === i
                , o = "vertical" === this.options.gestureOrientation && 0 === i || "horizontal" === this.options.gestureOrientation && 0 === t;
              if (a || o)
                  return;
              let l = n.composedPath();
              l = l.slice(0, l.indexOf(this.rootElement));
              const c = this.options.prevent;
              if (l.find((e => {
                  var t, i, n, a, o;
                  return e instanceof Element && ("function" == typeof c && (null == c ? void 0 : c(e)) || (null === (t = e.hasAttribute) || void 0 === t ? void 0 : t.call(e, "data-lenis-prevent")) || r && (null === (i = e.hasAttribute) || void 0 === i ? void 0 : i.call(e, "data-lenis-prevent-touch")) || s && (null === (n = e.hasAttribute) || void 0 === n ? void 0 : n.call(e, "data-lenis-prevent-wheel")) || (null === (a = e.classList) || void 0 === a ? void 0 : a.contains("lenis")) && !(null === (o = e.classList) || void 0 === o ? void 0 : o.contains("lenis-stopped")))
              }
              )))
                  return;
              if (this.isStopped || this.isLocked)
                  return void n.preventDefault();
              if (!(this.options.syncTouch && r || this.options.smoothWheel && s))
                  return this.isScrolling = "native",
                  void this.animate.stop();
              n.preventDefault();
              let u = i;
              "both" === this.options.gestureOrientation ? u = Math.abs(i) > Math.abs(t) ? i : t : "horizontal" === this.options.gestureOrientation && (u = t);
              const h = r && this.options.syncTouch
                , d = r && "touchend" === n.type && Math.abs(u) > 5;
              d && (u = this.velocity * this.options.touchInertiaMultiplier),
              this.scrollTo(this.targetScroll + u, Object.assign({
                  programmatic: !1
              }, h ? {
                  lerp: d ? this.options.syncTouchLerp : 1
              } : {
                  lerp: this.options.lerp,
                  duration: this.options.duration,
                  easing: this.options.easing
              }))
          }
          ,
          this.onNativeScroll = () => {
              if (clearTimeout(this.__resetVelocityTimeout),
              delete this.__resetVelocityTimeout,
              this.__preventNextNativeScrollEvent)
                  delete this.__preventNextNativeScrollEvent;
              else if (!1 === this.isScrolling || "native" === this.isScrolling) {
                  const e = this.animatedScroll;
                  this.animatedScroll = this.targetScroll = this.actualScroll,
                  this.lastVelocity = this.velocity,
                  this.velocity = this.animatedScroll - e,
                  this.direction = Math.sign(this.animatedScroll - e),
                  this.isScrolling = "native",
                  this.emit(),
                  0 !== this.velocity && (this.__resetVelocityTimeout = setTimeout(( () => {
                      this.lastVelocity = this.velocity,
                      this.velocity = 0,
                      this.isScrolling = !1,
                      this.emit()
                  }
                  ), 400))
              }
          }
          ,
          window.lenisVersion = "1.1.9",
          e && e !== document.documentElement && e !== document.body || (e = window),
          this.options = {
              wrapper: e,
              content: t,
              wheelEventsTarget: i,
              eventsTarget: n,
              smoothWheel: r,
              syncTouch: s,
              syncTouchLerp: a,
              touchInertiaMultiplier: o,
              duration: l,
              easing: c,
              lerp: u,
              infinite: h,
              gestureOrientation: p,
              orientation: d,
              touchMultiplier: f,
              wheelMultiplier: m,
              autoResize: g,
              prevent: v,
              virtualScroll: _,
              __experimental__naiveDimensions: y
          },
          this.animate = new Co,
          this.emitter = new Po,
          this.dimensions = new Ao({
              wrapper: e,
              content: t,
              autoResize: g
          }),
          this.updateClassName(),
          this.userData = {},
          this.time = 0,
          this.velocity = this.lastVelocity = 0,
          this.isLocked = !1,
          this.isStopped = !1,
          this.isScrolling = !1,
          this.targetScroll = this.animatedScroll = this.actualScroll,
          this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
          this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1),
          this.virtualScroll = new Lo(n,{
              touchMultiplier: f,
              wheelMultiplier: m
          }),
          this.virtualScroll.on("scroll", this.onVirtualScroll)
      }
      destroy() {
          this.emitter.destroy(),
          this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1),
          this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1),
          this.virtualScroll.destroy(),
          this.dimensions.destroy(),
          this.cleanUpClassName()
      }
      on(e, t) {
          return this.emitter.on(e, t)
      }
      off(e, t) {
          return this.emitter.off(e, t)
      }
      setScroll(e) {
          this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
      }
      resize() {
          this.dimensions.resize()
      }
      emit() {
          this.emitter.emit("scroll", this)
      }
      reset() {
          this.isLocked = !1,
          this.isScrolling = !1,
          this.animatedScroll = this.targetScroll = this.actualScroll,
          this.lastVelocity = this.velocity = 0,
          this.animate.stop()
      }
      start() {
          this.isStopped && (this.isStopped = !1,
          this.reset())
      }
      stop() {
          this.isStopped || (this.isStopped = !0,
          this.animate.stop(),
          this.reset())
      }
      raf(e) {
          const t = e - (this.time || e);
          this.time = e,
          this.animate.advance(.001 * t)
      }
      scrollTo(e, {offset: t=0, immediate: i=!1, lock: n=!1, duration: r=this.options.duration, easing: s=this.options.easing, lerp: a=this.options.lerp, onStart: o, onComplete: l, force: c=!1, programmatic: u=!0, userData: h={}}={}) {
          if (!this.isStopped && !this.isLocked || c) {
              if ("string" == typeof e && ["top", "left", "start"].includes(e))
                  e = 0;
              else if ("string" == typeof e && ["bottom", "right", "end"].includes(e))
                  e = this.limit;
              else {
                  let i;
                  if ("string" == typeof e ? i = document.querySelector(e) : e instanceof HTMLElement && (null == e ? void 0 : e.nodeType) && (i = e),
                  i) {
                      if (this.options.wrapper !== window) {
                          const e = this.rootElement.getBoundingClientRect();
                          t -= this.isHorizontal ? e.left : e.top
                      }
                      const n = i.getBoundingClientRect();
                      e = (this.isHorizontal ? n.left : n.top) + this.animatedScroll
                  }
              }
              if ("number" == typeof e && (e += t,
              e = Math.round(e),
              this.options.infinite ? u && (this.targetScroll = this.animatedScroll = this.scroll) : e = Do(0, e, this.limit),
              e !== this.targetScroll)) {
                  if (this.userData = h,
                  i)
                      return this.animatedScroll = this.targetScroll = e,
                      this.setScroll(this.scroll),
                      this.reset(),
                      this.preventNextNativeScrollEvent(),
                      this.emit(),
                      null == l || l(this),
                      void (this.userData = {});
                  u || (this.targetScroll = e),
                  this.animate.fromTo(this.animatedScroll, e, {
                      duration: r,
                      easing: s,
                      lerp: a,
                      onStart: () => {
                          n && (this.isLocked = !0),
                          this.isScrolling = "smooth",
                          null == o || o(this)
                      }
                      ,
                      onUpdate: (e, t) => {
                          this.isScrolling = "smooth",
                          this.lastVelocity = this.velocity,
                          this.velocity = e - this.animatedScroll,
                          this.direction = Math.sign(this.velocity),
                          this.animatedScroll = e,
                          this.setScroll(this.scroll),
                          u && (this.targetScroll = e),
                          t || this.emit(),
                          t && (this.reset(),
                          this.emit(),
                          null == l || l(this),
                          this.userData = {},
                          this.preventNextNativeScrollEvent())
                      }
                  })
              }
          }
      }
      preventNextNativeScrollEvent() {
          this.__preventNextNativeScrollEvent = !0,
          requestAnimationFrame(( () => {
              delete this.__preventNextNativeScrollEvent
          }
          ))
      }
      get rootElement() {
          return this.options.wrapper === window ? document.documentElement : this.options.wrapper
      }
      get limit() {
          return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
      }
      get isHorizontal() {
          return "horizontal" === this.options.orientation
      }
      get actualScroll() {
          return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
      }
      get scroll() {
          return this.options.infinite ? function(e, t) {
              return (e % t + t) % t
          }(this.animatedScroll, this.limit) : this.animatedScroll
      }
      get progress() {
          return 0 === this.limit ? 1 : this.scroll / this.limit
      }
      get isScrolling() {
          return this.__isScrolling
      }
      set isScrolling(e) {
          this.__isScrolling !== e && (this.__isScrolling = e,
          this.updateClassName())
      }
      get isStopped() {
          return this.__isStopped
      }
      set isStopped(e) {
          this.__isStopped !== e && (this.__isStopped = e,
          this.updateClassName())
      }
      get isLocked() {
          return this.__isLocked
      }
      set isLocked(e) {
          this.__isLocked !== e && (this.__isLocked = e,
          this.updateClassName())
      }
      get isSmooth() {
          return "smooth" === this.isScrolling
      }
      get className() {
          let e = "lenis";
          return this.isStopped && (e += " lenis-stopped"),
          this.isLocked && (e += " lenis-locked"),
          this.isScrolling && (e += " lenis-scrolling"),
          "smooth" === this.isScrolling && (e += " lenis-smooth"),
          e
      }
      updateClassName() {
          this.cleanUpClassName(),
          this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
      }
      cleanUpClassName() {
          this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
      }
  }
  function No() {
      return No = Object.assign ? Object.assign.bind() : function(e) {
          for (var t = 1; t < arguments.length; t++) {
              var i = arguments[t];
              for (var n in i)
                  Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
          }
          return e
      }
      ,
      No.apply(this, arguments)
  }
  history.scrollRestoration = "manual",
  jn.registerPlugin(Qa, wo);
  var Fo = function() {
      function e(t) {
          void 0 === t && (t = {}),
          this.options = Object.assign({}, {
              el: null,
              container: document.body,
              className: "mf-cursor",
              innerClassName: "mf-cursor-inner",
              textClassName: "mf-cursor-text",
              mediaClassName: "mf-cursor-media",
              mediaBoxClassName: "mf-cursor-media-box",
              iconSvgClassName: "mf-svgsprite",
              iconSvgNamePrefix: "-",
              iconSvgSrc: "",
              dataAttr: "cursor",
              hiddenState: "-hidden",
              textState: "-text",
              iconState: "-icon",
              activeState: "-active",
              mediaState: "-media",
              stateDetection: {
                  "-pointer": "a,button"
              },
              visible: !0,
              visibleOnState: !1,
              speed: .55,
              ease: "expo.out",
              overwrite: !0,
              skewing: 0,
              skewingText: 2,
              skewingIcon: 2,
              skewingMedia: 2,
              skewingDelta: .001,
              skewingDeltaMax: .15,
              stickDelta: .15,
              showTimeout: 0,
              hideOnLeave: !0,
              hideTimeout: 300,
              hideMediaTimeout: 300,
              initialPos: [-window.innerWidth, -window.innerHeight]
          }, t),
          this.options.visible && null == t.stateDetection && (this.options.stateDetection["-hidden"] = "iframe"),
          this.gsap = e.gsap || window.gsap,
          this.el = "string" == typeof this.options.el ? document.querySelector(this.options.el) : this.options.el,
          this.container = "string" == typeof this.options.container ? document.querySelector(this.options.container) : this.options.container,
          this.skewing = this.options.skewing,
          this.pos = {
              x: this.options.initialPos[0],
              y: this.options.initialPos[1]
          },
          this.vel = {
              x: 0,
              y: 0
          },
          this.event = {},
          this.events = [],
          this.init()
      }
      e.registerGSAP = function(t) {
          e.gsap = t
      }
      ;
      var t = e.prototype;
      return t.init = function() {
          this.el || this.create(),
          this.createSetter(),
          this.bind(),
          this.render(!0),
          this.ticker = this.render.bind(this, !1),
          this.gsap.ticker.add(this.ticker)
      }
      ,
      t.create = function() {
          this.el = document.createElement("div"),
          this.el.className = this.options.className,
          this.el.classList.add(this.options.hiddenState),
          this.inner = document.createElement("div"),
          this.inner.className = this.options.innerClassName,
          this.text = document.createElement("div"),
          this.text.className = this.options.textClassName,
          this.media = document.createElement("div"),
          this.media.className = this.options.mediaClassName,
          this.mediaBox = document.createElement("div"),
          this.mediaBox.className = this.options.mediaBoxClassName,
          this.media.appendChild(this.mediaBox),
          this.inner.appendChild(this.media),
          this.inner.appendChild(this.text),
          this.el.appendChild(this.inner),
          this.container.appendChild(this.el)
      }
      ,
      t.createSetter = function() {
          this.setter = {
              x: this.gsap.quickSetter(this.el, "x", "px"),
              y: this.gsap.quickSetter(this.el, "y", "px"),
              rotation: this.gsap.quickSetter(this.el, "rotation", "deg"),
              scaleX: this.gsap.quickSetter(this.el, "scaleX"),
              scaleY: this.gsap.quickSetter(this.el, "scaleY"),
              wc: this.gsap.quickSetter(this.el, "willChange"),
              inner: {
                  rotation: this.gsap.quickSetter(this.inner, "rotation", "deg")
              }
          }
      }
      ,
      t.bind = function() {
          var e = this;
          this.event.mouseleave = function() {
              return e.hide()
          }
          ,
          this.event.mouseenter = function() {
              return e.show()
          }
          ,
          this.event.mousedown = function() {
              return e.addState(e.options.activeState)
          }
          ,
          this.event.mouseup = function() {
              return e.removeState(e.options.activeState)
          }
          ,
          this.event.mousemoveOnce = function() {
              return e.show()
          }
          ,
          this.event.mousemove = function(t) {
              e.gsap.to(e.pos, {
                  x: e.stick ? e.stick.x - (e.stick.x - t.clientX) * e.options.stickDelta : t.clientX,
                  y: e.stick ? e.stick.y - (e.stick.y - t.clientY) * e.options.stickDelta : t.clientY,
                  overwrite: e.options.overwrite,
                  ease: e.options.ease,
                  duration: e.visible ? e.options.speed : 0,
                  onUpdate: function() {
                      return e.vel = {
                          x: t.clientX - e.pos.x,
                          y: t.clientY - e.pos.y
                      }
                  }
              })
          }
          ,
          this.event.mouseover = function(t) {
              for (var i = t.target; i && i !== e.container && (!t.relatedTarget || !i.contains(t.relatedTarget)); i = i.parentNode) {
                  for (var n in e.options.stateDetection)
                      i.matches(e.options.stateDetection[n]) && e.addState(n);
                  if (e.options.dataAttr) {
                      var r = e.getFromDataset(i);
                      r.state && e.addState(r.state),
                      r.text && e.setText(r.text),
                      r.icon && e.setIcon(r.icon),
                      r.img && e.setImg(r.img),
                      r.video && e.setVideo(r.video),
                      void 0 !== r.show && e.show(),
                      void 0 !== r.stick && e.setStick(r.stick || i)
                  }
              }
          }
          ,
          this.event.mouseout = function(t) {
              for (var i = t.target; i && i !== e.container && (!t.relatedTarget || !i.contains(t.relatedTarget)); i = i.parentNode) {
                  for (var n in e.options.stateDetection)
                      i.matches(e.options.stateDetection[n]) && e.removeState(n);
                  if (e.options.dataAttr) {
                      var r = e.getFromDataset(i);
                      r.state && e.removeState(r.state),
                      r.text && e.removeText(),
                      r.icon && e.removeIcon(),
                      r.img && e.removeImg(),
                      r.video && e.removeVideo(),
                      void 0 !== r.show && e.hide(),
                      void 0 !== r.stick && e.removeStick()
                  }
              }
          }
          ,
          this.options.hideOnLeave && this.container.addEventListener("mouseleave", this.event.mouseleave, {
              passive: !0
          }),
          this.options.visible && this.container.addEventListener("mouseenter", this.event.mouseenter, {
              passive: !0
          }),
          this.options.activeState && (this.container.addEventListener("mousedown", this.event.mousedown, {
              passive: !0
          }),
          this.container.addEventListener("mouseup", this.event.mouseup, {
              passive: !0
          })),
          this.container.addEventListener("mousemove", this.event.mousemove, {
              passive: !0
          }),
          this.options.visible && this.container.addEventListener("mousemove", this.event.mousemoveOnce, {
              passive: !0,
              once: !0
          }),
          (this.options.stateDetection || this.options.dataAttr) && (this.container.addEventListener("mouseover", this.event.mouseover, {
              passive: !0
          }),
          this.container.addEventListener("mouseout", this.event.mouseout, {
              passive: !0
          }))
      }
      ,
      t.render = function(e) {
          if (!0 === e || 0 !== this.vel.y && 0 !== this.vel.x) {
              if (this.trigger("render"),
              this.setter.wc("transform"),
              this.setter.x(this.pos.x),
              this.setter.y(this.pos.y),
              this.skewing) {
                  var t = Math.sqrt(Math.pow(this.vel.x, 2) + Math.pow(this.vel.y, 2))
                    , i = Math.min(t * this.options.skewingDelta, this.options.skewingDeltaMax) * this.skewing
                    , n = 180 * Math.atan2(this.vel.y, this.vel.x) / Math.PI;
                  this.setter.rotation(n),
                  this.setter.scaleX(1 + i),
                  this.setter.scaleY(1 - i),
                  this.setter.inner.rotation(-n)
              }
          } else
              this.setter.wc("auto")
      }
      ,
      t.show = function() {
          var e = this;
          this.trigger("show"),
          clearInterval(this.visibleInt),
          this.visibleInt = setTimeout((function() {
              e.el.classList.remove(e.options.hiddenState),
              e.visible = !0,
              e.render(!0)
          }
          ), this.options.showTimeout)
      }
      ,
      t.hide = function() {
          var e = this;
          this.trigger("hide"),
          clearInterval(this.visibleInt),
          this.el.classList.add(this.options.hiddenState),
          this.visibleInt = setTimeout((function() {
              return e.visible = !1
          }
          ), this.options.hideTimeout)
      }
      ,
      t.toggle = function(e) {
          !0 === e || !1 !== e && !this.visible ? this.show() : this.hide()
      }
      ,
      t.addState = function(e) {
          var t;
          if (this.trigger("addState", e),
          e === this.options.hiddenState)
              return this.hide();
          (t = this.el.classList).add.apply(t, e.split(" ")),
          this.options.visibleOnState && this.show()
      }
      ,
      t.removeState = function(e) {
          var t;
          if (this.trigger("removeState", e),
          e === this.options.hiddenState)
              return this.show();
          (t = this.el.classList).remove.apply(t, e.split(" ")),
          this.options.visibleOnState && this.el.className === this.options.className && this.hide()
      }
      ,
      t.toggleState = function(e, t) {
          !0 === t || !1 !== t && !this.el.classList.contains(e) ? this.addState(e) : this.removeState(e)
      }
      ,
      t.setSkewing = function(e) {
          this.gsap.to(this, {
              skewing: e
          })
      }
      ,
      t.removeSkewing = function() {
          this.gsap.to(this, {
              skewing: this.options.skewing
          })
      }
      ,
      t.setStick = function(e) {
          var t = ("string" == typeof e ? document.querySelector(e) : e).getBoundingClientRect();
          this.stick = {
              y: t.top + t.height / 2,
              x: t.left + t.width / 2
          }
      }
      ,
      t.removeStick = function() {
          this.stick = !1
      }
      ,
      t.setText = function(e) {
          this.text.innerHTML = e,
          this.addState(this.options.textState),
          this.setSkewing(this.options.skewingText)
      }
      ,
      t.removeText = function() {
          this.removeState(this.options.textState),
          this.removeSkewing()
      }
      ,
      t.setIcon = function(e, t) {
          void 0 === t && (t = ""),
          this.text.innerHTML = "<svg class='" + this.options.iconSvgClassName + " " + this.options.iconSvgNamePrefix + e + "' style='" + t + "'><use xlink:href='" + this.options.iconSvgSrc + "#" + e + "'></use></svg>",
          this.addState(this.options.iconState),
          this.setSkewing(this.options.skewingIcon)
      }
      ,
      t.removeIcon = function() {
          this.removeState(this.options.iconState),
          this.removeSkewing()
      }
      ,
      t.setMedia = function(e) {
          var t = this;
          clearTimeout(this.mediaInt),
          e && (this.mediaBox.innerHTML = "",
          this.mediaBox.appendChild(e)),
          this.mediaInt = setTimeout((function() {
              return t.addState(t.options.mediaState)
          }
          ), 20),
          this.setSkewing(this.options.skewingMedia)
      }
      ,
      t.removeMedia = function() {
          var e = this;
          clearTimeout(this.mediaInt),
          this.removeState(this.options.mediaState),
          this.mediaInt = setTimeout((function() {
              return e.mediaBox.innerHTML = ""
          }
          ), this.options.hideMediaTimeout),
          this.removeSkewing()
      }
      ,
      t.setImg = function(e) {
          this.mediaImg || (this.mediaImg = new Image),
          this.mediaImg.src !== e && (this.mediaImg.src = e),
          this.setMedia(this.mediaImg)
      }
      ,
      t.removeImg = function() {
          this.removeMedia()
      }
      ,
      t.setVideo = function(e) {
          this.mediaVideo || (this.mediaVideo = document.createElement("video"),
          this.mediaVideo.muted = !0,
          this.mediaVideo.loop = !0,
          this.mediaVideo.autoplay = !0),
          this.mediaVideo.src !== e && (this.mediaVideo.src = e,
          this.mediaVideo.load()),
          this.mediaVideo.play(),
          this.setMedia(this.mediaVideo)
      }
      ,
      t.removeVideo = function() {
          this.mediaVideo && this.mediaVideo.readyState > 2 && this.mediaVideo.pause(),
          this.removeMedia()
      }
      ,
      t.on = function(e, t) {
          this.events[e]instanceof Array || this.off(e),
          this.events[e].push(t)
      }
      ,
      t.off = function(e, t) {
          this.events[e] = t ? this.events[e].filter((function(e) {
              return e !== t
          }
          )) : []
      }
      ,
      t.trigger = function(e) {
          var t = arguments
            , i = this;
          this.events[e] && this.events[e].forEach((function(e) {
              return e.call.apply(e, [i, i].concat([].slice.call(t, 1)))
          }
          ))
      }
      ,
      t.getFromDataset = function(e) {
          var t = e.dataset;
          return {
              state: t[this.options.dataAttr],
              show: t[this.options.dataAttr + "Show"],
              text: t[this.options.dataAttr + "Text"],
              icon: t[this.options.dataAttr + "Icon"],
              img: t[this.options.dataAttr + "Img"],
              video: t[this.options.dataAttr + "Video"],
              stick: t[this.options.dataAttr + "Stick"]
          }
      }
      ,
      t.destroy = function() {
          this.trigger("destroy"),
          this.gsap.ticker.remove(this.ticker),
          this.container.removeEventListener("mouseleave", this.event.mouseleave),
          this.container.removeEventListener("mouseenter", this.event.mouseenter),
          this.container.removeEventListener("mousedown", this.event.mousedown),
          this.container.removeEventListener("mouseup", this.event.mouseup),
          this.container.removeEventListener("mousemove", this.event.mousemove),
          this.container.removeEventListener("mousemove", this.event.mousemoveOnce),
          this.container.removeEventListener("mouseover", this.event.mouseover),
          this.container.removeEventListener("mouseout", this.event.mouseout),
          this.el && (this.container.removeChild(this.el),
          this.el = null,
          this.mediaImg = null,
          this.mediaVideo = null)
      }
      ,
      e
  }();
  Fo.registerGSAP(jn);
  var Oo = function(e) {
      var t = typeof e;
      return null != e && ("object" == t || "function" == t)
  }
    , Uo = "object" == typeof global && global && global.Object === Object && global
    , Bo = "object" == typeof self && self && self.Object === Object && self
    , zo = Uo || Bo || Function("return this")()
    , ko = function() {
      return zo.Date.now()
  }
    , Vo = /\s/
    , Ho = /^\s+/
    , Go = function(e) {
      return e ? e.slice(0, function(e) {
          for (var t = e.length; t-- && Vo.test(e.charAt(t)); )
              ;
          return t
      }(e) + 1).replace(Ho, "") : e
  }
    , Wo = zo.Symbol
    , Xo = Object.prototype
    , qo = Xo.hasOwnProperty
    , jo = Xo.toString
    , Yo = Wo ? Wo.toStringTag : void 0
    , Ko = Object.prototype.toString
    , Zo = Wo ? Wo.toStringTag : void 0
    , $o = function(e) {
      return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Zo && Zo in Object(e) ? function(e) {
          var t = qo.call(e, Yo)
            , i = e[Yo];
          try {
              e[Yo] = void 0;
              var n = !0
          } catch (e) {}
          var r = jo.call(e);
          return n && (t ? e[Yo] = i : delete e[Yo]),
          r
      }(e) : function(e) {
          return Ko.call(e)
      }(e)
  }
    , Jo = /^[-+]0x[0-9a-f]+$/i
    , Qo = /^0b[01]+$/i
    , el = /^0o[0-7]+$/i
    , tl = parseInt
    , il = function(e) {
      if ("number" == typeof e)
          return e;
      if (function(e) {
          return "symbol" == typeof e || function(e) {
              return null != e && "object" == typeof e
          }(e) && "[object Symbol]" == $o(e)
      }(e))
          return NaN;
      if (Oo(e)) {
          var t = "function" == typeof e.valueOf ? e.valueOf() : e;
          e = Oo(t) ? t + "" : t
      }
      if ("string" != typeof e)
          return 0 === e ? e : +e;
      e = Go(e);
      var i = Qo.test(e);
      return i || el.test(e) ? tl(e.slice(2), i ? 2 : 8) : Jo.test(e) ? NaN : +e
  }
    , nl = Math.max
    , rl = Math.min
    , sl = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
  function al(e) {
      var t = e.nodeType
        , i = "";
      if (1 === t || 9 === t || 11 === t) {
          if ("string" == typeof e.textContent)
              return e.textContent;
          for (e = e.firstChild; e; e = e.nextSibling)
              i += al(e)
      } else if (3 === t || 4 === t)
          return e.nodeValue;
      return i
  }
  var ol, ll, cl, ul = /(?:\r|\n|\t\t)/g, hl = /(?:\s\s+)/g, dl = function(e) {
      return ll.getComputedStyle(e)
  }, pl = Array.isArray, fl = [].slice, ml = function(e, t) {
      var i;
      return pl(e) ? e : "string" == (i = typeof e) && !t && e ? fl.call(ol.querySelectorAll(e), 0) : e && "object" === i && "length"in e ? fl.call(e, 0) : e ? [e] : []
  }, gl = function(e) {
      return "absolute" === e.position || !0 === e.absolute
  }, vl = function(e, t) {
      for (var i, n = t.length; --n > -1; )
          if (i = t[n],
          e.substr(0, i.length) === i)
              return i.length
  }, _l = function(e, t) {
      void 0 === e && (e = "");
      var i = ~e.indexOf("++")
        , n = 1;
      return i && (e = e.split("++").join("")),
      function() {
          return "<" + t + " style='position:relative;display:inline-block;'" + (e ? " class='" + e + (i ? n++ : "") + "'>" : ">")
      }
  }, yl = function e(t, i, n) {
      var r = t.nodeType;
      if (1 === r || 9 === r || 11 === r)
          for (t = t.firstChild; t; t = t.nextSibling)
              e(t, i, n);
      else
          3 !== r && 4 !== r || (t.nodeValue = t.nodeValue.split(i).join(n))
  }, xl = function(e, t) {
      for (var i = t.length; --i > -1; )
          e.push(t[i])
  }, Sl = function(e, t, i) {
      for (var n; e && e !== t; ) {
          if (n = e._next || e.nextSibling)
              return n.textContent.charAt(0) === i;
          e = e.parentNode || e._parent
      }
  }, El = function e(t) {
      var i, n, r = ml(t.childNodes), s = r.length;
      for (i = 0; i < s; i++)
          (n = r[i])._isSplit ? e(n) : i && n.previousSibling && 3 === n.previousSibling.nodeType ? (n.previousSibling.nodeValue += 3 === n.nodeType ? n.nodeValue : n.firstChild.nodeValue,
          t.removeChild(n)) : 3 !== n.nodeType && (t.insertBefore(n.firstChild, n),
          t.removeChild(n))
  }, Ml = function(e, t) {
      return parseFloat(t[e]) || 0
  }, bl = function(e, t, i, n, r, s, a) {
      var o, l, c, u, h, d, p, f, m, g, v, _, y = dl(e), x = Ml("paddingLeft", y), S = -999, E = Ml("borderBottomWidth", y) + Ml("borderTopWidth", y), M = Ml("borderLeftWidth", y) + Ml("borderRightWidth", y), b = Ml("paddingTop", y) + Ml("paddingBottom", y), T = Ml("paddingLeft", y) + Ml("paddingRight", y), w = Ml("fontSize", y) * (t.lineThreshold || .2), D = y.textAlign, C = [], A = [], P = [], R = t.wordDelimiter || " ", L = t.tag ? t.tag : t.span ? "span" : "div", I = t.type || t.split || "chars,words,lines", N = r && ~I.indexOf("lines") ? [] : null, F = ~I.indexOf("words"), O = ~I.indexOf("chars"), U = gl(t), B = t.linesClass, z = ~(B || "").indexOf("++"), k = [], V = "flex" === y.display, H = e.style.display;
      for (z && (B = B.split("++").join("")),
      V && (e.style.display = "block"),
      c = (l = e.getElementsByTagName("*")).length,
      h = [],
      o = 0; o < c; o++)
          h[o] = l[o];
      if (N || U)
          for (o = 0; o < c; o++)
              ((d = (u = h[o]).parentNode === e) || U || O && !F) && (_ = u.offsetTop,
              N && d && Math.abs(_ - S) > w && ("BR" !== u.nodeName || 0 === o) && (p = [],
              N.push(p),
              S = _),
              U && (u._x = u.offsetLeft,
              u._y = _,
              u._w = u.offsetWidth,
              u._h = u.offsetHeight),
              N && ((u._isSplit && d || !O && d || F && d || !F && u.parentNode.parentNode === e && !u.parentNode._isSplit) && (p.push(u),
              u._x -= x,
              Sl(u, e, R) && (u._wordEnd = !0)),
              "BR" === u.nodeName && (u.nextSibling && "BR" === u.nextSibling.nodeName || 0 === o) && N.push([])));
      for (o = 0; o < c; o++)
          if (d = (u = h[o]).parentNode === e,
          "BR" !== u.nodeName)
              if (U && (m = u.style,
              F || d || (u._x += u.parentNode._x,
              u._y += u.parentNode._y),
              m.left = u._x + "px",
              m.top = u._y + "px",
              m.position = "absolute",
              m.display = "block",
              m.width = u._w + 1 + "px",
              m.height = u._h + "px"),
              !F && O)
                  if (u._isSplit)
                      for (u._next = l = u.nextSibling,
                      u.parentNode.appendChild(u); l && 3 === l.nodeType && " " === l.textContent; )
                          u._next = l.nextSibling,
                          u.parentNode.appendChild(l),
                          l = l.nextSibling;
                  else
                      u.parentNode._isSplit ? (u._parent = u.parentNode,
                      !u.previousSibling && u.firstChild && (u.firstChild._isFirst = !0),
                      u.nextSibling && " " === u.nextSibling.textContent && !u.nextSibling.nextSibling && k.push(u.nextSibling),
                      u._next = u.nextSibling && u.nextSibling._isFirst ? null : u.nextSibling,
                      u.parentNode.removeChild(u),
                      h.splice(o--, 1),
                      c--) : d || (_ = !u.nextSibling && Sl(u.parentNode, e, R),
                      u.parentNode._parent && u.parentNode._parent.appendChild(u),
                      _ && u.parentNode.appendChild(ol.createTextNode(" ")),
                      "span" === L && (u.style.display = "inline"),
                      C.push(u));
              else
                  u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML ? A.push(u) : O && !u._isSplit && ("span" === L && (u.style.display = "inline"),
                  C.push(u));
          else
              N || U ? (u.parentNode && u.parentNode.removeChild(u),
              h.splice(o--, 1),
              c--) : F || e.appendChild(u);
      for (o = k.length; --o > -1; )
          k[o].parentNode.removeChild(k[o]);
      if (N) {
          for (U && (g = ol.createElement(L),
          e.appendChild(g),
          v = g.offsetWidth + "px",
          _ = g.offsetParent === e ? 0 : e.offsetLeft,
          e.removeChild(g)),
          m = e.style.cssText,
          e.style.cssText = "display:none;"; e.firstChild; )
              e.removeChild(e.firstChild);
          for (f = " " === R && (!U || !F && !O),
          o = 0; o < N.length; o++) {
              for (p = N[o],
              (g = ol.createElement(L)).style.cssText = "display:block;text-align:" + D + ";position:" + (U ? "absolute;" : "relative;"),
              B && (g.className = B + (z ? o + 1 : "")),
              P.push(g),
              c = p.length,
              l = 0; l < c; l++)
                  "BR" !== p[l].nodeName && (u = p[l],
                  g.appendChild(u),
                  f && u._wordEnd && g.appendChild(ol.createTextNode(" ")),
                  U && (0 === l && (g.style.top = u._y + "px",
                  g.style.left = x + _ + "px"),
                  u.style.top = "0px",
                  _ && (u.style.left = u._x - _ + "px")));
              0 === c ? g.innerHTML = "&nbsp;" : F || O || (El(g),
              yl(g, String.fromCharCode(160), " ")),
              U && (g.style.width = v,
              g.style.height = u._h + "px"),
              e.appendChild(g)
          }
          e.style.cssText = m
      }
      U && (a > e.clientHeight && (e.style.height = a - b + "px",
      e.clientHeight < a && (e.style.height = a + E + "px")),
      s > e.clientWidth && (e.style.width = s - T + "px",
      e.clientWidth < s && (e.style.width = s + M + "px"))),
      V && (H ? e.style.display = H : e.style.removeProperty("display")),
      xl(i, C),
      F && xl(n, A),
      xl(r, P)
  }, Tl = function(e, t, i, n) {
      var r, s, a, o, l, c, u, h, d = t.tag ? t.tag : t.span ? "span" : "div", p = ~(t.type || t.split || "chars,words,lines").indexOf("chars"), f = gl(t), m = t.wordDelimiter || " ", g = " " !== m ? "" : f ? "&#173; " : " ", v = "</" + d + ">", _ = 1, y = t.specialChars ? "function" == typeof t.specialChars ? t.specialChars : vl : null, x = ol.createElement("div"), S = e.parentNode;
      for (S.insertBefore(x, e),
      x.textContent = e.nodeValue,
      S.removeChild(e),
      u = -1 !== (r = al(e = x)).indexOf("<"),
      !1 !== t.reduceWhiteSpace && (r = r.replace(hl, " ").replace(ul, "")),
      u && (r = r.split("<").join("{{LT}}")),
      l = r.length,
      s = (" " === r.charAt(0) ? g : "") + i(),
      a = 0; a < l; a++)
          if (c = r.charAt(a),
          y && (h = y(r.substr(a), t.specialChars)))
              c = r.substr(a, h || 1),
              s += p && " " !== c ? n() + c + "</" + d + ">" : c,
              a += h - 1;
          else if (c === m && r.charAt(a - 1) !== m && a) {
              for (s += _ ? v : "",
              _ = 0; r.charAt(a + 1) === m; )
                  s += g,
                  a++;
              a === l - 1 ? s += g : ")" !== r.charAt(a + 1) && (s += g + i(),
              _ = 1)
          } else
              "{" === c && "{{LT}}" === r.substr(a, 6) ? (s += p ? n() + "{{LT}}</" + d + ">" : "{{LT}}",
              a += 5) : c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319 || r.charCodeAt(a + 1) >= 65024 && r.charCodeAt(a + 1) <= 65039 ? (o = ((r.substr(a, 12).split(sl) || [])[1] || "").length || 2,
              s += p && " " !== c ? n() + r.substr(a, o) + "</" + d + ">" : r.substr(a, o),
              a += o - 1) : s += p && " " !== c ? n() + c + "</" + d + ">" : c;
      e.outerHTML = s + (_ ? v : ""),
      u && yl(S, "{{LT}}", "<")
  }, wl = function e(t, i, n, r) {
      var s, a, o = ml(t.childNodes), l = o.length, c = gl(i);
      if (3 !== t.nodeType || l > 1) {
          for (i.absolute = !1,
          s = 0; s < l; s++)
              (a = o[s])._next = a._isFirst = a._parent = a._wordEnd = null,
              (3 !== a.nodeType || /\S+/.test(a.nodeValue)) && (c && 3 !== a.nodeType && "inline" === dl(a).display && (a.style.display = "inline-block",
              a.style.position = "relative"),
              a._isSplit = !0,
              e(a, i, n, r));
          return i.absolute = c,
          void (t._isSplit = !0)
      }
      Tl(t, i, n, r)
  }, Dl = function() {
      function e(e, t) {
          cl || (ol = document,
          ll = window,
          cl = 1),
          this.elements = ml(e),
          this.chars = [],
          this.words = [],
          this.lines = [],
          this._originals = [],
          this.vars = t || {},
          this.split(t)
      }
      var t = e.prototype;
      return t.split = function(e) {
          this.isSplit && this.revert(),
          this.vars = e = e || this.vars,
          this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
          for (var t, i, n, r = this.elements.length, s = e.tag ? e.tag : e.span ? "span" : "div", a = _l(e.wordsClass, s), o = _l(e.charsClass, s); --r > -1; )
              n = this.elements[r],
              this._originals[r] = n.innerHTML,
              t = n.clientHeight,
              i = n.clientWidth,
              wl(n, e, a, o),
              bl(n, e, this.chars, this.words, this.lines, i, t);
          return this.chars.reverse(),
          this.words.reverse(),
          this.lines.reverse(),
          this.isSplit = !0,
          this
      }
      ,
      t.revert = function() {
          var e = this._originals;
          if (!e)
              throw "revert() call wasn't scoped properly.";
          return this.elements.forEach((function(t, i) {
              return t.innerHTML = e[i]
          }
          )),
          this.chars = [],
          this.words = [],
          this.lines = [],
          this.isSplit = !1,
          this
      }
      ,
      e.create = function(t, i) {
          return new e(t,i)
      }
      ,
      e
  }();
  function Cl() {
      return Cl = Object.assign ? Object.assign.bind() : function(e) {
          for (var t = 1; t < arguments.length; t++) {
              var i = arguments[t];
              for (var n in i)
                  Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
          }
          return e
      }
      ,
      Cl.apply(this, arguments)
  }
  Dl.version = "3.11.1";
  const Al = (e, t) => {
      const i = Cl({
          box: e,
          xDelta: .1,
          yDelta: .1,
          moveSpeed: .3,
          leaveSpeed: .3,
          moveEase: "power1.out",
          leaveEase: "power1.out",
          overwrite: !0
      }, t);
      let n;
      const r = (t, n, r) => {
          jn.to(e, Cl({
              x: t,
              y: n,
              overwrite: i.overwrite,
              onStart: () => jn.set(e, {
                  willChange: "transform"
              }),
              onComplete: () => jn.set(e, {
                  willChange: "auto"
              })
          }, r))
      }
      ;
      i.box.addEventListener("mouseenter", ( () => {
          n = e.getBoundingClientRect()
      }
      )),
      i.box.addEventListener("mousemove", (e => {
          const t = (e.clientY - n.top - n.height / 2) * i.yDelta
            , s = (e.clientX - n.left - n.width / 2) * i.xDelta;
          r(s, t, {
              duration: i.moveSpeed,
              ease: i.moveEase
          })
      }
      )),
      i.box.addEventListener("mouseleave", ( () => {
          r(0, 0, {
              duration: i.leaveSpeed,
              ease: i.leaveEase
          })
      }
      ))
  }
    , Pl = function(e, t) {
      void 0 === t && (t = {});
      const i = Cl({
          type: "words",
          duration: 1.7,
          stagger: {
              amount: .6
          },
          ease: "expo.out"
      }, t)
        , n = new jn.timeline
        , r = e.querySelectorAll(".cw-coin, img, video")
        , s = new Dl(e,{
          type: i.type
      })
        , a = new Dl(s[i.type],{
          type: i.type
      });
      return jn.set(s[i.type], {
          overflow: "hidden",
          verticalAlign: "top",
          padding: "0.2em",
          margin: "-0.2em"
      }),
      jn.set(a[i.type], {
          y: "120%"
      }),
      n.set(a[i.type], {
          willChange: "transform"
      }, 0),
      n.fromTo(a[i.type], {
          y: "120%"
      }, {
          y: "0%",
          duration: i.duration,
          stagger: i.stagger,
          ease: i.ease
      }, 0),
      r.length && (jn.set(r, {
          scale: 0
      }),
      n.fromTo(r, {
          scale: 0
      }, {
          scale: 1,
          duration: i.duration,
          stagger: i.stagger,
          ease: i.ease
      }, .2)),
      n.set(a[i.type], {
          willChange: "auto"
      }),
      n
  }
    , Rl = function(e, t) {
      return void 0 === t && (t = {}),
      Qa.create({
          trigger: e,
          animation: Pl(e, t),
          once: !0
      })
  }
    , Ll = function(e, t) {
      void 0 === t && (t = {});
      const i = Cl({
          from: 0,
          fromOpacity: 1,
          to: 1,
          toOpacity: 1,
          duration: 2,
          stagger: .1,
          ease: "expo.out"
      }, t);
      return jn.set(e, {
          scale: i.from,
          opacity: i.fromOpacity
      }),
      jn.fromTo(e, {
          scale: i.from,
          opacity: i.fromOpacity
      }, {
          scale: i.to,
          opacity: i.toOpacity,
          duration: i.duration,
          stagger: i.stagger,
          ease: i.ease
      })
  }
    , Il = function(e, t) {
      return void 0 === t && (t = {}),
      Qa.create({
          trigger: e,
          animation: Ll(e, t),
          once: !0
      })
  }
    , Nl = function(e, t) {
      void 0 === t && (t = {});
      const i = Cl({
          fromY: 70,
          toY: 0,
          fromX: 0,
          toX: 0,
          duration: 2,
          opacityDuration: 1,
          stagger: .1,
          ease: "expo.out"
      }, t)
        , n = new jn.timeline;
      return jn.set(e, {
          opacity: 0,
          y: i.fromY
      }),
      n.set(e, {
          willChange: "transform"
      }),
      n.fromTo(e, {
          opacity: 0
      }, {
          opacity: 1,
          duration: i.opacityDuration,
          stagger: i.stagger
      }, 0),
      n.fromTo(e, {
          y: i.fromY,
          x: i.fromX
      }, {
          y: i.toY,
          x: i.toX,
          duration: i.duration,
          stagger: i.stagger,
          ease: i.ease
      }, 0),
      n.set(e, {
          willChange: "auto"
      }),
      n
  }
    , Fl = function(e, t) {
      return void 0 === t && (t = {}),
      Qa.create({
          trigger: e,
          animation: Nl(e, t),
          once: !0
      })
  }
    , Ol = function(e, t, i) {
      return void 0 === t && (t = {}),
      void 0 === i && (i = {}),
      jn.set(e, {
          opacity: 0
      }),
      Qa.refresh(),
      Qa.batch(e, Cl({
          onEnter: e => Nl(e, t),
          once: !0
      }, i))
  }
    , Ul = function(e, t) {
      void 0 === t && (t = {});
      const i = Cl({
          from: 0,
          to: 1,
          duration: 2,
          stagger: .1,
          ease: "expo.out"
      }, t)
        , n = new jn.timeline;
      return jn.set(e, {
          opacity: 0
      }),
      n.fromTo(e, {
          opacity: i.from
      }, {
          opacity: i.to,
          duration: i.duration,
          stagger: i.stagger
      }, 0),
      n
  }
    , Bl = function(e, t) {
      return void 0 === t && (t = {}),
      Qa.create({
          trigger: e,
          animation: Ul(e, t),
          once: !0
      })
  }
    , zl = function(e, t) {
      void 0 === t && (t = {}),
      Cl({
          from: 0,
          to: 1,
          duration: 2,
          stagger: .1,
          ease: "expo.out"
      }, t);
      const i = new jn.timeline
        , n = e.querySelector(".cw-btn_cta-border")
        , r = e.querySelector(".cw-btn_cta-title");
      return jn.set(e, {
          pointerEvents: "none"
      }),
      i.set([n, r], {
          willChange: "transform"
      }),
      i.fromTo(n, {
          scaleY: .5,
          scaleX: 0
      }, {
          scaleY: 1,
          scaleX: 1,
          duration: 1.5,
          ease: "expo.out"
      }, 0),
      i.fromTo(r, {
          scaleY: .5,
          scaleX: .5
      }, {
          scaleY: 1,
          scaleX: 1,
          duration: 1.5,
          ease: "expo.out"
      }, 0),
      i.from(r, {
          y: "110%",
          duration: 1.2,
          ease: "expo.out"
      }, .1),
      i.fromTo(n, {
          opacity: 0
      }, {
          opacity: 1,
          duration: .4
      }, .2),
      i.set(e, {
          pointerEvents: "auto"
      }, .6),
      i.set([n, r], {
          willChange: "auto"
      }),
      i
  }
    , kl = function(e, t) {
      return void 0 === t && (t = {}),
      Qa.create({
          trigger: e,
          animation: zl(e, t),
          once: !0
      })
  };
  var Vl = new Map;
  function Hl(e) {
      var t = Vl.get(e);
      t && t.destroy()
  }
  function Gl(e) {
      var t = Vl.get(e);
      t && t.update()
  }
  var Wl = null;
  "undefined" == typeof window ? ((Wl = function(e) {
      return e
  }
  ).destroy = function(e) {
      return e
  }
  ,
  Wl.update = function(e) {
      return e
  }
  ) : ((Wl = function(e, t) {
      return e && Array.prototype.forEach.call(e.length ? e : [e], (function(e) {
          return function(e) {
              if (e && e.nodeName && "TEXTAREA" === e.nodeName && !Vl.has(e)) {
                  var t, i = null, n = window.getComputedStyle(e), r = (t = e.value,
                  function() {
                      a({
                          testForHeightReduction: "" === t || !e.value.startsWith(t),
                          restoreTextAlign: null
                      }),
                      t = e.value
                  }
                  ), s = function(t) {
                      e.removeEventListener("autosize:destroy", s),
                      e.removeEventListener("autosize:update", o),
                      e.removeEventListener("input", r),
                      window.removeEventListener("resize", o),
                      Object.keys(t).forEach((function(i) {
                          return e.style[i] = t[i]
                      }
                      )),
                      Vl.delete(e)
                  }
                  .bind(e, {
                      height: e.style.height,
                      resize: e.style.resize,
                      textAlign: e.style.textAlign,
                      overflowY: e.style.overflowY,
                      overflowX: e.style.overflowX,
                      wordWrap: e.style.wordWrap
                  });
                  e.addEventListener("autosize:destroy", s),
                  e.addEventListener("autosize:update", o),
                  e.addEventListener("input", r),
                  window.addEventListener("resize", o),
                  e.style.overflowX = "hidden",
                  e.style.wordWrap = "break-word",
                  Vl.set(e, {
                      destroy: s,
                      update: o
                  }),
                  o()
              }
              function a(t) {
                  var r, s, o = t.restoreTextAlign, l = void 0 === o ? null : o, c = t.testForHeightReduction, u = void 0 === c || c, h = n.overflowY;
                  if (0 !== e.scrollHeight && ("vertical" === n.resize ? e.style.resize = "none" : "both" === n.resize && (e.style.resize = "horizontal"),
                  u && (r = function(e) {
                      for (var t = []; e && e.parentNode && e.parentNode instanceof Element; )
                          e.parentNode.scrollTop && t.push([e.parentNode, e.parentNode.scrollTop]),
                          e = e.parentNode;
                      return function() {
                          return t.forEach((function(e) {
                              var t = e[0]
                                , i = e[1];
                              t.style.scrollBehavior = "auto",
                              t.scrollTop = i,
                              t.style.scrollBehavior = null
                          }
                          ))
                      }
                  }(e),
                  e.style.height = ""),
                  s = "content-box" === n.boxSizing ? e.scrollHeight - (parseFloat(n.paddingTop) + parseFloat(n.paddingBottom)) : e.scrollHeight + parseFloat(n.borderTopWidth) + parseFloat(n.borderBottomWidth),
                  "none" !== n.maxHeight && s > parseFloat(n.maxHeight) ? ("hidden" === n.overflowY && (e.style.overflow = "scroll"),
                  s = parseFloat(n.maxHeight)) : "hidden" !== n.overflowY && (e.style.overflow = "hidden"),
                  e.style.height = s + "px",
                  l && (e.style.textAlign = l),
                  r && r(),
                  i !== s && (e.dispatchEvent(new Event("autosize:resized",{
                      bubbles: !0
                  })),
                  i = s),
                  h !== n.overflow && !l)) {
                      var d = n.textAlign;
                      "hidden" === n.overflow && (e.style.textAlign = "start" === d ? "end" : "start"),
                      a({
                          restoreTextAlign: d,
                          testForHeightReduction: !0
                      })
                  }
              }
              function o() {
                  a({
                      testForHeightReduction: !0,
                      restoreTextAlign: null
                  })
              }
          }(e)
      }
      )),
      e
  }
  ).destroy = function(e) {
      return e && Array.prototype.forEach.call(e.length ? e : [e], Hl),
      e
  }
  ,
  Wl.update = function(e) {
      return e && Array.prototype.forEach.call(e.length ? e : [e], Gl),
      e
  }
  );
  var Xl = Wl;
  let ql = !1;
  function jl(e) {
      return null !== e && "object" == typeof e && "constructor"in e && e.constructor === Object
  }
  function Yl(e, t) {
      void 0 === e && (e = {}),
      void 0 === t && (t = {}),
      Object.keys(t).forEach((i => {
          void 0 === e[i] ? e[i] = t[i] : jl(t[i]) && jl(e[i]) && Object.keys(t[i]).length > 0 && Yl(e[i], t[i])
      }
      ))
  }
  const Kl = {
      body: {},
      addEventListener() {},
      removeEventListener() {},
      activeElement: {
          blur() {},
          nodeName: ""
      },
      querySelector: () => null,
      querySelectorAll: () => [],
      getElementById: () => null,
      createEvent: () => ({
          initEvent() {}
      }),
      createElement: () => ({
          children: [],
          childNodes: [],
          style: {},
          setAttribute() {},
          getElementsByTagName: () => []
      }),
      createElementNS: () => ({}),
      importNode: () => null,
      location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
      }
  };
  function Zl() {
      const e = "undefined" != typeof document ? document : {};
      return Yl(e, Kl),
      e
  }
  const $l = {
      document: Kl,
      navigator: {
          userAgent: ""
      },
      location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
      },
      history: {
          replaceState() {},
          pushState() {},
          go() {},
          back() {}
      },
      CustomEvent: function() {
          return this
      },
      addEventListener() {},
      removeEventListener() {},
      getComputedStyle: () => ({
          getPropertyValue: () => ""
      }),
      Image() {},
      Date() {},
      screen: {},
      setTimeout() {},
      clearTimeout() {},
      matchMedia: () => ({}),
      requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(),
      null) : setTimeout(e, 0),
      cancelAnimationFrame(e) {
          "undefined" != typeof setTimeout && clearTimeout(e)
      }
  };
  function Jl() {
      const e = "undefined" != typeof window ? window : {};
      return Yl(e, $l),
      e
  }
  function Ql(e, t) {
      return void 0 === t && (t = 0),
      setTimeout(e, t)
  }
  function ec() {
      return Date.now()
  }
  function tc(e) {
      return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
  }
  function ic() {
      const e = Object(arguments.length <= 0 ? void 0 : arguments[0])
        , t = ["__proto__", "constructor", "prototype"];
      for (let n = 1; n < arguments.length; n += 1) {
          const r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
          if (null != r && (i = r,
          !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) {
              const i = Object.keys(Object(r)).filter((e => t.indexOf(e) < 0));
              for (let t = 0, n = i.length; t < n; t += 1) {
                  const n = i[t]
                    , s = Object.getOwnPropertyDescriptor(r, n);
                  void 0 !== s && s.enumerable && (tc(e[n]) && tc(r[n]) ? r[n].__swiper__ ? e[n] = r[n] : ic(e[n], r[n]) : !tc(e[n]) && tc(r[n]) ? (e[n] = {},
                  r[n].__swiper__ ? e[n] = r[n] : ic(e[n], r[n])) : e[n] = r[n])
              }
          }
      }
      var i;
      return e
  }
  function nc(e, t, i) {
      e.style.setProperty(t, i)
  }
  function rc(e) {
      let {swiper: t, targetPosition: i, side: n} = e;
      const r = Jl()
        , s = -t.translate;
      let a, o = null;
      const l = t.params.speed;
      t.wrapperEl.style.scrollSnapType = "none",
      r.cancelAnimationFrame(t.cssModeFrameID);
      const c = i > s ? "next" : "prev"
        , u = (e, t) => "next" === c && e >= t || "prev" === c && e <= t
        , h = () => {
          a = (new Date).getTime(),
          null === o && (o = a);
          const e = Math.max(Math.min((a - o) / l, 1), 0)
            , c = .5 - Math.cos(e * Math.PI) / 2;
          let d = s + c * (i - s);
          if (u(d, i) && (d = i),
          t.wrapperEl.scrollTo({
              [n]: d
          }),
          u(d, i))
              return t.wrapperEl.style.overflow = "hidden",
              t.wrapperEl.style.scrollSnapType = "",
              setTimeout(( () => {
                  t.wrapperEl.style.overflow = "",
                  t.wrapperEl.scrollTo({
                      [n]: d
                  })
              }
              )),
              void r.cancelAnimationFrame(t.cssModeFrameID);
          t.cssModeFrameID = r.requestAnimationFrame(h)
      }
      ;
      h()
  }
  function sc(e, t) {
      void 0 === t && (t = "");
      const i = [...e.children];
      return e instanceof HTMLSlotElement && i.push(...e.assignedElements()),
      t ? i.filter((e => e.matches(t))) : i
  }
  function ac(e) {
      try {
          return void console.warn(e)
      } catch (e) {}
  }
  function oc(e, t) {
      void 0 === t && (t = []);
      const i = document.createElement(e);
      return i.classList.add(...Array.isArray(t) ? t : function(e) {
          return void 0 === e && (e = ""),
          e.trim().split(" ").filter((e => !!e.trim()))
      }(t)),
      i
  }
  function lc(e, t) {
      return Jl().getComputedStyle(e, null).getPropertyValue(t)
  }
  function cc(e) {
      let t, i = e;
      if (i) {
          for (t = 0; null !== (i = i.previousSibling); )
              1 === i.nodeType && (t += 1);
          return t
      }
  }
  function uc(e, t, i) {
      const n = Jl();
      return i ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth
  }
  let hc, dc, pc;
  function fc() {
      return hc || (hc = function() {
          const e = Jl()
            , t = Zl();
          return {
              smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior"in t.documentElement.style,
              touch: !!("ontouchstart"in e || e.DocumentTouch && t instanceof e.DocumentTouch)
          }
      }()),
      hc
  }
  function mc(e) {
      return void 0 === e && (e = {}),
      dc || (dc = function(e) {
          let {userAgent: t} = void 0 === e ? {} : e;
          const i = fc()
            , n = Jl()
            , r = n.navigator.platform
            , s = t || n.navigator.userAgent
            , a = {
              ios: !1,
              android: !1
          }
            , o = n.screen.width
            , l = n.screen.height
            , c = s.match(/(Android);?[\s\/]+([\d.]+)?/);
          let u = s.match(/(iPad).*OS\s([\d_]+)/);
          const h = s.match(/(iPod)(.*OS\s([\d_]+))?/)
            , d = !u && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
            , p = "Win32" === r;
          let f = "MacIntel" === r;
          return !u && f && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${l}`) >= 0 && (u = s.match(/(Version)\/([\d.]+)/),
          u || (u = [0, 1, "13_0_0"]),
          f = !1),
          c && !p && (a.os = "android",
          a.android = !0),
          (u || d || h) && (a.os = "ios",
          a.ios = !0),
          a
      }(e)),
      dc
  }
  var gc = {
      on(e, t, i) {
          const n = this;
          if (!n.eventsListeners || n.destroyed)
              return n;
          if ("function" != typeof t)
              return n;
          const r = i ? "unshift" : "push";
          return e.split(" ").forEach((e => {
              n.eventsListeners[e] || (n.eventsListeners[e] = []),
              n.eventsListeners[e][r](t)
          }
          )),
          n
      },
      once(e, t, i) {
          const n = this;
          if (!n.eventsListeners || n.destroyed)
              return n;
          if ("function" != typeof t)
              return n;
          function r() {
              n.off(e, r),
              r.__emitterProxy && delete r.__emitterProxy;
              for (var i = arguments.length, s = new Array(i), a = 0; a < i; a++)
                  s[a] = arguments[a];
              t.apply(n, s)
          }
          return r.__emitterProxy = t,
          n.on(e, r, i)
      },
      onAny(e, t) {
          const i = this;
          if (!i.eventsListeners || i.destroyed)
              return i;
          if ("function" != typeof e)
              return i;
          const n = t ? "unshift" : "push";
          return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[n](e),
          i
      },
      offAny(e) {
          const t = this;
          if (!t.eventsListeners || t.destroyed)
              return t;
          if (!t.eventsAnyListeners)
              return t;
          const i = t.eventsAnyListeners.indexOf(e);
          return i >= 0 && t.eventsAnyListeners.splice(i, 1),
          t
      },
      off(e, t) {
          const i = this;
          return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach((e => {
              void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach(( (n, r) => {
                  (n === t || n.__emitterProxy && n.__emitterProxy === t) && i.eventsListeners[e].splice(r, 1)
              }
              ))
          }
          )),
          i) : i
      },
      emit() {
          const e = this;
          if (!e.eventsListeners || e.destroyed)
              return e;
          if (!e.eventsListeners)
              return e;
          let t, i, n;
          for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)
              s[a] = arguments[a];
          return "string" == typeof s[0] || Array.isArray(s[0]) ? (t = s[0],
          i = s.slice(1, s.length),
          n = e) : (t = s[0].events,
          i = s[0].data,
          n = s[0].context || e),
          i.unshift(n),
          (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
              e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                  e.apply(n, [t, ...i])
              }
              )),
              e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
                  e.apply(n, i)
              }
              ))
          }
          )),
          e
      }
  };
  const vc = (e, t, i) => {
      t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
  }
    , _c = (e, t, i) => {
      t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
  }
    , yc = (e, t) => {
      if (!e || e.destroyed || !e.params)
          return;
      const i = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
      if (i) {
          let t = i.querySelector(`.${e.params.lazyPreloaderClass}`);
          !t && e.isElement && (i.shadowRoot ? t = i.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame(( () => {
              i.shadowRoot && (t = i.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`),
              t && t.remove())
          }
          ))),
          t && t.remove()
      }
  }
    , xc = (e, t) => {
      if (!e.slides[t])
          return;
      const i = e.slides[t].querySelector('[loading="lazy"]');
      i && i.removeAttribute("loading")
  }
    , Sc = e => {
      if (!e || e.destroyed || !e.params)
          return;
      let t = e.params.lazyPreloadPrevNext;
      const i = e.slides.length;
      if (!i || !t || t < 0)
          return;
      t = Math.min(t, i);
      const n = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView)
        , r = e.activeIndex;
      if (e.params.grid && e.params.grid.rows > 1) {
          const i = r
            , s = [i - t];
          return s.push(...Array.from({
              length: t
          }).map(( (e, t) => i + n + t))),
          void e.slides.forEach(( (t, i) => {
              s.includes(t.column) && xc(e, i)
          }
          ))
      }
      const s = r + n - 1;
      if (e.params.rewind || e.params.loop)
          for (let n = r - t; n <= s + t; n += 1) {
              const t = (n % i + i) % i;
              (t < r || t > s) && xc(e, t)
          }
      else
          for (let n = Math.max(r - t, 0); n <= Math.min(s + t, i - 1); n += 1)
              n !== r && (n > s || n < r) && xc(e, n)
  }
  ;
  var Ec = {
      updateSize: function() {
          const e = this;
          let t, i;
          const n = e.el;
          t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : n.clientWidth,
          i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : n.clientHeight,
          0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(lc(n, "padding-left") || 0, 10) - parseInt(lc(n, "padding-right") || 0, 10),
          i = i - parseInt(lc(n, "padding-top") || 0, 10) - parseInt(lc(n, "padding-bottom") || 0, 10),
          Number.isNaN(t) && (t = 0),
          Number.isNaN(i) && (i = 0),
          Object.assign(e, {
              width: t,
              height: i,
              size: e.isHorizontal() ? t : i
          }))
      },
      updateSlides: function() {
          const e = this;
          function t(t, i) {
              return parseFloat(t.getPropertyValue(e.getDirectionLabel(i)) || 0)
          }
          const i = e.params
            , {wrapperEl: n, slidesEl: r, size: s, rtlTranslate: a, wrongRTL: o} = e
            , l = e.virtual && i.virtual.enabled
            , c = l ? e.virtual.slides.length : e.slides.length
            , u = sc(r, `.${e.params.slideClass}, swiper-slide`)
            , h = l ? e.virtual.slides.length : u.length;
          let d = [];
          const p = []
            , f = [];
          let m = i.slidesOffsetBefore;
          "function" == typeof m && (m = i.slidesOffsetBefore.call(e));
          let g = i.slidesOffsetAfter;
          "function" == typeof g && (g = i.slidesOffsetAfter.call(e));
          const v = e.snapGrid.length
            , _ = e.slidesGrid.length;
          let y = i.spaceBetween
            , x = -m
            , S = 0
            , E = 0;
          if (void 0 === s)
              return;
          "string" == typeof y && y.indexOf("%") >= 0 ? y = parseFloat(y.replace("%", "")) / 100 * s : "string" == typeof y && (y = parseFloat(y)),
          e.virtualSize = -y,
          u.forEach((e => {
              a ? e.style.marginLeft = "" : e.style.marginRight = "",
              e.style.marginBottom = "",
              e.style.marginTop = ""
          }
          )),
          i.centeredSlides && i.cssMode && (nc(n, "--swiper-centered-offset-before", ""),
          nc(n, "--swiper-centered-offset-after", ""));
          const M = i.grid && i.grid.rows > 1 && e.grid;
          let b;
          M ? e.grid.initSlides(u) : e.grid && e.grid.unsetSlides();
          const T = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e => void 0 !== i.breakpoints[e].slidesPerView)).length > 0;
          for (let n = 0; n < h; n += 1) {
              let r;
              if (b = 0,
              u[n] && (r = u[n]),
              M && e.grid.updateSlide(n, r, u),
              !u[n] || "none" !== lc(r, "display")) {
                  if ("auto" === i.slidesPerView) {
                      T && (u[n].style[e.getDirectionLabel("width")] = "");
                      const s = getComputedStyle(r)
                        , a = r.style.transform
                        , o = r.style.webkitTransform;
                      if (a && (r.style.transform = "none"),
                      o && (r.style.webkitTransform = "none"),
                      i.roundLengths)
                          b = e.isHorizontal() ? uc(r, "width", !0) : uc(r, "height", !0);
                      else {
                          const e = t(s, "width")
                            , i = t(s, "padding-left")
                            , n = t(s, "padding-right")
                            , a = t(s, "margin-left")
                            , o = t(s, "margin-right")
                            , l = s.getPropertyValue("box-sizing");
                          if (l && "border-box" === l)
                              b = e + a + o;
                          else {
                              const {clientWidth: t, offsetWidth: s} = r;
                              b = e + i + n + a + o + (s - t)
                          }
                      }
                      a && (r.style.transform = a),
                      o && (r.style.webkitTransform = o),
                      i.roundLengths && (b = Math.floor(b))
                  } else
                      b = (s - (i.slidesPerView - 1) * y) / i.slidesPerView,
                      i.roundLengths && (b = Math.floor(b)),
                      u[n] && (u[n].style[e.getDirectionLabel("width")] = `${b}px`);
                  u[n] && (u[n].swiperSlideSize = b),
                  f.push(b),
                  i.centeredSlides ? (x = x + b / 2 + S / 2 + y,
                  0 === S && 0 !== n && (x = x - s / 2 - y),
                  0 === n && (x = x - s / 2 - y),
                  Math.abs(x) < .001 && (x = 0),
                  i.roundLengths && (x = Math.floor(x)),
                  E % i.slidesPerGroup == 0 && d.push(x),
                  p.push(x)) : (i.roundLengths && (x = Math.floor(x)),
                  (E - Math.min(e.params.slidesPerGroupSkip, E)) % e.params.slidesPerGroup == 0 && d.push(x),
                  p.push(x),
                  x = x + b + y),
                  e.virtualSize += b + y,
                  S = b,
                  E += 1
              }
          }
          if (e.virtualSize = Math.max(e.virtualSize, s) + g,
          a && o && ("slide" === i.effect || "coverflow" === i.effect) && (n.style.width = `${e.virtualSize + y}px`),
          i.setWrapperSize && (n.style[e.getDirectionLabel("width")] = `${e.virtualSize + y}px`),
          M && e.grid.updateWrapperSize(b, d),
          !i.centeredSlides) {
              const t = [];
              for (let n = 0; n < d.length; n += 1) {
                  let r = d[n];
                  i.roundLengths && (r = Math.floor(r)),
                  d[n] <= e.virtualSize - s && t.push(r)
              }
              d = t,
              Math.floor(e.virtualSize - s) - Math.floor(d[d.length - 1]) > 1 && d.push(e.virtualSize - s)
          }
          if (l && i.loop) {
              const t = f[0] + y;
              if (i.slidesPerGroup > 1) {
                  const n = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup)
                    , r = t * i.slidesPerGroup;
                  for (let e = 0; e < n; e += 1)
                      d.push(d[d.length - 1] + r)
              }
              for (let n = 0; n < e.virtual.slidesBefore + e.virtual.slidesAfter; n += 1)
                  1 === i.slidesPerGroup && d.push(d[d.length - 1] + t),
                  p.push(p[p.length - 1] + t),
                  e.virtualSize += t
          }
          if (0 === d.length && (d = [0]),
          0 !== y) {
              const t = e.isHorizontal() && a ? "marginLeft" : e.getDirectionLabel("marginRight");
              u.filter(( (e, t) => !(i.cssMode && !i.loop) || t !== u.length - 1)).forEach((e => {
                  e.style[t] = `${y}px`
              }
              ))
          }
          if (i.centeredSlides && i.centeredSlidesBounds) {
              let e = 0;
              f.forEach((t => {
                  e += t + (y || 0)
              }
              )),
              e -= y;
              const t = e - s;
              d = d.map((e => e <= 0 ? -m : e > t ? t + g : e))
          }
          if (i.centerInsufficientSlides) {
              let e = 0;
              f.forEach((t => {
                  e += t + (y || 0)
              }
              )),
              e -= y;
              const t = (i.slidesOffsetBefore || 0) + (i.slidesOffsetAfter || 0);
              if (e + t < s) {
                  const i = (s - e - t) / 2;
                  d.forEach(( (e, t) => {
                      d[t] = e - i
                  }
                  )),
                  p.forEach(( (e, t) => {
                      p[t] = e + i
                  }
                  ))
              }
          }
          if (Object.assign(e, {
              slides: u,
              snapGrid: d,
              slidesGrid: p,
              slidesSizesGrid: f
          }),
          i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
              nc(n, "--swiper-centered-offset-before", -d[0] + "px"),
              nc(n, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px");
              const t = -e.snapGrid[0]
                , i = -e.slidesGrid[0];
              e.snapGrid = e.snapGrid.map((e => e + t)),
              e.slidesGrid = e.slidesGrid.map((e => e + i))
          }
          if (h !== c && e.emit("slidesLengthChange"),
          d.length !== v && (e.params.watchOverflow && e.checkOverflow(),
          e.emit("snapGridLengthChange")),
          p.length !== _ && e.emit("slidesGridLengthChange"),
          i.watchSlidesProgress && e.updateSlidesOffset(),
          e.emit("slidesUpdated"),
          !(l || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) {
              const t = `${i.containerModifierClass}backface-hidden`
                , n = e.el.classList.contains(t);
              h <= i.maxBackfaceHiddenSlides ? n || e.el.classList.add(t) : n && e.el.classList.remove(t)
          }
      },
      updateAutoHeight: function(e) {
          const t = this
            , i = []
            , n = t.virtual && t.params.virtual.enabled;
          let r, s = 0;
          "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
          const a = e => n ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
          if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
              if (t.params.centeredSlides)
                  (t.visibleSlides || []).forEach((e => {
                      i.push(e)
                  }
                  ));
              else
                  for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) {
                      const e = t.activeIndex + r;
                      if (e > t.slides.length && !n)
                          break;
                      i.push(a(e))
                  }
          else
              i.push(a(t.activeIndex));
          for (r = 0; r < i.length; r += 1)
              if (void 0 !== i[r]) {
                  const e = i[r].offsetHeight;
                  s = e > s ? e : s
              }
          (s || 0 === s) && (t.wrapperEl.style.height = `${s}px`)
      },
      updateSlidesOffset: function() {
          const e = this
            , t = e.slides
            , i = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
          for (let n = 0; n < t.length; n += 1)
              t[n].swiperSlideOffset = (e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop) - i - e.cssOverflowAdjustment()
      },
      updateSlidesProgress: function(e) {
          void 0 === e && (e = this && this.translate || 0);
          const t = this
            , i = t.params
            , {slides: n, rtlTranslate: r, snapGrid: s} = t;
          if (0 === n.length)
              return;
          void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset();
          let a = -e;
          r && (a = e),
          t.visibleSlidesIndexes = [],
          t.visibleSlides = [];
          let o = i.spaceBetween;
          "string" == typeof o && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * t.size : "string" == typeof o && (o = parseFloat(o));
          for (let e = 0; e < n.length; e += 1) {
              const l = n[e];
              let c = l.swiperSlideOffset;
              i.cssMode && i.centeredSlides && (c -= n[0].swiperSlideOffset);
              const u = (a + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + o)
                , h = (a - s[0] + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + o)
                , d = -(a - c)
                , p = d + t.slidesSizesGrid[e]
                , f = d >= 0 && d <= t.size - t.slidesSizesGrid[e]
                , m = d >= 0 && d < t.size - 1 || p > 1 && p <= t.size || d <= 0 && p >= t.size;
              m && (t.visibleSlides.push(l),
              t.visibleSlidesIndexes.push(e)),
              vc(l, m, i.slideVisibleClass),
              vc(l, f, i.slideFullyVisibleClass),
              l.progress = r ? -u : u,
              l.originalProgress = r ? -h : h
          }
      },
      updateProgress: function(e) {
          const t = this;
          if (void 0 === e) {
              const i = t.rtlTranslate ? -1 : 1;
              e = t && t.translate && t.translate * i || 0
          }
          const i = t.params
            , n = t.maxTranslate() - t.minTranslate();
          let {progress: r, isBeginning: s, isEnd: a, progressLoop: o} = t;
          const l = s
            , c = a;
          if (0 === n)
              r = 0,
              s = !0,
              a = !0;
          else {
              r = (e - t.minTranslate()) / n;
              const i = Math.abs(e - t.minTranslate()) < 1
                , o = Math.abs(e - t.maxTranslate()) < 1;
              s = i || r <= 0,
              a = o || r >= 1,
              i && (r = 0),
              o && (r = 1)
          }
          if (i.loop) {
              const i = t.getSlideIndexByData(0)
                , n = t.getSlideIndexByData(t.slides.length - 1)
                , r = t.slidesGrid[i]
                , s = t.slidesGrid[n]
                , a = t.slidesGrid[t.slidesGrid.length - 1]
                , l = Math.abs(e);
              o = l >= r ? (l - r) / a : (l + a - s) / a,
              o > 1 && (o -= 1)
          }
          Object.assign(t, {
              progress: r,
              progressLoop: o,
              isBeginning: s,
              isEnd: a
          }),
          (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e),
          s && !l && t.emit("reachBeginning toEdge"),
          a && !c && t.emit("reachEnd toEdge"),
          (l && !s || c && !a) && t.emit("fromEdge"),
          t.emit("progress", r)
      },
      updateSlidesClasses: function() {
          const e = this
            , {slides: t, params: i, slidesEl: n, activeIndex: r} = e
            , s = e.virtual && i.virtual.enabled
            , a = e.grid && i.grid && i.grid.rows > 1
            , o = e => sc(n, `.${i.slideClass}${e}, swiper-slide${e}`)[0];
          let l, c, u;
          if (s)
              if (i.loop) {
                  let t = r - e.virtual.slidesBefore;
                  t < 0 && (t = e.virtual.slides.length + t),
                  t >= e.virtual.slides.length && (t -= e.virtual.slides.length),
                  l = o(`[data-swiper-slide-index="${t}"]`)
              } else
                  l = o(`[data-swiper-slide-index="${r}"]`);
          else
              a ? (l = t.filter((e => e.column === r))[0],
              u = t.filter((e => e.column === r + 1))[0],
              c = t.filter((e => e.column === r - 1))[0]) : l = t[r];
          l && (a || (u = function(e, t) {
              const i = [];
              for (; e.nextElementSibling; ) {
                  const n = e.nextElementSibling;
                  t ? n.matches(t) && i.push(n) : i.push(n),
                  e = n
              }
              return i
          }(l, `.${i.slideClass}, swiper-slide`)[0],
          i.loop && !u && (u = t[0]),
          c = function(e, t) {
              const i = [];
              for (; e.previousElementSibling; ) {
                  const n = e.previousElementSibling;
                  t ? n.matches(t) && i.push(n) : i.push(n),
                  e = n
              }
              return i
          }(l, `.${i.slideClass}, swiper-slide`)[0],
          i.loop && 0 === !c && (c = t[t.length - 1]))),
          t.forEach((e => {
              _c(e, e === l, i.slideActiveClass),
              _c(e, e === u, i.slideNextClass),
              _c(e, e === c, i.slidePrevClass)
          }
          )),
          e.emitSlidesClasses()
      },
      updateActiveIndex: function(e) {
          const t = this
            , i = t.rtlTranslate ? t.translate : -t.translate
            , {snapGrid: n, params: r, activeIndex: s, realIndex: a, snapIndex: o} = t;
          let l, c = e;
          const u = e => {
              let i = e - t.virtual.slidesBefore;
              return i < 0 && (i = t.virtual.slides.length + i),
              i >= t.virtual.slides.length && (i -= t.virtual.slides.length),
              i
          }
          ;
          if (void 0 === c && (c = function(e) {
              const {slidesGrid: t, params: i} = e
                , n = e.rtlTranslate ? e.translate : -e.translate;
              let r;
              for (let e = 0; e < t.length; e += 1)
                  void 0 !== t[e + 1] ? n >= t[e] && n < t[e + 1] - (t[e + 1] - t[e]) / 2 ? r = e : n >= t[e] && n < t[e + 1] && (r = e + 1) : n >= t[e] && (r = e);
              return i.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0),
              r
          }(t)),
          n.indexOf(i) >= 0)
              l = n.indexOf(i);
          else {
              const e = Math.min(r.slidesPerGroupSkip, c);
              l = e + Math.floor((c - e) / r.slidesPerGroup)
          }
          if (l >= n.length && (l = n.length - 1),
          c === s && !t.params.loop)
              return void (l !== o && (t.snapIndex = l,
              t.emit("snapIndexChange")));
          if (c === s && t.params.loop && t.virtual && t.params.virtual.enabled)
              return void (t.realIndex = u(c));
          const h = t.grid && r.grid && r.grid.rows > 1;
          let d;
          if (t.virtual && r.virtual.enabled && r.loop)
              d = u(c);
          else if (h) {
              const e = t.slides.filter((e => e.column === c))[0];
              let i = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
              Number.isNaN(i) && (i = Math.max(t.slides.indexOf(e), 0)),
              d = Math.floor(i / r.grid.rows)
          } else if (t.slides[c]) {
              const e = t.slides[c].getAttribute("data-swiper-slide-index");
              d = e ? parseInt(e, 10) : c
          } else
              d = c;
          Object.assign(t, {
              previousSnapIndex: o,
              snapIndex: l,
              previousRealIndex: a,
              realIndex: d,
              previousIndex: s,
              activeIndex: c
          }),
          t.initialized && Sc(t),
          t.emit("activeIndexChange"),
          t.emit("snapIndexChange"),
          (t.initialized || t.params.runCallbacksOnInit) && (a !== d && t.emit("realIndexChange"),
          t.emit("slideChange"))
      },
      updateClickedSlide: function(e, t) {
          const i = this
            , n = i.params;
          let r = e.closest(`.${n.slideClass}, swiper-slide`);
          !r && i.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e => {
              !r && e.matches && e.matches(`.${n.slideClass}, swiper-slide`) && (r = e)
          }
          ));
          let s, a = !1;
          if (r)
              for (let e = 0; e < i.slides.length; e += 1)
                  if (i.slides[e] === r) {
                      a = !0,
                      s = e;
                      break
                  }
          if (!r || !a)
              return i.clickedSlide = void 0,
              void (i.clickedIndex = void 0);
          i.clickedSlide = r,
          i.virtual && i.params.virtual.enabled ? i.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : i.clickedIndex = s,
          n.slideToClickedSlide && void 0 !== i.clickedIndex && i.clickedIndex !== i.activeIndex && i.slideToClickedSlide()
      }
  }
    , Mc = {
      getTranslate: function(e) {
          void 0 === e && (e = this.isHorizontal() ? "x" : "y");
          const {params: t, rtlTranslate: i, translate: n, wrapperEl: r} = this;
          if (t.virtualTranslate)
              return i ? -n : n;
          if (t.cssMode)
              return n;
          let s = function(e, t) {
              void 0 === t && (t = "x");
              const i = Jl();
              let n, r, s;
              const a = function(e) {
                  const t = Jl();
                  let i;
                  return t.getComputedStyle && (i = t.getComputedStyle(e, null)),
                  !i && e.currentStyle && (i = e.currentStyle),
                  i || (i = e.style),
                  i
              }(e);
              return i.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform,
              r.split(",").length > 6 && (r = r.split(", ").map((e => e.replace(",", "."))).join(", ")),
              s = new i.WebKitCSSMatrix("none" === r ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
              n = s.toString().split(",")),
              "x" === t && (r = i.WebKitCSSMatrix ? s.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])),
              "y" === t && (r = i.WebKitCSSMatrix ? s.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])),
              r || 0
          }(r, e);
          return s += this.cssOverflowAdjustment(),
          i && (s = -s),
          s || 0
      },
      setTranslate: function(e, t) {
          const i = this
            , {rtlTranslate: n, params: r, wrapperEl: s, progress: a} = i;
          let o, l = 0, c = 0;
          i.isHorizontal() ? l = n ? -e : e : c = e,
          r.roundLengths && (l = Math.floor(l),
          c = Math.floor(c)),
          i.previousTranslate = i.translate,
          i.translate = i.isHorizontal() ? l : c,
          r.cssMode ? s[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -c : r.virtualTranslate || (i.isHorizontal() ? l -= i.cssOverflowAdjustment() : c -= i.cssOverflowAdjustment(),
          s.style.transform = `translate3d(${l}px, ${c}px, 0px)`);
          const u = i.maxTranslate() - i.minTranslate();
          o = 0 === u ? 0 : (e - i.minTranslate()) / u,
          o !== a && i.updateProgress(e),
          i.emit("setTranslate", i.translate, t)
      },
      minTranslate: function() {
          return -this.snapGrid[0]
      },
      maxTranslate: function() {
          return -this.snapGrid[this.snapGrid.length - 1]
      },
      translateTo: function(e, t, i, n, r) {
          void 0 === e && (e = 0),
          void 0 === t && (t = this.params.speed),
          void 0 === i && (i = !0),
          void 0 === n && (n = !0);
          const s = this
            , {params: a, wrapperEl: o} = s;
          if (s.animating && a.preventInteractionOnTransition)
              return !1;
          const l = s.minTranslate()
            , c = s.maxTranslate();
          let u;
          if (u = n && e > l ? l : n && e < c ? c : e,
          s.updateProgress(u),
          a.cssMode) {
              const e = s.isHorizontal();
              if (0 === t)
                  o[e ? "scrollLeft" : "scrollTop"] = -u;
              else {
                  if (!s.support.smoothScroll)
                      return rc({
                          swiper: s,
                          targetPosition: -u,
                          side: e ? "left" : "top"
                      }),
                      !0;
                  o.scrollTo({
                      [e ? "left" : "top"]: -u,
                      behavior: "smooth"
                  })
              }
              return !0
          }
          return 0 === t ? (s.setTransition(0),
          s.setTranslate(u),
          i && (s.emit("beforeTransitionStart", t, r),
          s.emit("transitionEnd"))) : (s.setTransition(t),
          s.setTranslate(u),
          i && (s.emit("beforeTransitionStart", t, r),
          s.emit("transitionStart")),
          s.animating || (s.animating = !0,
          s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(e) {
              s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd),
              s.onTranslateToWrapperTransitionEnd = null,
              delete s.onTranslateToWrapperTransitionEnd,
              s.animating = !1,
              i && s.emit("transitionEnd"))
          }
          ),
          s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))),
          !0
      }
  };
  function bc(e) {
      let {swiper: t, runCallbacks: i, direction: n, step: r} = e;
      const {activeIndex: s, previousIndex: a} = t;
      let o = n;
      if (o || (o = s > a ? "next" : s < a ? "prev" : "reset"),
      t.emit(`transition${r}`),
      i && s !== a) {
          if ("reset" === o)
              return void t.emit(`slideResetTransition${r}`);
          t.emit(`slideChangeTransition${r}`),
          "next" === o ? t.emit(`slideNextTransition${r}`) : t.emit(`slidePrevTransition${r}`)
      }
  }
  var Tc = {
      slideTo: function(e, t, i, n, r) {
          void 0 === e && (e = 0),
          void 0 === i && (i = !0),
          "string" == typeof e && (e = parseInt(e, 10));
          const s = this;
          let a = e;
          a < 0 && (a = 0);
          const {params: o, snapGrid: l, slidesGrid: c, previousIndex: u, activeIndex: h, rtlTranslate: d, wrapperEl: p, enabled: f} = s;
          if (!f && !n && !r || s.destroyed || s.animating && o.preventInteractionOnTransition)
              return !1;
          void 0 === t && (t = s.params.speed);
          const m = Math.min(s.params.slidesPerGroupSkip, a);
          let g = m + Math.floor((a - m) / s.params.slidesPerGroup);
          g >= l.length && (g = l.length - 1);
          const v = -l[g];
          if (o.normalizeSlideIndex)
              for (let e = 0; e < c.length; e += 1) {
                  const t = -Math.floor(100 * v)
                    , i = Math.floor(100 * c[e])
                    , n = Math.floor(100 * c[e + 1]);
                  void 0 !== c[e + 1] ? t >= i && t < n - (n - i) / 2 ? a = e : t >= i && t < n && (a = e + 1) : t >= i && (a = e)
              }
          if (s.initialized && a !== h) {
              if (!s.allowSlideNext && (d ? v > s.translate && v > s.minTranslate() : v < s.translate && v < s.minTranslate()))
                  return !1;
              if (!s.allowSlidePrev && v > s.translate && v > s.maxTranslate() && (h || 0) !== a)
                  return !1
          }
          let _;
          if (a !== (u || 0) && i && s.emit("beforeSlideChangeStart"),
          s.updateProgress(v),
          _ = a > h ? "next" : a < h ? "prev" : "reset",
          d && -v === s.translate || !d && v === s.translate)
              return s.updateActiveIndex(a),
              o.autoHeight && s.updateAutoHeight(),
              s.updateSlidesClasses(),
              "slide" !== o.effect && s.setTranslate(v),
              "reset" !== _ && (s.transitionStart(i, _),
              s.transitionEnd(i, _)),
              !1;
          if (o.cssMode) {
              const e = s.isHorizontal()
                , i = d ? v : -v;
              if (0 === t) {
                  const t = s.virtual && s.params.virtual.enabled;
                  t && (s.wrapperEl.style.scrollSnapType = "none",
                  s._immediateVirtual = !0),
                  t && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0,
                  requestAnimationFrame(( () => {
                      p[e ? "scrollLeft" : "scrollTop"] = i
                  }
                  ))) : p[e ? "scrollLeft" : "scrollTop"] = i,
                  t && requestAnimationFrame(( () => {
                      s.wrapperEl.style.scrollSnapType = "",
                      s._immediateVirtual = !1
                  }
                  ))
              } else {
                  if (!s.support.smoothScroll)
                      return rc({
                          swiper: s,
                          targetPosition: i,
                          side: e ? "left" : "top"
                      }),
                      !0;
                  p.scrollTo({
                      [e ? "left" : "top"]: i,
                      behavior: "smooth"
                  })
              }
              return !0
          }
          return s.setTransition(t),
          s.setTranslate(v),
          s.updateActiveIndex(a),
          s.updateSlidesClasses(),
          s.emit("beforeTransitionStart", t, n),
          s.transitionStart(i, _),
          0 === t ? s.transitionEnd(i, _) : s.animating || (s.animating = !0,
          s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function(e) {
              s && !s.destroyed && e.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd),
              s.onSlideToWrapperTransitionEnd = null,
              delete s.onSlideToWrapperTransitionEnd,
              s.transitionEnd(i, _))
          }
          ),
          s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)),
          !0
      },
      slideToLoop: function(e, t, i, n) {
          void 0 === e && (e = 0),
          void 0 === i && (i = !0),
          "string" == typeof e && (e = parseInt(e, 10));
          const r = this;
          if (r.destroyed)
              return;
          void 0 === t && (t = r.params.speed);
          const s = r.grid && r.params.grid && r.params.grid.rows > 1;
          let a = e;
          if (r.params.loop)
              if (r.virtual && r.params.virtual.enabled)
                  a += r.virtual.slidesBefore;
              else {
                  let e;
                  if (s) {
                      const t = a * r.params.grid.rows;
                      e = r.slides.filter((e => 1 * e.getAttribute("data-swiper-slide-index") === t))[0].column
                  } else
                      e = r.getSlideIndexByData(a);
                  const t = s ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length
                    , {centeredSlides: i} = r.params;
                  let o = r.params.slidesPerView;
                  "auto" === o ? o = r.slidesPerViewDynamic() : (o = Math.ceil(parseFloat(r.params.slidesPerView, 10)),
                  i && o % 2 == 0 && (o += 1));
                  let l = t - e < o;
                  if (i && (l = l || e < Math.ceil(o / 2)),
                  n && i && "auto" !== r.params.slidesPerView && !s && (l = !1),
                  l) {
                      const n = i ? e < r.activeIndex ? "prev" : "next" : e - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev";
                      r.loopFix({
                          direction: n,
                          slideTo: !0,
                          activeSlideIndex: "next" === n ? e + 1 : e - t + 1,
                          slideRealIndex: "next" === n ? r.realIndex : void 0
                      })
                  }
                  if (s) {
                      const e = a * r.params.grid.rows;
                      a = r.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0].column
                  } else
                      a = r.getSlideIndexByData(a)
              }
          return requestAnimationFrame(( () => {
              r.slideTo(a, t, i, n)
          }
          )),
          r
      },
      slideNext: function(e, t, i) {
          void 0 === t && (t = !0);
          const n = this
            , {enabled: r, params: s, animating: a} = n;
          if (!r || n.destroyed)
              return n;
          void 0 === e && (e = n.params.speed);
          let o = s.slidesPerGroup;
          "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (o = Math.max(n.slidesPerViewDynamic("current", !0), 1));
          const l = n.activeIndex < s.slidesPerGroupSkip ? 1 : o
            , c = n.virtual && s.virtual.enabled;
          if (s.loop) {
              if (a && !c && s.loopPreventsSliding)
                  return !1;
              if (n.loopFix({
                  direction: "next"
              }),
              n._clientLeft = n.wrapperEl.clientLeft,
              n.activeIndex === n.slides.length - 1 && s.cssMode)
                  return requestAnimationFrame(( () => {
                      n.slideTo(n.activeIndex + l, e, t, i)
                  }
                  )),
                  !0
          }
          return s.rewind && n.isEnd ? n.slideTo(0, e, t, i) : n.slideTo(n.activeIndex + l, e, t, i)
      },
      slidePrev: function(e, t, i) {
          void 0 === t && (t = !0);
          const n = this
            , {params: r, snapGrid: s, slidesGrid: a, rtlTranslate: o, enabled: l, animating: c} = n;
          if (!l || n.destroyed)
              return n;
          void 0 === e && (e = n.params.speed);
          const u = n.virtual && r.virtual.enabled;
          if (r.loop) {
              if (c && !u && r.loopPreventsSliding)
                  return !1;
              n.loopFix({
                  direction: "prev"
              }),
              n._clientLeft = n.wrapperEl.clientLeft
          }
          function h(e) {
              return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
          }
          const d = h(o ? n.translate : -n.translate)
            , p = s.map((e => h(e)));
          let f = s[p.indexOf(d) - 1];
          if (void 0 === f && r.cssMode) {
              let e;
              s.forEach(( (t, i) => {
                  d >= t && (e = i)
              }
              )),
              void 0 !== e && (f = s[e > 0 ? e - 1 : e])
          }
          let m = 0;
          if (void 0 !== f && (m = a.indexOf(f),
          m < 0 && (m = n.activeIndex - 1),
          "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (m = m - n.slidesPerViewDynamic("previous", !0) + 1,
          m = Math.max(m, 0))),
          r.rewind && n.isBeginning) {
              const r = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1;
              return n.slideTo(r, e, t, i)
          }
          return r.loop && 0 === n.activeIndex && r.cssMode ? (requestAnimationFrame(( () => {
              n.slideTo(m, e, t, i)
          }
          )),
          !0) : n.slideTo(m, e, t, i)
      },
      slideReset: function(e, t, i) {
          void 0 === t && (t = !0);
          const n = this;
          if (!n.destroyed)
              return void 0 === e && (e = n.params.speed),
              n.slideTo(n.activeIndex, e, t, i)
      },
      slideToClosest: function(e, t, i, n) {
          void 0 === t && (t = !0),
          void 0 === n && (n = .5);
          const r = this;
          if (r.destroyed)
              return;
          void 0 === e && (e = r.params.speed);
          let s = r.activeIndex;
          const a = Math.min(r.params.slidesPerGroupSkip, s)
            , o = a + Math.floor((s - a) / r.params.slidesPerGroup)
            , l = r.rtlTranslate ? r.translate : -r.translate;
          if (l >= r.snapGrid[o]) {
              const e = r.snapGrid[o];
              l - e > (r.snapGrid[o + 1] - e) * n && (s += r.params.slidesPerGroup)
          } else {
              const e = r.snapGrid[o - 1];
              l - e <= (r.snapGrid[o] - e) * n && (s -= r.params.slidesPerGroup)
          }
          return s = Math.max(s, 0),
          s = Math.min(s, r.slidesGrid.length - 1),
          r.slideTo(s, e, t, i)
      },
      slideToClickedSlide: function() {
          const e = this;
          if (e.destroyed)
              return;
          const {params: t, slidesEl: i} = e
            , n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
          let r, s = e.clickedIndex;
          const a = e.isElement ? "swiper-slide" : `.${t.slideClass}`;
          if (t.loop) {
              if (e.animating)
                  return;
              r = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
              t.centeredSlides ? s < e.loopedSlides - n / 2 || s > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(),
              s = e.getSlideIndex(sc(i, `${a}[data-swiper-slide-index="${r}"]`)[0]),
              Ql(( () => {
                  e.slideTo(s)
              }
              ))) : e.slideTo(s) : s > e.slides.length - n ? (e.loopFix(),
              s = e.getSlideIndex(sc(i, `${a}[data-swiper-slide-index="${r}"]`)[0]),
              Ql(( () => {
                  e.slideTo(s)
              }
              ))) : e.slideTo(s)
          } else
              e.slideTo(s)
      }
  }
    , wc = {
      loopCreate: function(e) {
          const t = this
            , {params: i, slidesEl: n} = t;
          if (!i.loop || t.virtual && t.params.virtual.enabled)
              return;
          const r = () => {
              sc(n, `.${i.slideClass}, swiper-slide`).forEach(( (e, t) => {
                  e.setAttribute("data-swiper-slide-index", t)
              }
              ))
          }
            , s = t.grid && i.grid && i.grid.rows > 1
            , a = i.slidesPerGroup * (s ? i.grid.rows : 1)
            , o = t.slides.length % a != 0
            , l = s && t.slides.length % i.grid.rows != 0
            , c = e => {
              for (let n = 0; n < e; n += 1) {
                  const e = t.isElement ? oc("swiper-slide", [i.slideBlankClass]) : oc("div", [i.slideClass, i.slideBlankClass]);
                  t.slidesEl.append(e)
              }
          }
          ;
          o ? (i.loopAddBlankSlides ? (c(a - t.slides.length % a),
          t.recalcSlides(),
          t.updateSlides()) : ac("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"),
          r()) : l ? (i.loopAddBlankSlides ? (c(i.grid.rows - t.slides.length % i.grid.rows),
          t.recalcSlides(),
          t.updateSlides()) : ac("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"),
          r()) : r(),
          t.loopFix({
              slideRealIndex: e,
              direction: i.centeredSlides ? void 0 : "next"
          })
      },
      loopFix: function(e) {
          let {slideRealIndex: t, slideTo: i=!0, direction: n, setTranslate: r, activeSlideIndex: s, byController: a, byMousewheel: o} = void 0 === e ? {} : e;
          const l = this;
          if (!l.params.loop)
              return;
          l.emit("beforeLoopFix");
          const {slides: c, allowSlidePrev: u, allowSlideNext: h, slidesEl: d, params: p} = l
            , {centeredSlides: f} = p;
          if (l.allowSlidePrev = !0,
          l.allowSlideNext = !0,
          l.virtual && p.virtual.enabled)
              return i && (p.centeredSlides || 0 !== l.snapIndex ? p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)),
              l.allowSlidePrev = u,
              l.allowSlideNext = h,
              void l.emit("loopFix");
          let m = p.slidesPerView;
          "auto" === m ? m = l.slidesPerViewDynamic() : (m = Math.ceil(parseFloat(p.slidesPerView, 10)),
          f && m % 2 == 0 && (m += 1));
          const g = p.slidesPerGroupAuto ? m : p.slidesPerGroup;
          let v = g;
          v % g != 0 && (v += g - v % g),
          v += p.loopAdditionalSlides,
          l.loopedSlides = v;
          const _ = l.grid && p.grid && p.grid.rows > 1;
          c.length < m + v ? ac("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : _ && "row" === p.grid.fill && ac("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
          const y = []
            , x = [];
          let S = l.activeIndex;
          void 0 === s ? s = l.getSlideIndex(c.filter((e => e.classList.contains(p.slideActiveClass)))[0]) : S = s;
          const E = "next" === n || !n
            , M = "prev" === n || !n;
          let b = 0
            , T = 0;
          const w = _ ? Math.ceil(c.length / p.grid.rows) : c.length
            , D = (_ ? c[s].column : s) + (f && void 0 === r ? -m / 2 + .5 : 0);
          if (D < v) {
              b = Math.max(v - D, g);
              for (let e = 0; e < v - D; e += 1) {
                  const t = e - Math.floor(e / w) * w;
                  if (_) {
                      const e = w - t - 1;
                      for (let t = c.length - 1; t >= 0; t -= 1)
                          c[t].column === e && y.push(t)
                  } else
                      y.push(w - t - 1)
              }
          } else if (D + m > w - v) {
              T = Math.max(D - (w - 2 * v), g);
              for (let e = 0; e < T; e += 1) {
                  const t = e - Math.floor(e / w) * w;
                  _ ? c.forEach(( (e, i) => {
                      e.column === t && x.push(i)
                  }
                  )) : x.push(t)
              }
          }
          if (l.__preventObserver__ = !0,
          requestAnimationFrame(( () => {
              l.__preventObserver__ = !1
          }
          )),
          M && y.forEach((e => {
              c[e].swiperLoopMoveDOM = !0,
              d.prepend(c[e]),
              c[e].swiperLoopMoveDOM = !1
          }
          )),
          E && x.forEach((e => {
              c[e].swiperLoopMoveDOM = !0,
              d.append(c[e]),
              c[e].swiperLoopMoveDOM = !1
          }
          )),
          l.recalcSlides(),
          "auto" === p.slidesPerView ? l.updateSlides() : _ && (y.length > 0 && M || x.length > 0 && E) && l.slides.forEach(( (e, t) => {
              l.grid.updateSlide(t, e, l.slides)
          }
          )),
          p.watchSlidesProgress && l.updateSlidesOffset(),
          i)
              if (y.length > 0 && M) {
                  if (void 0 === t) {
                      const e = l.slidesGrid[S]
                        , t = l.slidesGrid[S + b] - e;
                      o ? l.setTranslate(l.translate - t) : (l.slideTo(S + Math.ceil(b), 0, !1, !0),
                      r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t,
                      l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                  } else if (r) {
                      const e = _ ? y.length / p.grid.rows : y.length;
                      l.slideTo(l.activeIndex + e, 0, !1, !0),
                      l.touchEventsData.currentTranslate = l.translate
                  }
              } else if (x.length > 0 && E)
                  if (void 0 === t) {
                      const e = l.slidesGrid[S]
                        , t = l.slidesGrid[S - T] - e;
                      o ? l.setTranslate(l.translate - t) : (l.slideTo(S - T, 0, !1, !0),
                      r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t,
                      l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
                  } else {
                      const e = _ ? x.length / p.grid.rows : x.length;
                      l.slideTo(l.activeIndex - e, 0, !1, !0)
                  }
          if (l.allowSlidePrev = u,
          l.allowSlideNext = h,
          l.controller && l.controller.control && !a) {
              const e = {
                  slideRealIndex: t,
                  direction: n,
                  setTranslate: r,
                  activeSlideIndex: s,
                  byController: !0
              };
              Array.isArray(l.controller.control) ? l.controller.control.forEach((t => {
                  !t.destroyed && t.params.loop && t.loopFix({
                      ...e,
                      slideTo: t.params.slidesPerView === p.slidesPerView && i
                  })
              }
              )) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({
                  ...e,
                  slideTo: l.controller.control.params.slidesPerView === p.slidesPerView && i
              })
          }
          l.emit("loopFix")
      },
      loopDestroy: function() {
          const e = this
            , {params: t, slidesEl: i} = e;
          if (!t.loop || e.virtual && e.params.virtual.enabled)
              return;
          e.recalcSlides();
          const n = [];
          e.slides.forEach((e => {
              const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
              n[t] = e
          }
          )),
          e.slides.forEach((e => {
              e.removeAttribute("data-swiper-slide-index")
          }
          )),
          n.forEach((e => {
              i.append(e)
          }
          )),
          e.recalcSlides(),
          e.slideTo(e.realIndex, 0)
      }
  };
  function Dc(e, t, i) {
      const n = Jl()
        , {params: r} = e
        , s = r.edgeSwipeDetection
        , a = r.edgeSwipeThreshold;
      return !s || !(i <= a || i >= n.innerWidth - a) || "prevent" === s && (t.preventDefault(),
      !0)
  }
  function Cc(e) {
      const t = this
        , i = Zl();
      let n = e;
      n.originalEvent && (n = n.originalEvent);
      const r = t.touchEventsData;
      if ("pointerdown" === n.type) {
          if (null !== r.pointerId && r.pointerId !== n.pointerId)
              return;
          r.pointerId = n.pointerId
      } else
          "touchstart" === n.type && 1 === n.targetTouches.length && (r.touchId = n.targetTouches[0].identifier);
      if ("touchstart" === n.type)
          return void Dc(t, n, n.targetTouches[0].pageX);
      const {params: s, touches: a, enabled: o} = t;
      if (!o)
          return;
      if (!s.simulateTouch && "mouse" === n.pointerType)
          return;
      if (t.animating && s.preventInteractionOnTransition)
          return;
      !t.animating && s.cssMode && s.loop && t.loopFix();
      let l = n.target;
      if ("wrapper" === s.touchEventsTarget && !function(e, t) {
          const i = t.contains(e);
          return !i && t instanceof HTMLSlotElement ? [...element.assignedElements()].includes(e) : i
      }(l, t.wrapperEl))
          return;
      if ("which"in n && 3 === n.which)
          return;
      if ("button"in n && n.button > 0)
          return;
      if (r.isTouched && r.isMoved)
          return;
      const c = !!s.noSwipingClass && "" !== s.noSwipingClass
        , u = n.composedPath ? n.composedPath() : n.path;
      c && n.target && n.target.shadowRoot && u && (l = u[0]);
      const h = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`
        , d = !(!n.target || !n.target.shadowRoot);
      if (s.noSwiping && (d ? function(e, t) {
          return void 0 === t && (t = this),
          function t(i) {
              if (!i || i === Zl() || i === Jl())
                  return null;
              i.assignedSlot && (i = i.assignedSlot);
              const n = i.closest(e);
              return n || i.getRootNode ? n || t(i.getRootNode().host) : null
          }(t)
      }(h, l) : l.closest(h)))
          return void (t.allowClick = !0);
      if (s.swipeHandler && !l.closest(s.swipeHandler))
          return;
      a.currentX = n.pageX,
      a.currentY = n.pageY;
      const p = a.currentX
        , f = a.currentY;
      if (!Dc(t, n, p))
          return;
      Object.assign(r, {
          isTouched: !0,
          isMoved: !1,
          allowTouchCallbacks: !0,
          isScrolling: void 0,
          startMoving: void 0
      }),
      a.startX = p,
      a.startY = f,
      r.touchStartTime = ec(),
      t.allowClick = !0,
      t.updateSize(),
      t.swipeDirection = void 0,
      s.threshold > 0 && (r.allowThresholdMove = !1);
      let m = !0;
      l.matches(r.focusableElements) && (m = !1,
      "SELECT" === l.nodeName && (r.isTouched = !1)),
      i.activeElement && i.activeElement.matches(r.focusableElements) && i.activeElement !== l && i.activeElement.blur();
      const g = m && t.allowTouchMove && s.touchStartPreventDefault;
      !s.touchStartForcePreventDefault && !g || l.isContentEditable || n.preventDefault(),
      s.freeMode && s.freeMode.enabled && t.freeMode && t.animating && !s.cssMode && t.freeMode.onTouchStart(),
      t.emit("touchStart", n)
  }
  function Ac(e) {
      const t = Zl()
        , i = this
        , n = i.touchEventsData
        , {params: r, touches: s, rtlTranslate: a, enabled: o} = i;
      if (!o)
          return;
      if (!r.simulateTouch && "mouse" === e.pointerType)
          return;
      let l, c = e;
      if (c.originalEvent && (c = c.originalEvent),
      "pointermove" === c.type) {
          if (null !== n.touchId)
              return;
          if (c.pointerId !== n.pointerId)
              return
      }
      if ("touchmove" === c.type) {
          if (l = [...c.changedTouches].filter((e => e.identifier === n.touchId))[0],
          !l || l.identifier !== n.touchId)
              return
      } else
          l = c;
      if (!n.isTouched)
          return void (n.startMoving && n.isScrolling && i.emit("touchMoveOpposite", c));
      const u = l.pageX
        , h = l.pageY;
      if (c.preventedByNestedSwiper)
          return s.startX = u,
          void (s.startY = h);
      if (!i.allowTouchMove)
          return c.target.matches(n.focusableElements) || (i.allowClick = !1),
          void (n.isTouched && (Object.assign(s, {
              startX: u,
              startY: h,
              currentX: u,
              currentY: h
          }),
          n.touchStartTime = ec()));
      if (r.touchReleaseOnEdges && !r.loop)
          if (i.isVertical()) {
              if (h < s.startY && i.translate <= i.maxTranslate() || h > s.startY && i.translate >= i.minTranslate())
                  return n.isTouched = !1,
                  void (n.isMoved = !1)
          } else if (u < s.startX && i.translate <= i.maxTranslate() || u > s.startX && i.translate >= i.minTranslate())
              return;
      if (t.activeElement && c.target === t.activeElement && c.target.matches(n.focusableElements))
          return n.isMoved = !0,
          void (i.allowClick = !1);
      n.allowTouchCallbacks && i.emit("touchMove", c),
      s.previousX = s.currentX,
      s.previousY = s.currentY,
      s.currentX = u,
      s.currentY = h;
      const d = s.currentX - s.startX
        , p = s.currentY - s.startY;
      if (i.params.threshold && Math.sqrt(d ** 2 + p ** 2) < i.params.threshold)
          return;
      if (void 0 === n.isScrolling) {
          let e;
          i.isHorizontal() && s.currentY === s.startY || i.isVertical() && s.currentX === s.startX ? n.isScrolling = !1 : d * d + p * p >= 25 && (e = 180 * Math.atan2(Math.abs(p), Math.abs(d)) / Math.PI,
          n.isScrolling = i.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
      }
      if (n.isScrolling && i.emit("touchMoveOpposite", c),
      void 0 === n.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (n.startMoving = !0)),
      n.isScrolling || "touchmove" === c.type && n.preventTouchMoveFromPointerMove)
          return void (n.isTouched = !1);
      if (!n.startMoving)
          return;
      i.allowClick = !1,
      !r.cssMode && c.cancelable && c.preventDefault(),
      r.touchMoveStopPropagation && !r.nested && c.stopPropagation();
      let f = i.isHorizontal() ? d : p
        , m = i.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY;
      r.oneWayMovement && (f = Math.abs(f) * (a ? 1 : -1),
      m = Math.abs(m) * (a ? 1 : -1)),
      s.diff = f,
      f *= r.touchRatio,
      a && (f = -f,
      m = -m);
      const g = i.touchesDirection;
      i.swipeDirection = f > 0 ? "prev" : "next",
      i.touchesDirection = m > 0 ? "prev" : "next";
      const v = i.params.loop && !r.cssMode
        , _ = "next" === i.touchesDirection && i.allowSlideNext || "prev" === i.touchesDirection && i.allowSlidePrev;
      if (!n.isMoved) {
          if (v && _ && i.loopFix({
              direction: i.swipeDirection
          }),
          n.startTranslate = i.getTranslate(),
          i.setTransition(0),
          i.animating) {
              const e = new window.CustomEvent("transitionend",{
                  bubbles: !0,
                  cancelable: !0,
                  detail: {
                      bySwiperTouchMove: !0
                  }
              });
              i.wrapperEl.dispatchEvent(e)
          }
          n.allowMomentumBounce = !1,
          !r.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0),
          i.emit("sliderFirstMove", c)
      }
      if ((new Date).getTime(),
      n.isMoved && n.allowThresholdMove && g !== i.touchesDirection && v && _ && Math.abs(f) >= 1)
          return Object.assign(s, {
              startX: u,
              startY: h,
              currentX: u,
              currentY: h,
              startTranslate: n.currentTranslate
          }),
          n.loopSwapReset = !0,
          void (n.startTranslate = n.currentTranslate);
      i.emit("sliderMove", c),
      n.isMoved = !0,
      n.currentTranslate = f + n.startTranslate;
      let y = !0
        , x = r.resistanceRatio;
      if (r.touchReleaseOnEdges && (x = 0),
      f > 0 ? (v && _ && n.allowThresholdMove && n.currentTranslate > (r.centeredSlides ? i.minTranslate() - i.slidesSizesGrid[i.activeIndex + 1] : i.minTranslate()) && i.loopFix({
          direction: "prev",
          setTranslate: !0,
          activeSlideIndex: 0
      }),
      n.currentTranslate > i.minTranslate() && (y = !1,
      r.resistance && (n.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + n.startTranslate + f) ** x))) : f < 0 && (v && _ && n.allowThresholdMove && n.currentTranslate < (r.centeredSlides ? i.maxTranslate() + i.slidesSizesGrid[i.slidesSizesGrid.length - 1] : i.maxTranslate()) && i.loopFix({
          direction: "next",
          setTranslate: !0,
          activeSlideIndex: i.slides.length - ("auto" === r.slidesPerView ? i.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10)))
      }),
      n.currentTranslate < i.maxTranslate() && (y = !1,
      r.resistance && (n.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - n.startTranslate - f) ** x))),
      y && (c.preventedByNestedSwiper = !0),
      !i.allowSlideNext && "next" === i.swipeDirection && n.currentTranslate < n.startTranslate && (n.currentTranslate = n.startTranslate),
      !i.allowSlidePrev && "prev" === i.swipeDirection && n.currentTranslate > n.startTranslate && (n.currentTranslate = n.startTranslate),
      i.allowSlidePrev || i.allowSlideNext || (n.currentTranslate = n.startTranslate),
      r.threshold > 0) {
          if (!(Math.abs(f) > r.threshold || n.allowThresholdMove))
              return void (n.currentTranslate = n.startTranslate);
          if (!n.allowThresholdMove)
              return n.allowThresholdMove = !0,
              s.startX = s.currentX,
              s.startY = s.currentY,
              n.currentTranslate = n.startTranslate,
              void (s.diff = i.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY)
      }
      r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && i.freeMode || r.watchSlidesProgress) && (i.updateActiveIndex(),
      i.updateSlidesClasses()),
      r.freeMode && r.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(),
      i.updateProgress(n.currentTranslate),
      i.setTranslate(n.currentTranslate))
  }
  function Pc(e) {
      const t = this
        , i = t.touchEventsData;
      let n, r = e;
      if (r.originalEvent && (r = r.originalEvent),
      "touchend" === r.type || "touchcancel" === r.type) {
          if (n = [...r.changedTouches].filter((e => e.identifier === i.touchId))[0],
          !n || n.identifier !== i.touchId)
              return
      } else {
          if (null !== i.touchId)
              return;
          if (r.pointerId !== i.pointerId)
              return;
          n = r
      }
      if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type) && (!["pointercancel", "contextmenu"].includes(r.type) || !t.browser.isSafari && !t.browser.isWebView))
          return;
      i.pointerId = null,
      i.touchId = null;
      const {params: s, touches: a, rtlTranslate: o, slidesGrid: l, enabled: c} = t;
      if (!c)
          return;
      if (!s.simulateTouch && "mouse" === r.pointerType)
          return;
      if (i.allowTouchCallbacks && t.emit("touchEnd", r),
      i.allowTouchCallbacks = !1,
      !i.isTouched)
          return i.isMoved && s.grabCursor && t.setGrabCursor(!1),
          i.isMoved = !1,
          void (i.startMoving = !1);
      s.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
      const u = ec()
        , h = u - i.touchStartTime;
      if (t.allowClick) {
          const e = r.path || r.composedPath && r.composedPath();
          t.updateClickedSlide(e && e[0] || r.target, e),
          t.emit("tap click", r),
          h < 300 && u - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", r)
      }
      if (i.lastClickTime = ec(),
      Ql(( () => {
          t.destroyed || (t.allowClick = !0)
      }
      )),
      !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === a.diff && !i.loopSwapReset || i.currentTranslate === i.startTranslate && !i.loopSwapReset)
          return i.isTouched = !1,
          i.isMoved = !1,
          void (i.startMoving = !1);
      let d;
      if (i.isTouched = !1,
      i.isMoved = !1,
      i.startMoving = !1,
      d = s.followFinger ? o ? t.translate : -t.translate : -i.currentTranslate,
      s.cssMode)
          return;
      if (s.freeMode && s.freeMode.enabled)
          return void t.freeMode.onTouchEnd({
              currentPos: d
          });
      const p = d >= -t.maxTranslate() && !t.params.loop;
      let f = 0
        , m = t.slidesSizesGrid[0];
      for (let e = 0; e < l.length; e += e < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) {
          const t = e < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
          void 0 !== l[e + t] ? (p || d >= l[e] && d < l[e + t]) && (f = e,
          m = l[e + t] - l[e]) : (p || d >= l[e]) && (f = e,
          m = l[l.length - 1] - l[l.length - 2])
      }
      let g = null
        , v = null;
      s.rewind && (t.isBeginning ? v = s.virtual && s.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0));
      const _ = (d - l[f]) / m
        , y = f < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup;
      if (h > s.longSwipesMs) {
          if (!s.longSwipes)
              return void t.slideTo(t.activeIndex);
          "next" === t.swipeDirection && (_ >= s.longSwipesRatio ? t.slideTo(s.rewind && t.isEnd ? g : f + y) : t.slideTo(f)),
          "prev" === t.swipeDirection && (_ > 1 - s.longSwipesRatio ? t.slideTo(f + y) : null !== v && _ < 0 && Math.abs(_) > s.longSwipesRatio ? t.slideTo(v) : t.slideTo(f))
      } else {
          if (!s.shortSwipes)
              return void t.slideTo(t.activeIndex);
          !t.navigation || r.target !== t.navigation.nextEl && r.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(null !== g ? g : f + y),
          "prev" === t.swipeDirection && t.slideTo(null !== v ? v : f)) : r.target === t.navigation.nextEl ? t.slideTo(f + y) : t.slideTo(f)
      }
  }
  function Rc() {
      const e = this
        , {params: t, el: i} = e;
      if (i && 0 === i.offsetWidth)
          return;
      t.breakpoints && e.setBreakpoint();
      const {allowSlideNext: n, allowSlidePrev: r, snapGrid: s} = e
        , a = e.virtual && e.params.virtual.enabled;
      e.allowSlideNext = !0,
      e.allowSlidePrev = !0,
      e.updateSize(),
      e.updateSlides(),
      e.updateSlidesClasses();
      const o = a && t.loop;
      !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || o ? e.params.loop && !a ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0),
      e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout),
      e.autoplay.resizeTimeout = setTimeout(( () => {
          e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
      }
      ), 500)),
      e.allowSlidePrev = r,
      e.allowSlideNext = n,
      e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow()
  }
  function Lc(e) {
      const t = this;
      t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(),
      t.params.preventClicksPropagation && t.animating && (e.stopPropagation(),
      e.stopImmediatePropagation())))
  }
  function Ic() {
      const e = this
        , {wrapperEl: t, rtlTranslate: i, enabled: n} = e;
      if (!n)
          return;
      let r;
      e.previousTranslate = e.translate,
      e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop,
      0 === e.translate && (e.translate = 0),
      e.updateActiveIndex(),
      e.updateSlidesClasses();
      const s = e.maxTranslate() - e.minTranslate();
      r = 0 === s ? 0 : (e.translate - e.minTranslate()) / s,
      r !== e.progress && e.updateProgress(i ? -e.translate : e.translate),
      e.emit("setTranslate", e.translate, !1)
  }
  function Nc(e) {
      const t = this;
      yc(t, e.target),
      t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update()
  }
  function Fc() {
      const e = this;
      e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0,
      e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"))
  }
  const Oc = (e, t) => {
      const i = Zl()
        , {params: n, el: r, wrapperEl: s, device: a} = e
        , o = !!n.nested
        , l = "on" === t ? "addEventListener" : "removeEventListener"
        , c = t;
      r && "string" != typeof r && (i[l]("touchstart", e.onDocumentTouchStart, {
          passive: !1,
          capture: o
      }),
      r[l]("touchstart", e.onTouchStart, {
          passive: !1
      }),
      r[l]("pointerdown", e.onTouchStart, {
          passive: !1
      }),
      i[l]("touchmove", e.onTouchMove, {
          passive: !1,
          capture: o
      }),
      i[l]("pointermove", e.onTouchMove, {
          passive: !1,
          capture: o
      }),
      i[l]("touchend", e.onTouchEnd, {
          passive: !0
      }),
      i[l]("pointerup", e.onTouchEnd, {
          passive: !0
      }),
      i[l]("pointercancel", e.onTouchEnd, {
          passive: !0
      }),
      i[l]("touchcancel", e.onTouchEnd, {
          passive: !0
      }),
      i[l]("pointerout", e.onTouchEnd, {
          passive: !0
      }),
      i[l]("pointerleave", e.onTouchEnd, {
          passive: !0
      }),
      i[l]("contextmenu", e.onTouchEnd, {
          passive: !0
      }),
      (n.preventClicks || n.preventClicksPropagation) && r[l]("click", e.onClick, !0),
      n.cssMode && s[l]("scroll", e.onScroll),
      n.updateOnWindowResize ? e[c](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Rc, !0) : e[c]("observerUpdate", Rc, !0),
      r[l]("load", e.onLoad, {
          capture: !0
      }))
  }
    , Uc = (e, t) => e.grid && t.grid && t.grid.rows > 1;
  var Bc = {
      init: !0,
      direction: "horizontal",
      oneWayMovement: !1,
      swiperElementNodeName: "SWIPER-CONTAINER",
      touchEventsTarget: "wrapper",
      initialSlide: 0,
      speed: 300,
      cssMode: !1,
      updateOnWindowResize: !0,
      resizeObserver: !0,
      nested: !1,
      createElements: !1,
      eventsPrefix: "swiper",
      enabled: !0,
      focusableElements: "input, select, option, textarea, button, video, label",
      width: null,
      height: null,
      preventInteractionOnTransition: !1,
      userAgent: null,
      url: null,
      edgeSwipeDetection: !1,
      edgeSwipeThreshold: 20,
      autoHeight: !1,
      setWrapperSize: !1,
      virtualTranslate: !1,
      effect: "slide",
      breakpoints: void 0,
      breakpointsBase: "window",
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: !1,
      centeredSlides: !1,
      centeredSlidesBounds: !1,
      slidesOffsetBefore: 0,
      slidesOffsetAfter: 0,
      normalizeSlideIndex: !0,
      centerInsufficientSlides: !1,
      watchOverflow: !0,
      roundLengths: !1,
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: !0,
      shortSwipes: !0,
      longSwipes: !0,
      longSwipesRatio: .5,
      longSwipesMs: 300,
      followFinger: !0,
      allowTouchMove: !0,
      threshold: 5,
      touchMoveStopPropagation: !1,
      touchStartPreventDefault: !0,
      touchStartForcePreventDefault: !1,
      touchReleaseOnEdges: !1,
      uniqueNavElements: !0,
      resistance: !0,
      resistanceRatio: .85,
      watchSlidesProgress: !1,
      grabCursor: !1,
      preventClicks: !0,
      preventClicksPropagation: !0,
      slideToClickedSlide: !1,
      loop: !1,
      loopAddBlankSlides: !0,
      loopAdditionalSlides: 0,
      loopPreventsSliding: !0,
      rewind: !1,
      allowSlidePrev: !0,
      allowSlideNext: !0,
      swipeHandler: null,
      noSwiping: !0,
      noSwipingClass: "swiper-no-swiping",
      noSwipingSelector: null,
      passiveListeners: !0,
      maxBackfaceHiddenSlides: 10,
      containerModifierClass: "swiper-",
      slideClass: "swiper-slide",
      slideBlankClass: "swiper-slide-blank",
      slideActiveClass: "swiper-slide-active",
      slideVisibleClass: "swiper-slide-visible",
      slideFullyVisibleClass: "swiper-slide-fully-visible",
      slideNextClass: "swiper-slide-next",
      slidePrevClass: "swiper-slide-prev",
      wrapperClass: "swiper-wrapper",
      lazyPreloaderClass: "swiper-lazy-preloader",
      lazyPreloadPrevNext: 0,
      runCallbacksOnInit: !0,
      _emitClasses: !1
  };
  function zc(e, t) {
      return function(i) {
          void 0 === i && (i = {});
          const n = Object.keys(i)[0]
            , r = i[n];
          "object" == typeof r && null !== r ? (!0 === e[n] && (e[n] = {
              enabled: !0
          }),
          "navigation" === n && e[n] && e[n].enabled && !e[n].prevEl && !e[n].nextEl && (e[n].auto = !0),
          ["pagination", "scrollbar"].indexOf(n) >= 0 && e[n] && e[n].enabled && !e[n].el && (e[n].auto = !0),
          n in e && "enabled"in r ? ("object" != typeof e[n] || "enabled"in e[n] || (e[n].enabled = !0),
          e[n] || (e[n] = {
              enabled: !1
          }),
          ic(t, i)) : ic(t, i)) : ic(t, i)
      }
  }
  const kc = {
      eventsEmitter: gc,
      update: Ec,
      translate: Mc,
      transition: {
          setTransition: function(e, t) {
              const i = this;
              i.params.cssMode || (i.wrapperEl.style.transitionDuration = `${e}ms`,
              i.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""),
              i.emit("setTransition", e, t)
          },
          transitionStart: function(e, t) {
              void 0 === e && (e = !0);
              const i = this
                , {params: n} = i;
              n.cssMode || (n.autoHeight && i.updateAutoHeight(),
              bc({
                  swiper: i,
                  runCallbacks: e,
                  direction: t,
                  step: "Start"
              }))
          },
          transitionEnd: function(e, t) {
              void 0 === e && (e = !0);
              const i = this
                , {params: n} = i;
              i.animating = !1,
              n.cssMode || (i.setTransition(0),
              bc({
                  swiper: i,
                  runCallbacks: e,
                  direction: t,
                  step: "End"
              }))
          }
      },
      slide: Tc,
      loop: wc,
      grabCursor: {
          setGrabCursor: function(e) {
              const t = this;
              if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)
                  return;
              const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
              t.isElement && (t.__preventObserver__ = !0),
              i.style.cursor = "move",
              i.style.cursor = e ? "grabbing" : "grab",
              t.isElement && requestAnimationFrame(( () => {
                  t.__preventObserver__ = !1
              }
              ))
          },
          unsetGrabCursor: function() {
              const e = this;
              e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0),
              e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "",
              e.isElement && requestAnimationFrame(( () => {
                  e.__preventObserver__ = !1
              }
              )))
          }
      },
      events: {
          attachEvents: function() {
              const e = this
                , {params: t} = e;
              e.onTouchStart = Cc.bind(e),
              e.onTouchMove = Ac.bind(e),
              e.onTouchEnd = Pc.bind(e),
              e.onDocumentTouchStart = Fc.bind(e),
              t.cssMode && (e.onScroll = Ic.bind(e)),
              e.onClick = Lc.bind(e),
              e.onLoad = Nc.bind(e),
              Oc(e, "on")
          },
          detachEvents: function() {
              Oc(this, "off")
          }
      },
      breakpoints: {
          setBreakpoint: function() {
              const e = this
                , {realIndex: t, initialized: i, params: n, el: r} = e
                , s = n.breakpoints;
              if (!s || s && 0 === Object.keys(s).length)
                  return;
              const a = e.getBreakpoint(s, e.params.breakpointsBase, e.el);
              if (!a || e.currentBreakpoint === a)
                  return;
              const o = (a in s ? s[a] : void 0) || e.originalParams
                , l = Uc(e, n)
                , c = Uc(e, o)
                , u = e.params.grabCursor
                , h = o.grabCursor
                , d = n.enabled;
              l && !c ? (r.classList.remove(`${n.containerModifierClass}grid`, `${n.containerModifierClass}grid-column`),
              e.emitContainerClasses()) : !l && c && (r.classList.add(`${n.containerModifierClass}grid`),
              (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === n.grid.fill) && r.classList.add(`${n.containerModifierClass}grid-column`),
              e.emitContainerClasses()),
              u && !h ? e.unsetGrabCursor() : !u && h && e.setGrabCursor(),
              ["navigation", "pagination", "scrollbar"].forEach((t => {
                  if (void 0 === o[t])
                      return;
                  const i = n[t] && n[t].enabled
                    , r = o[t] && o[t].enabled;
                  i && !r && e[t].disable(),
                  !i && r && e[t].enable()
              }
              ));
              const p = o.direction && o.direction !== n.direction
                , f = n.loop && (o.slidesPerView !== n.slidesPerView || p)
                , m = n.loop;
              p && i && e.changeDirection(),
              ic(e.params, o);
              const g = e.params.enabled
                , v = e.params.loop;
              Object.assign(e, {
                  allowTouchMove: e.params.allowTouchMove,
                  allowSlideNext: e.params.allowSlideNext,
                  allowSlidePrev: e.params.allowSlidePrev
              }),
              d && !g ? e.disable() : !d && g && e.enable(),
              e.currentBreakpoint = a,
              e.emit("_beforeBreakpoint", o),
              i && (f ? (e.loopDestroy(),
              e.loopCreate(t),
              e.updateSlides()) : !m && v ? (e.loopCreate(t),
              e.updateSlides()) : m && !v && e.loopDestroy()),
              e.emit("breakpoint", o)
          },
          getBreakpoint: function(e, t, i) {
              if (void 0 === t && (t = "window"),
              !e || "container" === t && !i)
                  return;
              let n = !1;
              const r = Jl()
                , s = "window" === t ? r.innerHeight : i.clientHeight
                , a = Object.keys(e).map((e => {
                  if ("string" == typeof e && 0 === e.indexOf("@")) {
                      const t = parseFloat(e.substr(1));
                      return {
                          value: s * t,
                          point: e
                      }
                  }
                  return {
                      value: e,
                      point: e
                  }
              }
              ));
              a.sort(( (e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
              for (let e = 0; e < a.length; e += 1) {
                  const {point: s, value: o} = a[e];
                  "window" === t ? r.matchMedia(`(min-width: ${o}px)`).matches && (n = s) : o <= i.clientWidth && (n = s)
              }
              return n || "max"
          }
      },
      checkOverflow: {
          checkOverflow: function() {
              const e = this
                , {isLocked: t, params: i} = e
                , {slidesOffsetBefore: n} = i;
              if (n) {
                  const t = e.slides.length - 1
                    , i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * n;
                  e.isLocked = e.size > i
              } else
                  e.isLocked = 1 === e.snapGrid.length;
              !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked),
              !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked),
              t && t !== e.isLocked && (e.isEnd = !1),
              t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
          }
      },
      classes: {
          addClasses: function() {
              const e = this
                , {classNames: t, params: i, rtl: n, el: r, device: s} = e
                , a = function(e, t) {
                  const i = [];
                  return e.forEach((e => {
                      "object" == typeof e ? Object.keys(e).forEach((n => {
                          e[n] && i.push(t + n)
                      }
                      )) : "string" == typeof e && i.push(t + e)
                  }
                  )),
                  i
              }(["initialized", i.direction, {
                  "free-mode": e.params.freeMode && i.freeMode.enabled
              }, {
                  autoheight: i.autoHeight
              }, {
                  rtl: n
              }, {
                  grid: i.grid && i.grid.rows > 1
              }, {
                  "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill
              }, {
                  android: s.android
              }, {
                  ios: s.ios
              }, {
                  "css-mode": i.cssMode
              }, {
                  centered: i.cssMode && i.centeredSlides
              }, {
                  "watch-progress": i.watchSlidesProgress
              }], i.containerModifierClass);
              t.push(...a),
              r.classList.add(...t),
              e.emitContainerClasses()
          },
          removeClasses: function() {
              const {el: e, classNames: t} = this;
              e && "string" != typeof e && (e.classList.remove(...t),
              this.emitContainerClasses())
          }
      }
  }
    , Vc = {};
  class Hc {
      constructor() {
          let e, t;
          for (var i = arguments.length, n = new Array(i), r = 0; r < i; r++)
              n[r] = arguments[r];
          1 === n.length && n[0].constructor && "Object" === Object.prototype.toString.call(n[0]).slice(8, -1) ? t = n[0] : [e,t] = n,
          t || (t = {}),
          t = ic({}, t),
          e && !t.el && (t.el = e);
          const s = Zl();
          if (t.el && "string" == typeof t.el && s.querySelectorAll(t.el).length > 1) {
              const e = [];
              return s.querySelectorAll(t.el).forEach((i => {
                  const n = ic({}, t, {
                      el: i
                  });
                  e.push(new Hc(n))
              }
              )),
              e
          }
          const a = this;
          a.__swiper__ = !0,
          a.support = fc(),
          a.device = mc({
              userAgent: t.userAgent
          }),
          a.browser = (pc || (pc = function() {
              const e = Jl()
                , t = mc();
              let i = !1;
              function n() {
                  const t = e.navigator.userAgent.toLowerCase();
                  return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
              }
              if (n()) {
                  const t = String(e.navigator.userAgent);
                  if (t.includes("Version/")) {
                      const [e,n] = t.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e)));
                      i = e < 16 || 16 === e && n < 2
                  }
              }
              const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
                , s = n();
              return {
                  isSafari: i || s,
                  needPerspectiveFix: i,
                  need3dFix: s || r && t.ios,
                  isWebView: r
              }
          }()),
          pc),
          a.eventsListeners = {},
          a.eventsAnyListeners = [],
          a.modules = [...a.__modules__],
          t.modules && Array.isArray(t.modules) && a.modules.push(...t.modules);
          const o = {};
          a.modules.forEach((e => {
              e({
                  params: t,
                  swiper: a,
                  extendParams: zc(t, o),
                  on: a.on.bind(a),
                  once: a.once.bind(a),
                  off: a.off.bind(a),
                  emit: a.emit.bind(a)
              })
          }
          ));
          const l = ic({}, Bc, o);
          return a.params = ic({}, l, Vc, t),
          a.originalParams = ic({}, a.params),
          a.passedParams = ic({}, t),
          a.params && a.params.on && Object.keys(a.params.on).forEach((e => {
              a.on(e, a.params.on[e])
          }
          )),
          a.params && a.params.onAny && a.onAny(a.params.onAny),
          Object.assign(a, {
              enabled: a.params.enabled,
              el: e,
              classNames: [],
              slides: [],
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              isHorizontal: () => "horizontal" === a.params.direction,
              isVertical: () => "vertical" === a.params.direction,
              activeIndex: 0,
              realIndex: 0,
              isBeginning: !0,
              isEnd: !1,
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: !1,
              cssOverflowAdjustment() {
                  return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
              },
              allowSlideNext: a.params.allowSlideNext,
              allowSlidePrev: a.params.allowSlidePrev,
              touchEventsData: {
                  isTouched: void 0,
                  isMoved: void 0,
                  allowTouchCallbacks: void 0,
                  touchStartTime: void 0,
                  isScrolling: void 0,
                  currentTranslate: void 0,
                  startTranslate: void 0,
                  allowThresholdMove: void 0,
                  focusableElements: a.params.focusableElements,
                  lastClickTime: 0,
                  clickTimeout: void 0,
                  velocities: [],
                  allowMomentumBounce: void 0,
                  startMoving: void 0,
                  pointerId: null,
                  touchId: null
              },
              allowClick: !0,
              allowTouchMove: a.params.allowTouchMove,
              touches: {
                  startX: 0,
                  startY: 0,
                  currentX: 0,
                  currentY: 0,
                  diff: 0
              },
              imagesToLoad: [],
              imagesLoaded: 0
          }),
          a.emit("_swiper"),
          a.params.init && a.init(),
          a
      }
      getDirectionLabel(e) {
          return this.isHorizontal() ? e : {
              width: "height",
              "margin-top": "margin-left",
              "margin-bottom ": "margin-right",
              "margin-left": "margin-top",
              "margin-right": "margin-bottom",
              "padding-left": "padding-top",
              "padding-right": "padding-bottom",
              marginRight: "marginBottom"
          }[e]
      }
      getSlideIndex(e) {
          const {slidesEl: t, params: i} = this
            , n = cc(sc(t, `.${i.slideClass}, swiper-slide`)[0]);
          return cc(e) - n
      }
      getSlideIndexByData(e) {
          return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0])
      }
      recalcSlides() {
          const {slidesEl: e, params: t} = this;
          this.slides = sc(e, `.${t.slideClass}, swiper-slide`)
      }
      enable() {
          const e = this;
          e.enabled || (e.enabled = !0,
          e.params.grabCursor && e.setGrabCursor(),
          e.emit("enable"))
      }
      disable() {
          const e = this;
          e.enabled && (e.enabled = !1,
          e.params.grabCursor && e.unsetGrabCursor(),
          e.emit("disable"))
      }
      setProgress(e, t) {
          const i = this;
          e = Math.min(Math.max(e, 0), 1);
          const n = i.minTranslate()
            , r = (i.maxTranslate() - n) * e + n;
          i.translateTo(r, void 0 === t ? 0 : t),
          i.updateActiveIndex(),
          i.updateSlidesClasses()
      }
      emitContainerClasses() {
          const e = this;
          if (!e.params._emitClasses || !e.el)
              return;
          const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
          e.emit("_containerClasses", t.join(" "))
      }
      getSlideClasses(e) {
          const t = this;
          return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
      }
      emitSlidesClasses() {
          const e = this;
          if (!e.params._emitClasses || !e.el)
              return;
          const t = [];
          e.slides.forEach((i => {
              const n = e.getSlideClasses(i);
              t.push({
                  slideEl: i,
                  classNames: n
              }),
              e.emit("_slideClass", i, n)
          }
          )),
          e.emit("_slideClasses", t)
      }
      slidesPerViewDynamic(e, t) {
          void 0 === e && (e = "current"),
          void 0 === t && (t = !1);
          const {params: i, slides: n, slidesGrid: r, slidesSizesGrid: s, size: a, activeIndex: o} = this;
          let l = 1;
          if ("number" == typeof i.slidesPerView)
              return i.slidesPerView;
          if (i.centeredSlides) {
              let e, t = n[o] ? Math.ceil(n[o].swiperSlideSize) : 0;
              for (let i = o + 1; i < n.length; i += 1)
                  n[i] && !e && (t += Math.ceil(n[i].swiperSlideSize),
                  l += 1,
                  t > a && (e = !0));
              for (let i = o - 1; i >= 0; i -= 1)
                  n[i] && !e && (t += n[i].swiperSlideSize,
                  l += 1,
                  t > a && (e = !0))
          } else if ("current" === e)
              for (let e = o + 1; e < n.length; e += 1)
                  (t ? r[e] + s[e] - r[o] < a : r[e] - r[o] < a) && (l += 1);
          else
              for (let e = o - 1; e >= 0; e -= 1)
                  r[o] - r[e] < a && (l += 1);
          return l
      }
      update() {
          const e = this;
          if (!e || e.destroyed)
              return;
          const {snapGrid: t, params: i} = e;
          function n() {
              const t = e.rtlTranslate ? -1 * e.translate : e.translate
                , i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
              e.setTranslate(i),
              e.updateActiveIndex(),
              e.updateSlidesClasses()
          }
          let r;
          if (i.breakpoints && e.setBreakpoint(),
          [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => {
              t.complete && yc(e, t)
          }
          )),
          e.updateSize(),
          e.updateSlides(),
          e.updateProgress(),
          e.updateSlidesClasses(),
          i.freeMode && i.freeMode.enabled && !i.cssMode)
              n(),
              i.autoHeight && e.updateAutoHeight();
          else {
              if (("auto" === i.slidesPerView || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
                  const t = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
                  r = e.slideTo(t.length - 1, 0, !1, !0)
              } else
                  r = e.slideTo(e.activeIndex, 0, !1, !0);
              r || n()
          }
          i.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
          e.emit("update")
      }
      changeDirection(e, t) {
          void 0 === t && (t = !0);
          const i = this
            , n = i.params.direction;
          return e || (e = "horizontal" === n ? "vertical" : "horizontal"),
          e === n || "horizontal" !== e && "vertical" !== e || (i.el.classList.remove(`${i.params.containerModifierClass}${n}`),
          i.el.classList.add(`${i.params.containerModifierClass}${e}`),
          i.emitContainerClasses(),
          i.params.direction = e,
          i.slides.forEach((t => {
              "vertical" === e ? t.style.width = "" : t.style.height = ""
          }
          )),
          i.emit("changeDirection"),
          t && i.update()),
          i
      }
      changeLanguageDirection(e) {
          const t = this;
          t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e,
          t.rtlTranslate = "horizontal" === t.params.direction && t.rtl,
          t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`),
          t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`),
          t.el.dir = "ltr"),
          t.update())
      }
      mount(e) {
          const t = this;
          if (t.mounted)
              return !0;
          let i = e || t.params.el;
          if ("string" == typeof i && (i = document.querySelector(i)),
          !i)
              return !1;
          i.swiper = t,
          i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
          const n = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
          let r = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(n()) : sc(i, n())[0];
          return !r && t.params.createElements && (r = oc("div", t.params.wrapperClass),
          i.append(r),
          sc(i, `.${t.params.slideClass}`).forEach((e => {
              r.append(e)
          }
          ))),
          Object.assign(t, {
              el: i,
              wrapperEl: r,
              slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : r,
              hostEl: t.isElement ? i.parentNode.host : i,
              mounted: !0,
              rtl: "rtl" === i.dir.toLowerCase() || "rtl" === lc(i, "direction"),
              rtlTranslate: "horizontal" === t.params.direction && ("rtl" === i.dir.toLowerCase() || "rtl" === lc(i, "direction")),
              wrongRTL: "-webkit-box" === lc(r, "display")
          }),
          !0
      }
      init(e) {
          const t = this;
          if (t.initialized)
              return t;
          if (!1 === t.mount(e))
              return t;
          t.emit("beforeInit"),
          t.params.breakpoints && t.setBreakpoint(),
          t.addClasses(),
          t.updateSize(),
          t.updateSlides(),
          t.params.watchOverflow && t.checkOverflow(),
          t.params.grabCursor && t.enabled && t.setGrabCursor(),
          t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0),
          t.params.loop && t.loopCreate(),
          t.attachEvents();
          const i = [...t.el.querySelectorAll('[loading="lazy"]')];
          return t.isElement && i.push(...t.hostEl.querySelectorAll('[loading="lazy"]')),
          i.forEach((e => {
              e.complete ? yc(t, e) : e.addEventListener("load", (e => {
                  yc(t, e.target)
              }
              ))
          }
          )),
          Sc(t),
          t.initialized = !0,
          Sc(t),
          t.emit("init"),
          t.emit("afterInit"),
          t
      }
      destroy(e, t) {
          void 0 === e && (e = !0),
          void 0 === t && (t = !0);
          const i = this
            , {params: n, el: r, wrapperEl: s, slides: a} = i;
          return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"),
          i.initialized = !1,
          i.detachEvents(),
          n.loop && i.loopDestroy(),
          t && (i.removeClasses(),
          r && "string" != typeof r && r.removeAttribute("style"),
          s && s.removeAttribute("style"),
          a && a.length && a.forEach((e => {
              e.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass),
              e.removeAttribute("style"),
              e.removeAttribute("data-swiper-slide-index")
          }
          ))),
          i.emit("destroy"),
          Object.keys(i.eventsListeners).forEach((e => {
              i.off(e)
          }
          )),
          !1 !== e && (i.el && "string" != typeof i.el && (i.el.swiper = null),
          function(e) {
              const t = e;
              Object.keys(t).forEach((e => {
                  try {
                      t[e] = null
                  } catch (e) {}
                  try {
                      delete t[e]
                  } catch (e) {}
              }
              ))
          }(i)),
          i.destroyed = !0),
          null
      }
      static extendDefaults(e) {
          ic(Vc, e)
      }
      static get extendedDefaults() {
          return Vc
      }
      static get defaults() {
          return Bc
      }
      static installModule(e) {
          Hc.prototype.__modules__ || (Hc.prototype.__modules__ = []);
          const t = Hc.prototype.__modules__;
          "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
      }
      static use(e) {
          return Array.isArray(e) ? (e.forEach((e => Hc.installModule(e))),
          Hc) : (Hc.installModule(e),
          Hc)
      }
  }
  function Gc() {
      return Gc = Object.assign || function(e) {
          for (var t = 1; t < arguments.length; t++) {
              var i = arguments[t];
              for (var n in i)
                  Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
          }
          return e
      }
      ,
      Gc.apply(this, arguments)
  }
  function Wc(e, t) {
      e.prototype = Object.create(t.prototype),
      e.prototype.constructor = e,
      Xc(e, t)
  }
  function Xc(e, t) {
      return Xc = Object.setPrototypeOf || function(e, t) {
          return e.__proto__ = t,
          e
      }
      ,
      Xc(e, t)
  }
  Object.keys(kc).forEach((e => {
      Object.keys(kc[e]).forEach((t => {
          Hc.prototype[t] = kc[e][t]
      }
      ))
  }
  )),
  Hc.use([function(e) {
      let {swiper: t, on: i, emit: n} = e;
      const r = Jl();
      let s = null
        , a = null;
      const o = () => {
          t && !t.destroyed && t.initialized && (n("beforeResize"),
          n("resize"))
      }
        , l = () => {
          t && !t.destroyed && t.initialized && n("orientationchange")
      }
      ;
      i("init", ( () => {
          t.params.resizeObserver && void 0 !== r.ResizeObserver ? t && !t.destroyed && t.initialized && (s = new ResizeObserver((e => {
              a = r.requestAnimationFrame(( () => {
                  const {width: i, height: n} = t;
                  let r = i
                    , s = n;
                  e.forEach((e => {
                      let {contentBoxSize: i, contentRect: n, target: a} = e;
                      a && a !== t.el || (r = n ? n.width : (i[0] || i).inlineSize,
                      s = n ? n.height : (i[0] || i).blockSize)
                  }
                  )),
                  r === i && s === n || o()
              }
              ))
          }
          )),
          s.observe(t.el)) : (r.addEventListener("resize", o),
          r.addEventListener("orientationchange", l))
      }
      )),
      i("destroy", ( () => {
          a && r.cancelAnimationFrame(a),
          s && s.unobserve && t.el && (s.unobserve(t.el),
          s = null),
          r.removeEventListener("resize", o),
          r.removeEventListener("orientationchange", l)
      }
      ))
  }
  , function(e) {
      let {swiper: t, extendParams: i, on: n, emit: r} = e;
      const s = []
        , a = Jl()
        , o = function(e, i) {
          void 0 === i && (i = {});
          const n = new (a.MutationObserver || a.WebkitMutationObserver)((e => {
              if (t.__preventObserver__)
                  return;
              if (1 === e.length)
                  return void r("observerUpdate", e[0]);
              const i = function() {
                  r("observerUpdate", e[0])
              };
              a.requestAnimationFrame ? a.requestAnimationFrame(i) : a.setTimeout(i, 0)
          }
          ));
          n.observe(e, {
              attributes: void 0 === i.attributes || i.attributes,
              childList: t.isElement || (void 0 === i.childList || i).childList,
              characterData: void 0 === i.characterData || i.characterData
          }),
          s.push(n)
      };
      i({
          observer: !1,
          observeParents: !1,
          observeSlideChildren: !1
      }),
      n("init", ( () => {
          if (t.params.observer) {
              if (t.params.observeParents) {
                  const e = function(e, t) {
                      const i = [];
                      let n = e.parentElement;
                      for (; n; )
                          i.push(n),
                          n = n.parentElement;
                      return i
                  }(t.hostEl);
                  for (let t = 0; t < e.length; t += 1)
                      o(e[t])
              }
              o(t.hostEl, {
                  childList: t.params.observeSlideChildren
              }),
              o(t.wrapperEl, {
                  attributes: !1
              })
          }
      }
      )),
      n("destroy", ( () => {
          s.forEach((e => {
              e.disconnect()
          }
          )),
          s.splice(0, s.length)
      }
      ))
  }
  ]);
  var qc = function() {
      function e() {
          this.events = {}
      }
      var t = e.prototype;
      return t.on = function(e, t) {
          this.events[e]instanceof Array || (this.events[e] = []),
          this.events[e].push(t)
      }
      ,
      t.off = function(e, t) {
          this.events[e] = t ? this.events[e].filter((function(e) {
              return e !== t
          }
          )) : []
      }
      ,
      t.trigger = function(e) {
          var t = arguments
            , i = this;
          this.events[e] && this.events[e].forEach((function(e) {
              return e.call.apply(e, [i, i].concat([].slice.call(t, 1)))
          }
          ))
      }
      ,
      e
  }()
    , jc = function(e) {
      function t(i) {
          var n;
          return (n = e.call(this) || this).options = Gc({}, t.defaultOptions, i),
          n.container = "string" == typeof n.options.container ? document.querySelector(n.options.container) : n.options.container,
          n.wrapper = "string" == typeof n.options.wrapper ? n.container.querySelector(n.options.wrapper) : n.options.wrapper || n.options.container,
          n.item = [],
          n.refresh(!1),
          n.options.autoUpdate ? n.bindResizeObserver() : n.update(),
          n
      }
      Wc(t, e);
      var i = t.prototype;
      return i.bindResizeObserver = function() {
          var e = this;
          this.resizeObserver = new ResizeObserver((function() {
              e.update()
          }
          )),
          this.resizeObserver.observe(this.container)
      }
      ,
      i.addClones = function(e, t) {
          var i;
          void 0 === t && (t = 0);
          for (var n = [], r = 0; r < e; r++) {
              var s = this.item[(t + r) % this.item.length].cloneNode(!0);
              s.classList.add(this.options.cloneClassName),
              n.push(s)
          }
          (i = this.wrapper).append.apply(i, n)
      }
      ,
      i.removeClones = function(e) {
          void 0 === e && (e = 0),
          Array.from(this.wrapper.getElementsByClassName(this.options.cloneClassName)).slice(-e).forEach((function(e) {
              return e.remove()
          }
          ))
      }
      ,
      i.setClonesCount = function(e) {
          this.clonesCount !== e && (this.clonesCount < e && this.addClones(e - this.clonesCount, this.clonesCount),
          this.clonesCount > e && this.removeClones(this.clonesCount - e),
          this.clonesCount = e)
      }
      ,
      i.getCalcData = function() {
          var e = {
              clonesCount: 0,
              clonesWidth: 0,
              containerWidth: this.container.offsetWidth,
              fullWidth: 0,
              itemWidth: [],
              itemsWidth: 0,
              lastIndex: 0
          };
          this.item.map((function(t) {
              var i = window.getComputedStyle(t)
                , n = t.offsetWidth + parseInt(i.marginLeft) + parseInt(i.marginRight);
              e.itemWidth.push(n),
              e.itemsWidth += n
          }
          ));
          for (var t = e.itemWidth.length, i = this.options.clonesOverflow ? e.containerWidth : e.containerWidth - e.itemsWidth; i > e.clonesWidth || e.clonesCount < this.options.clonesMin || this.options.clonesFinish && e.clonesCount % t > 0; )
              e.lastIndex = e.clonesCount % t,
              e.clonesWidth += e.itemWidth[e.lastIndex],
              e.clonesCount++;
          return e.fullWidth = e.clonesWidth + e.itemsWidth,
          e
      }
      ,
      i.update = function() {
          this.calcData = this.getCalcData(),
          this.setClonesCount(this.calcData.clonesCount),
          this.trigger("update", this.calcData)
      }
      ,
      i.refresh = function(e) {
          void 0 === e && (e = !0),
          this.removeClones(),
          this.item = Array.from(this.container.querySelectorAll(this.options.itemSelector)),
          this.calcData = {},
          this.clonesCount = 0,
          this.trigger("refresh"),
          e && this.update()
      }
      ,
      i.destroy = function(e) {
          void 0 === e && (e = !1),
          e && this.removeClones(),
          this.resizeObserver && this.resizeObserver.disconnect(),
          this.trigger("destroy")
      }
      ,
      t
  }(qc);
  jc.defaultOptions = {
      container: null,
      wrapper: null,
      itemSelector: null,
      cloneClassName: "-clone",
      autoUpdate: !0,
      clonesOverflow: !1,
      clonesFinish: !1,
      clonesMin: 0
  };
  var Yc = function(e) {
      function t(i) {
          var n;
          return (n = e.call(this) || this).options = Gc({}, t.defaultOptions, i),
          n.gsap = t.gsap || window.gsap,
          n.paused = n.options.paused,
          n.createFiller(),
          n.createTimeline(),
          n.options.autoStop && n.bindIntersectionObserver(),
          n.options.plugins && n.initPlugins(),
          n
      }
      Wc(t, e),
      t.registerGSAP = function(e) {
          t.gsap = e
      }
      ,
      t.use = function() {
          [].slice.call(arguments).forEach((function(e) {
              var i = e.pluginName;
              if ("string" != typeof i)
                  throw new TypeError("Invalid plugin. Name is required.");
              t.plugins[i] = e
          }
          ))
      }
      ;
      var i = t.prototype;
      return i.createFiller = function() {
          var e = this;
          this.filler = new jc(this.options),
          this.filler.on("update", (function(t, i) {
              e.invalidate(),
              e.trigger("update", i)
          }
          )),
          this.filler.on("refresh", (function() {
              e.trigger("refresh")
          }
          ))
      }
      ,
      i.createTimeline = function() {
          var e = this;
          return this.tl = new this.gsap.timeline({
              paused: this.options.paused,
              reversed: this.options.reversed,
              repeat: -1,
              yoyo: !this.options.loop,
              onReverseComplete: function() {
                  this.progress(1)
              }
          }),
          this.gsap.set(this.filler.container, {
              overflow: "hidden"
          }),
          this.tl.fromTo(this.filler.wrapper, {
              x: function() {
                  return e.options.clonesOverflow ? -e.filler.calcData.itemsWidth : -(e.filler.calcData.fullWidth - e.filler.calcData.containerWidth)
              }
          }, {
              x: 0,
              duration: this.options.speed,
              ease: this.options.ease
          }),
          this.tl.seek(this.options.seek),
          this.tl
      }
      ,
      i.bindIntersectionObserver = function() {
          var e = this;
          this.intersectionObserver = new IntersectionObserver((function(t) {
              t[0].isIntersecting ? e.resume() : e.pause()
          }
          )),
          this.intersectionObserver.observe(this.filler.container)
      }
      ,
      i.initPlugins = function() {
          this.plugin = {};
          for (var e = 0, i = Object.entries(this.options.plugins); e < i.length; e++) {
              var n = i[e]
                , r = n[0]
                , s = n[1]
                , a = t.plugins[r];
              a ? this.plugin[r] = new a(this,s) : console.error("Plugin " + r + " not found. Make sure you register it with Reeller.use()")
          }
      }
      ,
      i.destroyPlugins = function() {
          for (var e = 0, t = Object.values(this.plugin); e < t.length; e++) {
              var i = t[e];
              i.destroy && i.destroy()
          }
      }
      ,
      i.resume = function() {
          this.gsap.set(this.filler.container, {
              z: "0"
          }),
          this.gsap.set(this.filler.wrapper, {
              willChange: "transform"
          }),
          this.paused = !1,
          this.tl.resume(),
          this.trigger("resume")
      }
      ,
      i.reverse = function(e) {
          void 0 === e && (e = !0),
          this.tl.reversed(e),
          this.resume(),
          this.trigger("reverse", e)
      }
      ,
      i.pause = function() {
          this.gsap.set(this.filler.container, {
              clearProps: "z"
          }),
          this.gsap.set(this.filler.wrapper, {
              willChange: "auto"
          }),
          this.paused = !0,
          this.tl.pause(),
          this.trigger("pause")
      }
      ,
      i.invalidate = function() {
          this.tl.invalidate(),
          this.trigger("invalidate")
      }
      ,
      i.update = function() {
          this.filler.update()
      }
      ,
      i.refresh = function(e) {
          void 0 === e && (e = !0),
          this.filler.refresh(e)
      }
      ,
      i.destroy = function(e, t) {
          void 0 === e && (e = !1),
          void 0 === t && (t = !1),
          this.intersectionObserver && this.intersectionObserver.disconnect(),
          this.options.plugins && this.destroyPlugins(),
          this.tl.kill(),
          this.filler.destroy(e),
          t && (this.gsap.set(this.filler.container, {
              clearProps: "overflow"
          }),
          this.gsap.set(this.filler.wrapper, {
              clearProps: "x,willChange"
          })),
          this.trigger("destroy")
      }
      ,
      t
  }(qc);
  Yc.defaultOptions = {
      container: null,
      wrapper: null,
      itemSelector: null,
      cloneClassName: "-clone",
      speed: 10,
      ease: "none",
      initialSeek: 10,
      loop: !0,
      paused: !0,
      reversed: !1,
      autoStop: !0,
      autoUpdate: !0,
      clonesOverflow: !0,
      clonesFinish: !1,
      clonesMin: 0,
      plugins: null
  },
  Yc.plugins = {};
  var Kc = function() {
      function e(t, i) {
          this.options = Gc({}, e.defaultOptions, i),
          this.reeller = t,
          this.gsap = this.reeller.gsap,
          this.tl = this.reeller.tl,
          this.init()
      }
      var t = e.prototype;
      return t.getScrollPos = function() {
          return this.options.scrollProxy ? this.options.scrollProxy() : window.pageYOffset
      }
      ,
      t.init = function() {
          var e = this
            , t = this.getScrollPos()
            , i = 1
            , n = !0;
          this.tickerFn = function() {
              var r = e.getScrollPos()
                , s = r - t;
              if (e.options.bothDirection || (s = Math.abs(s)),
              e.options.reversed && (s *= -1),
              e.reeller.paused)
                  return i = Math.sign(s),
                  t = r,
                  n || (e.gsap.killTweensOf(e.tl),
                  n = !0),
                  void e.tl.timeScale(i * e.options.threshold);
              if (s) {
                  var a = s * e.options.multiplier
                    , o = a > 0 ? Math.max(e.options.threshold, a) : Math.min(-e.options.threshold, a);
                  e.tween = e.gsap.to(e.tl, {
                      timeScale: o,
                      duration: e.options.speed,
                      ease: e.options.ease,
                      overwrite: e.options.overwrite
                  }),
                  n = !1
              } else if (!n) {
                  var l = e.options.stopOnEnd ? 0 : i * e.options.threshold;
                  e.gsap.killTweensOf(e.tl),
                  e.tween = e.gsap.to(e.tl, {
                      timeScale: l,
                      duration: e.options.speed,
                      overwrite: e.options.overwrite,
                      ease: e.options.ease
                  }),
                  n = !0
              }
              i = Math.sign(s),
              t = r
          }
          ,
          this.gsap.ticker.add(this.tickerFn)
      }
      ,
      t.destroy = function() {
          this.tickerFn && (this.gsap.ticker.remove(this.tickerFn),
          this.tickerFn = null),
          this.tween && this.tween.kill()
      }
      ,
      e
  }();
  Kc.pluginName = "scroller",
  Kc.defaultOptions = {
      speed: 1,
      multiplier: .5,
      threshold: 1,
      ease: "expo.out",
      overwrite: !0,
      bothDirection: !0,
      reversed: !1,
      stopOnEnd: !1,
      scrollProxy: null
  },
  Yc.registerGSAP(jn),
  Yc.use(Kc),
  Hc.use([function(e) {
      let t, i, {swiper: n, extendParams: r, on: s, emit: a, params: o} = e;
      n.autoplay = {
          running: !1,
          paused: !1,
          timeLeft: 0
      },
      r({
          autoplay: {
              enabled: !1,
              delay: 39e3,
              waitForTransition: !0,
              disableOnInteraction: !1,
              stopOnLastSlide: !1,
              reverseDirection: !1,
              pauseOnMouseEnter: !1
          }
      });
      let l, c, u, h, d, p, f, m, g = o && o.autoplay ? o.autoplay.delay : 3e3, v = o && o.autoplay ? o.autoplay.delay : 3e3, _ = (new Date).getTime();
      function y(e) {
          n && !n.destroyed && n.wrapperEl && e.target === n.wrapperEl && (n.wrapperEl.removeEventListener("transitionend", y),
          m || e.detail && e.detail.bySwiperTouchMove || T())
      }
      const x = () => {
          if (n.destroyed || !n.autoplay.running)
              return;
          n.autoplay.paused ? c = !0 : c && (v = l,
          c = !1);
          const e = n.autoplay.paused ? l : _ + v - (new Date).getTime();
          n.autoplay.timeLeft = e,
          a("autoplayTimeLeft", e, e / g),
          i = requestAnimationFrame(( () => {
              x()
          }
          ))
      }
        , S = e => {
          if (n.destroyed || !n.autoplay.running)
              return;
          cancelAnimationFrame(i),
          x();
          let r = void 0 === e ? n.params.autoplay.delay : e;
          g = n.params.autoplay.delay,
          v = n.params.autoplay.delay;
          const s = ( () => {
              let e;
              if (e = n.virtual && n.params.virtual.enabled ? n.slides.filter((e => e.classList.contains("swiper-slide-active")))[0] : n.slides[n.activeIndex],
              e)
                  return parseInt(e.getAttribute("data-swiper-autoplay"), 10)
          }
          )();
          !Number.isNaN(s) && s > 0 && void 0 === e && (r = s,
          g = s,
          v = s),
          l = r;
          const o = n.params.speed
            , c = () => {
              n && !n.destroyed && (n.params.autoplay.reverseDirection ? !n.isBeginning || n.params.loop || n.params.rewind ? (n.slidePrev(o, !0, !0),
              a("autoplay")) : n.params.autoplay.stopOnLastSlide || (n.slideTo(n.slides.length - 1, o, !0, !0),
              a("autoplay")) : !n.isEnd || n.params.loop || n.params.rewind ? (n.slideNext(o, !0, !0),
              a("autoplay")) : n.params.autoplay.stopOnLastSlide || (n.slideTo(0, o, !0, !0),
              a("autoplay")),
              n.params.cssMode && (_ = (new Date).getTime(),
              requestAnimationFrame(( () => {
                  S()
              }
              ))))
          }
          ;
          return r > 0 ? (clearTimeout(t),
          t = setTimeout(( () => {
              c()
          }
          ), r)) : requestAnimationFrame(( () => {
              c()
          }
          )),
          r
      }
        , E = () => {
          _ = (new Date).getTime(),
          n.autoplay.running = !0,
          S(),
          a("autoplayStart")
      }
        , M = () => {
          n.autoplay.running = !1,
          clearTimeout(t),
          cancelAnimationFrame(i),
          a("autoplayStop")
      }
        , b = (e, i) => {
          if (n.destroyed || !n.autoplay.running)
              return;
          clearTimeout(t),
          e || (f = !0);
          const r = () => {
              a("autoplayPause"),
              n.params.autoplay.waitForTransition ? n.wrapperEl.addEventListener("transitionend", y) : T()
          }
          ;
          if (n.autoplay.paused = !0,
          i)
              return p && (l = n.params.autoplay.delay),
              p = !1,
              void r();
          const s = l || n.params.autoplay.delay;
          l = s - ((new Date).getTime() - _),
          n.isEnd && l < 0 && !n.params.loop || (l < 0 && (l = 0),
          r())
      }
        , T = () => {
          n.isEnd && l < 0 && !n.params.loop || n.destroyed || !n.autoplay.running || (_ = (new Date).getTime(),
          f ? (f = !1,
          S(l)) : S(),
          n.autoplay.paused = !1,
          a("autoplayResume"))
      }
        , w = () => {
          if (n.destroyed || !n.autoplay.running)
              return;
          const e = Zl();
          "hidden" === e.visibilityState && (f = !0,
          b(!0)),
          "visible" === e.visibilityState && T()
      }
        , D = e => {
          "mouse" === e.pointerType && (f = !0,
          m = !0,
          n.animating || n.autoplay.paused || b(!0))
      }
        , C = e => {
          "mouse" === e.pointerType && (m = !1,
          n.autoplay.paused && T())
      }
      ;
      s("init", ( () => {
          n.params.autoplay.enabled && (n.params.autoplay.pauseOnMouseEnter && (n.el.addEventListener("pointerenter", D),
          n.el.addEventListener("pointerleave", C)),
          Zl().addEventListener("visibilitychange", w),
          E())
      }
      )),
      s("destroy", ( () => {
          n.el && "string" != typeof n.el && (n.el.removeEventListener("pointerenter", D),
          n.el.removeEventListener("pointerleave", C)),
          Zl().removeEventListener("visibilitychange", w),
          n.autoplay.running && M()
      }
      )),
      s("_freeModeStaticRelease", ( () => {
          (h || f) && T()
      }
      )),
      s("_freeModeNoMomentumRelease", ( () => {
          n.params.autoplay.disableOnInteraction ? M() : b(!0, !0)
      }
      )),
      s("beforeTransitionStart", ( (e, t, i) => {
          !n.destroyed && n.autoplay.running && (i || !n.params.autoplay.disableOnInteraction ? b(!0, !0) : M())
      }
      )),
      s("sliderFirstMove", ( () => {
          !n.destroyed && n.autoplay.running && (n.params.autoplay.disableOnInteraction ? M() : (u = !0,
          h = !1,
          f = !1,
          d = setTimeout(( () => {
              f = !0,
              h = !0,
              b(!0)
          }
          ), 200)))
      }
      )),
      s("touchEnd", ( () => {
          if (!n.destroyed && n.autoplay.running && u) {
              if (clearTimeout(d),
              clearTimeout(t),
              n.params.autoplay.disableOnInteraction)
                  return h = !1,
                  void (u = !1);
              h && n.params.cssMode && T(),
              h = !1,
              u = !1
          }
      }
      )),
      s("slideChange", ( () => {
          !n.destroyed && n.autoplay.running && (p = !0)
      }
      )),
      Object.assign(n.autoplay, {
          start: E,
          stop: M,
          pause: b,
          resume: T
      })
  }
  ]);
  const Zc = e => Math.max(e.offsetHeight, e.scrollHeight);
  class $c {
      constructor(e={}) {
          const t = {
              content: e.viewport.children[0],
              direction: "all",
              pointerMode: "all",
              scrollMode: void 0,
              bounce: !0,
              bounceForce: .1,
              friction: .05,
              textSelection: !1,
              inputsFocus: !0,
              emulateScroll: !1,
              preventDefaultOnEmulateScroll: !1,
              preventPointerMoveDefault: !0,
              lockScrollOnDragDirection: !1,
              pointerDownPreventDefault: !0,
              dragDirectionTolerance: 40,
              onPointerDown() {},
              onPointerUp() {},
              onPointerMove() {},
              onClick() {},
              onUpdate() {},
              onWheel() {},
              shouldScroll: () => !0
          };
          if (this.props = {
              ...t,
              ...e
          },
          !(this.props.viewport && this.props.viewport instanceof Element))
              return void console.error('ScrollBooster init error: "viewport" config property must be present and must be Element');
          if (!this.props.content)
              return void console.error("ScrollBooster init error: Viewport does not have any content");
          this.isDragging = !1,
          this.isTargetScroll = !1,
          this.isScrolling = !1,
          this.isRunning = !1;
          const i = {
              x: 0,
              y: 0
          };
          this.position = {
              ...i
          },
          this.velocity = {
              ...i
          },
          this.dragStartPosition = {
              ...i
          },
          this.dragOffset = {
              ...i
          },
          this.clientOffset = {
              ...i
          },
          this.dragPosition = {
              ...i
          },
          this.targetPosition = {
              ...i
          },
          this.scrollOffset = {
              ...i
          },
          this.rafID = null,
          this.events = {},
          this.updateMetrics(),
          this.handleEvents()
      }
      updateOptions(e={}) {
          this.props = {
              ...this.props,
              ...e
          },
          this.props.onUpdate(this.getState()),
          this.startAnimationLoop()
      }
      updateMetrics() {
          var e;
          this.viewport = {
              width: this.props.viewport.clientWidth,
              height: this.props.viewport.clientHeight
          },
          this.content = {
              width: (e = this.props.content,
              Math.max(e.offsetWidth, e.scrollWidth)),
              height: Zc(this.props.content)
          },
          this.edgeX = {
              from: Math.min(-this.content.width + this.viewport.width, 0),
              to: 0
          },
          this.edgeY = {
              from: Math.min(-this.content.height + this.viewport.height, 0),
              to: 0
          },
          this.props.onUpdate(this.getState()),
          this.startAnimationLoop()
      }
      startAnimationLoop() {
          this.isRunning = !0,
          cancelAnimationFrame(this.rafID),
          this.rafID = requestAnimationFrame(( () => this.animate()))
      }
      animate() {
          if (!this.isRunning)
              return;
          this.updateScrollPosition(),
          this.isMoving() || (this.isRunning = !1,
          this.isTargetScroll = !1);
          const e = this.getState();
          this.setContentPosition(e),
          this.props.onUpdate(e),
          this.rafID = requestAnimationFrame(( () => this.animate()))
      }
      updateScrollPosition() {
          this.applyEdgeForce(),
          this.applyDragForce(),
          this.applyScrollForce(),
          this.applyTargetForce();
          const e = 1 - this.props.friction;
          this.velocity.x *= e,
          this.velocity.y *= e,
          "vertical" !== this.props.direction && (this.position.x += this.velocity.x),
          "horizontal" !== this.props.direction && (this.position.y += this.velocity.y),
          this.props.bounce && !this.isScrolling || this.isTargetScroll || (this.position.x = Math.max(Math.min(this.position.x, this.edgeX.to), this.edgeX.from),
          this.position.y = Math.max(Math.min(this.position.y, this.edgeY.to), this.edgeY.from))
      }
      applyForce(e) {
          this.velocity.x += e.x,
          this.velocity.y += e.y
      }
      applyEdgeForce() {
          if (!this.props.bounce || this.isDragging)
              return;
          const e = this.position.x < this.edgeX.from
            , t = this.position.x > this.edgeX.to
            , i = this.position.y < this.edgeY.from
            , n = this.position.y > this.edgeY.to
            , r = e || t
            , s = i || n;
          if (!r && !s)
              return;
          const a = e ? this.edgeX.from : this.edgeX.to
            , o = i ? this.edgeY.from : this.edgeY.to
            , l = a - this.position.x
            , c = o - this.position.y
            , u = {
              x: l * this.props.bounceForce,
              y: c * this.props.bounceForce
          }
            , h = this.position.x + (this.velocity.x + u.x) / this.props.friction
            , d = this.position.y + (this.velocity.y + u.y) / this.props.friction;
          (e && h >= this.edgeX.from || t && h <= this.edgeX.to) && (u.x = l * this.props.bounceForce - this.velocity.x),
          (i && d >= this.edgeY.from || n && d <= this.edgeY.to) && (u.y = c * this.props.bounceForce - this.velocity.y),
          this.applyForce({
              x: r ? u.x : 0,
              y: s ? u.y : 0
          })
      }
      applyDragForce() {
          if (!this.isDragging)
              return;
          const e = this.dragPosition.x - this.position.x
            , t = this.dragPosition.y - this.position.y;
          this.applyForce({
              x: e - this.velocity.x,
              y: t - this.velocity.y
          })
      }
      applyScrollForce() {
          this.isScrolling && (this.applyForce({
              x: this.scrollOffset.x - this.velocity.x,
              y: this.scrollOffset.y - this.velocity.y
          }),
          this.scrollOffset.x = 0,
          this.scrollOffset.y = 0)
      }
      applyTargetForce() {
          this.isTargetScroll && this.applyForce({
              x: .08 * (this.targetPosition.x - this.position.x) - this.velocity.x,
              y: .08 * (this.targetPosition.y - this.position.y) - this.velocity.y
          })
      }
      isMoving() {
          return this.isDragging || this.isScrolling || Math.abs(this.velocity.x) >= .01 || Math.abs(this.velocity.y) >= .01
      }
      scrollTo(e={}) {
          this.isTargetScroll = !0,
          this.targetPosition.x = -e.x || 0,
          this.targetPosition.y = -e.y || 0,
          this.startAnimationLoop()
      }
      setPosition(e={}) {
          this.velocity.x = 0,
          this.velocity.y = 0,
          this.position.x = -e.x || 0,
          this.position.y = -e.y || 0,
          this.startAnimationLoop()
      }
      getState() {
          return {
              isMoving: this.isMoving(),
              isDragging: !(!this.dragOffset.x && !this.dragOffset.y),
              position: {
                  x: -this.position.x,
                  y: -this.position.y
              },
              dragOffset: this.dragOffset,
              dragAngle: this.getDragAngle(this.clientOffset.x, this.clientOffset.y),
              borderCollision: {
                  left: this.position.x >= this.edgeX.to,
                  right: this.position.x <= this.edgeX.from,
                  top: this.position.y >= this.edgeY.to,
                  bottom: this.position.y <= this.edgeY.from
              }
          }
      }
      getDragAngle(e, t) {
          return Math.round(Math.atan2(e, t) * (180 / Math.PI))
      }
      getDragDirection(e, t) {
          return Math.abs(90 - Math.abs(e)) <= 90 - t ? "horizontal" : "vertical"
      }
      setContentPosition(e) {
          "transform" === this.props.scrollMode && (this.props.content.style.transform = `translate(${-e.position.x}px, ${-e.position.y}px)`),
          "native" === this.props.scrollMode && (this.props.viewport.scrollTop = e.position.y,
          this.props.viewport.scrollLeft = e.position.x)
      }
      handleEvents() {
          const e = {
              x: 0,
              y: 0
          }
            , t = {
              x: 0,
              y: 0
          };
          let i = null
            , n = null
            , r = !1;
          const s = n => {
              if (!this.isDragging)
                  return;
              const s = r ? n.touches[0] : n
                , {pageX: a, pageY: o, clientX: l, clientY: c} = s;
              this.dragOffset.x = a - e.x,
              this.dragOffset.y = o - e.y,
              this.clientOffset.x = l - t.x,
              this.clientOffset.y = c - t.y,
              (Math.abs(this.clientOffset.x) > 5 && !i || Math.abs(this.clientOffset.y) > 5 && !i) && (i = this.getDragDirection(this.getDragAngle(this.clientOffset.x, this.clientOffset.y), this.props.dragDirectionTolerance)),
              this.props.lockScrollOnDragDirection && "all" !== this.props.lockScrollOnDragDirection ? i === this.props.lockScrollOnDragDirection && r ? (this.dragPosition.x = this.dragStartPosition.x + this.dragOffset.x,
              this.dragPosition.y = this.dragStartPosition.y + this.dragOffset.y) : r ? (this.dragPosition.x = this.dragStartPosition.x,
              this.dragPosition.y = this.dragStartPosition.y) : (this.dragPosition.x = this.dragStartPosition.x + this.dragOffset.x,
              this.dragPosition.y = this.dragStartPosition.y + this.dragOffset.y) : (this.dragPosition.x = this.dragStartPosition.x + this.dragOffset.x,
              this.dragPosition.y = this.dragStartPosition.y + this.dragOffset.y)
          }
          ;
          this.events.pointerdown = i => {
              r = !(!i.touches || !i.touches[0]),
              this.props.onPointerDown(this.getState(), i, r);
              const n = r ? i.touches[0] : i
                , {pageX: a, pageY: o, clientX: l, clientY: c} = n
                , {viewport: u} = this.props
                , h = u.getBoundingClientRect();
              if (!(l - h.left >= u.clientLeft + u.clientWidth) && !(c - h.top >= u.clientTop + u.clientHeight) && this.props.shouldScroll(this.getState(), i) && 2 !== i.button && ("mouse" !== this.props.pointerMode || !r) && ("touch" !== this.props.pointerMode || r) && !(this.props.inputsFocus && ["input", "textarea", "button", "select", "label"].indexOf(i.target.nodeName.toLowerCase()) > -1)) {
                  if (this.props.textSelection) {
                      const e = ( (e, t, i) => {
                          const n = e.childNodes
                            , r = document.createRange();
                          for (let e = 0; e < n.length; e++) {
                              const s = n[e];
                              if (3 !== s.nodeType)
                                  continue;
                              r.selectNodeContents(s);
                              const a = r.getBoundingClientRect();
                              if (t >= a.left && i >= a.top && t <= a.right && i <= a.bottom)
                                  return s
                          }
                          return !1
                      }
                      )(i.target, l, c);
                      if (e)
                          return;
                      ( () => {
                          const e = window.getSelection ? window.getSelection() : document.selection;
                          e && (e.removeAllRanges ? e.removeAllRanges() : e.empty && e.empty())
                      }
                      )()
                  }
                  this.isDragging = !0,
                  e.x = a,
                  e.y = o,
                  t.x = l,
                  t.y = c,
                  this.dragStartPosition.x = this.position.x,
                  this.dragStartPosition.y = this.position.y,
                  s(i),
                  this.startAnimationLoop(),
                  !r && this.props.pointerDownPreventDefault && i.preventDefault()
              }
          }
          ,
          this.events.pointermove = e => {
              !e.cancelable || "all" !== this.props.lockScrollOnDragDirection && this.props.lockScrollOnDragDirection !== i || e.preventDefault(),
              s(e),
              this.props.onPointerMove(this.getState(), e, r)
          }
          ,
          this.events.pointerup = e => {
              this.isDragging = !1,
              i = null,
              this.props.onPointerUp(this.getState(), e, r)
          }
          ,
          this.events.wheel = e => {
              const t = this.getState();
              this.props.emulateScroll && (this.velocity.x = 0,
              this.velocity.y = 0,
              this.isScrolling = !0,
              this.scrollOffset.x = -e.deltaX,
              this.scrollOffset.y = -e.deltaY,
              this.props.onWheel(t, e),
              this.startAnimationLoop(),
              clearTimeout(n),
              n = setTimeout(( () => this.isScrolling = !1), 80),
              this.props.preventDefaultOnEmulateScroll && this.getDragDirection(this.getDragAngle(-e.deltaX, -e.deltaY), this.props.dragDirectionTolerance) === this.props.preventDefaultOnEmulateScroll && e.preventDefault())
          }
          ,
          this.events.scroll = () => {
              const {scrollLeft: e, scrollTop: t} = this.props.viewport;
              Math.abs(this.position.x + e) > 3 && (this.position.x = -e,
              this.velocity.x = 0),
              Math.abs(this.position.y + t) > 3 && (this.position.y = -t,
              this.velocity.y = 0)
          }
          ,
          this.events.click = e => {
              const t = this.getState()
                , i = "vertical" !== this.props.direction ? t.dragOffset.x : 0
                , n = "horizontal" !== this.props.direction ? t.dragOffset.y : 0;
              Math.max(Math.abs(i), Math.abs(n)) > 5 && (e.preventDefault(),
              e.stopPropagation()),
              this.props.onClick(t, e, r)
          }
          ,
          this.events.contentLoad = () => this.updateMetrics(),
          this.events.resize = () => this.updateMetrics(),
          this.props.viewport.addEventListener("mousedown", this.events.pointerdown),
          this.props.viewport.addEventListener("touchstart", this.events.pointerdown, {
              passive: !1
          }),
          this.props.viewport.addEventListener("click", this.events.click),
          this.props.viewport.addEventListener("wheel", this.events.wheel, {
              passive: !1
          }),
          this.props.viewport.addEventListener("scroll", this.events.scroll),
          this.props.content.addEventListener("load", this.events.contentLoad, !0),
          window.addEventListener("mousemove", this.events.pointermove),
          window.addEventListener("touchmove", this.events.pointermove, {
              passive: !1
          }),
          window.addEventListener("mouseup", this.events.pointerup),
          window.addEventListener("touchend", this.events.pointerup),
          window.addEventListener("resize", this.events.resize)
      }
      destroy() {
          this.props.viewport.removeEventListener("mousedown", this.events.pointerdown),
          this.props.viewport.removeEventListener("touchstart", this.events.pointerdown),
          this.props.viewport.removeEventListener("click", this.events.click),
          this.props.viewport.removeEventListener("wheel", this.events.wheel),
          this.props.viewport.removeEventListener("scroll", this.events.scroll),
          this.props.content.removeEventListener("load", this.events.contentLoad),
          window.removeEventListener("mousemove", this.events.pointermove),
          window.removeEventListener("touchmove", this.events.pointermove),
          window.removeEventListener("mouseup", this.events.pointerup),
          window.removeEventListener("touchend", this.events.pointerup),
          window.removeEventListener("resize", this.events.resize)
      }
  }
  const Jc = "167"
    , Qc = 1
    , eu = 2
    , tu = 3
    , iu = 100
    , nu = 0
    , ru = 1
    , su = 2
    , au = 0
    , ou = 1
    , lu = 2
    , cu = 3
    , uu = 4
    , hu = 5
    , du = 6
    , pu = 7
    , fu = 301
    , mu = 302
    , gu = 306
    , vu = 1e3
    , _u = 1001
    , yu = 1002
    , xu = 1003
    , Su = 1005
    , Eu = 1006
    , Mu = 1007
    , bu = 1008
    , Tu = 1009
    , wu = 1010
    , Du = 1011
    , Cu = 1012
    , Au = 1013
    , Pu = 1014
    , Ru = 1015
    , Lu = 1016
    , Iu = 1017
    , Nu = 1018
    , Fu = 1020
    , Ou = 35902
    , Uu = 1021
    , Bu = 1022
    , zu = 1023
    , ku = 1024
    , Vu = 1025
    , Hu = 1026
    , Gu = 1027
    , Wu = 1028
    , Xu = 1029
    , qu = 1030
    , ju = 1031
    , Yu = 1033
    , Ku = 33776
    , Zu = 33777
    , $u = 33778
    , Ju = 33779
    , Qu = 35840
    , eh = 35841
    , th = 35842
    , ih = 35843
    , nh = 36196
    , rh = 37492
    , sh = 37496
    , ah = 37808
    , oh = 37809
    , lh = 37810
    , ch = 37811
    , uh = 37812
    , hh = 37813
    , dh = 37814
    , ph = 37815
    , fh = 37816
    , mh = 37817
    , gh = 37818
    , vh = 37819
    , _h = 37820
    , yh = 37821
    , xh = 36492
    , Sh = 36494
    , Eh = 36495
    , Mh = 36283
    , bh = 36284
    , Th = 36285
    , wh = 36286
    , Dh = 2300
    , Ch = 2301
    , Ah = 2302
    , Ph = ""
    , Rh = "srgb"
    , Lh = "srgb-linear"
    , Ih = "display-p3"
    , Nh = "display-p3-linear"
    , Fh = "linear"
    , Oh = "srgb"
    , Uh = "rec709"
    , Bh = "p3"
    , zh = 7680
    , kh = "300 es"
    , Vh = 2e3
    , Hh = 2001;
  class Gh {
      addEventListener(e, t) {
          void 0 === this._listeners && (this._listeners = {});
          const i = this._listeners;
          void 0 === i[e] && (i[e] = []),
          -1 === i[e].indexOf(t) && i[e].push(t)
      }
      hasEventListener(e, t) {
          if (void 0 === this._listeners)
              return !1;
          const i = this._listeners;
          return void 0 !== i[e] && -1 !== i[e].indexOf(t)
      }
      removeEventListener(e, t) {
          if (void 0 === this._listeners)
              return;
          const i = this._listeners[e];
          if (void 0 !== i) {
              const e = i.indexOf(t);
              -1 !== e && i.splice(e, 1)
          }
      }
      dispatchEvent(e) {
          if (void 0 === this._listeners)
              return;
          const t = this._listeners[e.type];
          if (void 0 !== t) {
              e.target = this;
              const i = t.slice(0);
              for (let t = 0, n = i.length; t < n; t++)
                  i[t].call(this, e);
              e.target = null
          }
      }
  }
  const Wh = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
    , Xh = Math.PI / 180
    , qh = 180 / Math.PI;
  function jh() {
      const e = 4294967295 * Math.random() | 0
        , t = 4294967295 * Math.random() | 0
        , i = 4294967295 * Math.random() | 0
        , n = 4294967295 * Math.random() | 0;
      return (Wh[255 & e] + Wh[e >> 8 & 255] + Wh[e >> 16 & 255] + Wh[e >> 24 & 255] + "-" + Wh[255 & t] + Wh[t >> 8 & 255] + "-" + Wh[t >> 16 & 15 | 64] + Wh[t >> 24 & 255] + "-" + Wh[63 & i | 128] + Wh[i >> 8 & 255] + "-" + Wh[i >> 16 & 255] + Wh[i >> 24 & 255] + Wh[255 & n] + Wh[n >> 8 & 255] + Wh[n >> 16 & 255] + Wh[n >> 24 & 255]).toLowerCase()
  }
  function Yh(e, t, i) {
      return Math.max(t, Math.min(i, e))
  }
  function Kh(e, t, i) {
      return (1 - i) * e + i * t
  }
  function Zh(e, t) {
      switch (t.constructor) {
      case Float32Array:
          return e;
      case Uint32Array:
          return e / 4294967295;
      case Uint16Array:
          return e / 65535;
      case Uint8Array:
          return e / 255;
      case Int32Array:
          return Math.max(e / 2147483647, -1);
      case Int16Array:
          return Math.max(e / 32767, -1);
      case Int8Array:
          return Math.max(e / 127, -1);
      default:
          throw new Error("Invalid component type.")
      }
  }
  function $h(e, t) {
      switch (t.constructor) {
      case Float32Array:
          return e;
      case Uint32Array:
          return Math.round(4294967295 * e);
      case Uint16Array:
          return Math.round(65535 * e);
      case Uint8Array:
          return Math.round(255 * e);
      case Int32Array:
          return Math.round(2147483647 * e);
      case Int16Array:
          return Math.round(32767 * e);
      case Int8Array:
          return Math.round(127 * e);
      default:
          throw new Error("Invalid component type.")
      }
  }
  class Jh {
      constructor(e=0, t=0) {
          Jh.prototype.isVector2 = !0,
          this.x = e,
          this.y = t
      }
      get width() {
          return this.x
      }
      set width(e) {
          this.x = e
      }
      get height() {
          return this.y
      }
      set height(e) {
          this.y = e
      }
      set(e, t) {
          return this.x = e,
          this.y = t,
          this
      }
      setScalar(e) {
          return this.x = e,
          this.y = e,
          this
      }
      setX(e) {
          return this.x = e,
          this
      }
      setY(e) {
          return this.y = e,
          this
      }
      setComponent(e, t) {
          switch (e) {
          case 0:
              this.x = t;
              break;
          case 1:
              this.y = t;
              break;
          default:
              throw new Error("index is out of range: " + e)
          }
          return this
      }
      getComponent(e) {
          switch (e) {
          case 0:
              return this.x;
          case 1:
              return this.y;
          default:
              throw new Error("index is out of range: " + e)
          }
      }
      clone() {
          return new this.constructor(this.x,this.y)
      }
      copy(e) {
          return this.x = e.x,
          this.y = e.y,
          this
      }
      add(e) {
          return this.x += e.x,
          this.y += e.y,
          this
      }
      addScalar(e) {
          return this.x += e,
          this.y += e,
          this
      }
      addVectors(e, t) {
          return this.x = e.x + t.x,
          this.y = e.y + t.y,
          this
      }
      addScaledVector(e, t) {
          return this.x += e.x * t,
          this.y += e.y * t,
          this
      }
      sub(e) {
          return this.x -= e.x,
          this.y -= e.y,
          this
      }
      subScalar(e) {
          return this.x -= e,
          this.y -= e,
          this
      }
      subVectors(e, t) {
          return this.x = e.x - t.x,
          this.y = e.y - t.y,
          this
      }
      multiply(e) {
          return this.x *= e.x,
          this.y *= e.y,
          this
      }
      multiplyScalar(e) {
          return this.x *= e,
          this.y *= e,
          this
      }
      divide(e) {
          return this.x /= e.x,
          this.y /= e.y,
          this
      }
      divideScalar(e) {
          return this.multiplyScalar(1 / e)
      }
      applyMatrix3(e) {
          const t = this.x
            , i = this.y
            , n = e.elements;
          return this.x = n[0] * t + n[3] * i + n[6],
          this.y = n[1] * t + n[4] * i + n[7],
          this
      }
      min(e) {
          return this.x = Math.min(this.x, e.x),
          this.y = Math.min(this.y, e.y),
          this
      }
      max(e) {
          return this.x = Math.max(this.x, e.x),
          this.y = Math.max(this.y, e.y),
          this
      }
      clamp(e, t) {
          return this.x = Math.max(e.x, Math.min(t.x, this.x)),
          this.y = Math.max(e.y, Math.min(t.y, this.y)),
          this
      }
      clampScalar(e, t) {
          return this.x = Math.max(e, Math.min(t, this.x)),
          this.y = Math.max(e, Math.min(t, this.y)),
          this
      }
      clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
      }
      floor() {
          return this.x = Math.floor(this.x),
          this.y = Math.floor(this.y),
          this
      }
      ceil() {
          return this.x = Math.ceil(this.x),
          this.y = Math.ceil(this.y),
          this
      }
      round() {
          return this.x = Math.round(this.x),
          this.y = Math.round(this.y),
          this
      }
      roundToZero() {
          return this.x = Math.trunc(this.x),
          this.y = Math.trunc(this.y),
          this
      }
      negate() {
          return this.x = -this.x,
          this.y = -this.y,
          this
      }
      dot(e) {
          return this.x * e.x + this.y * e.y
      }
      cross(e) {
          return this.x * e.y - this.y * e.x
      }
      lengthSq() {
          return this.x * this.x + this.y * this.y
      }
      length() {
          return Math.sqrt(this.x * this.x + this.y * this.y)
      }
      manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y)
      }
      normalize() {
          return this.divideScalar(this.length() || 1)
      }
      angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI
      }
      angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t)
              return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(Yh(i, -1, 1))
      }
      distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e))
      }
      distanceToSquared(e) {
          const t = this.x - e.x
            , i = this.y - e.y;
          return t * t + i * i
      }
      manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
      }
      setLength(e) {
          return this.normalize().multiplyScalar(e)
      }
      lerp(e, t) {
          return this.x += (e.x - this.x) * t,
          this.y += (e.y - this.y) * t,
          this
      }
      lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i,
          this.y = e.y + (t.y - e.y) * i,
          this
      }
      equals(e) {
          return e.x === this.x && e.y === this.y
      }
      fromArray(e, t=0) {
          return this.x = e[t],
          this.y = e[t + 1],
          this
      }
      toArray(e=[], t=0) {
          return e[t] = this.x,
          e[t + 1] = this.y,
          e
      }
      fromBufferAttribute(e, t) {
          return this.x = e.getX(t),
          this.y = e.getY(t),
          this
      }
      rotateAround(e, t) {
          const i = Math.cos(t)
            , n = Math.sin(t)
            , r = this.x - e.x
            , s = this.y - e.y;
          return this.x = r * i - s * n + e.x,
          this.y = r * n + s * i + e.y,
          this
      }
      random() {
          return this.x = Math.random(),
          this.y = Math.random(),
          this
      }
      *[Symbol.iterator]() {
          yield this.x,
          yield this.y
      }
  }
  class Qh {
      constructor(e, t, i, n, r, s, a, o, l) {
          Qh.prototype.isMatrix3 = !0,
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
          void 0 !== e && this.set(e, t, i, n, r, s, a, o, l)
      }
      set(e, t, i, n, r, s, a, o, l) {
          const c = this.elements;
          return c[0] = e,
          c[1] = n,
          c[2] = a,
          c[3] = t,
          c[4] = r,
          c[5] = o,
          c[6] = i,
          c[7] = s,
          c[8] = l,
          this
      }
      identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
          this
      }
      copy(e) {
          const t = this.elements
            , i = e.elements;
          return t[0] = i[0],
          t[1] = i[1],
          t[2] = i[2],
          t[3] = i[3],
          t[4] = i[4],
          t[5] = i[5],
          t[6] = i[6],
          t[7] = i[7],
          t[8] = i[8],
          this
      }
      extractBasis(e, t, i) {
          return e.setFromMatrix3Column(this, 0),
          t.setFromMatrix3Column(this, 1),
          i.setFromMatrix3Column(this, 2),
          this
      }
      setFromMatrix4(e) {
          const t = e.elements;
          return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
          this
      }
      multiply(e) {
          return this.multiplyMatrices(this, e)
      }
      premultiply(e) {
          return this.multiplyMatrices(e, this)
      }
      multiplyMatrices(e, t) {
          const i = e.elements
            , n = t.elements
            , r = this.elements
            , s = i[0]
            , a = i[3]
            , o = i[6]
            , l = i[1]
            , c = i[4]
            , u = i[7]
            , h = i[2]
            , d = i[5]
            , p = i[8]
            , f = n[0]
            , m = n[3]
            , g = n[6]
            , v = n[1]
            , _ = n[4]
            , y = n[7]
            , x = n[2]
            , S = n[5]
            , E = n[8];
          return r[0] = s * f + a * v + o * x,
          r[3] = s * m + a * _ + o * S,
          r[6] = s * g + a * y + o * E,
          r[1] = l * f + c * v + u * x,
          r[4] = l * m + c * _ + u * S,
          r[7] = l * g + c * y + u * E,
          r[2] = h * f + d * v + p * x,
          r[5] = h * m + d * _ + p * S,
          r[8] = h * g + d * y + p * E,
          this
      }
      multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e,
          t[3] *= e,
          t[6] *= e,
          t[1] *= e,
          t[4] *= e,
          t[7] *= e,
          t[2] *= e,
          t[5] *= e,
          t[8] *= e,
          this
      }
      determinant() {
          const e = this.elements
            , t = e[0]
            , i = e[1]
            , n = e[2]
            , r = e[3]
            , s = e[4]
            , a = e[5]
            , o = e[6]
            , l = e[7]
            , c = e[8];
          return t * s * c - t * a * l - i * r * c + i * a * o + n * r * l - n * s * o
      }
      invert() {
          const e = this.elements
            , t = e[0]
            , i = e[1]
            , n = e[2]
            , r = e[3]
            , s = e[4]
            , a = e[5]
            , o = e[6]
            , l = e[7]
            , c = e[8]
            , u = c * s - a * l
            , h = a * o - c * r
            , d = l * r - s * o
            , p = t * u + i * h + n * d;
          if (0 === p)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / p;
          return e[0] = u * f,
          e[1] = (n * l - c * i) * f,
          e[2] = (a * i - n * s) * f,
          e[3] = h * f,
          e[4] = (c * t - n * o) * f,
          e[5] = (n * r - a * t) * f,
          e[6] = d * f,
          e[7] = (i * o - l * t) * f,
          e[8] = (s * t - i * r) * f,
          this
      }
      transpose() {
          let e;
          const t = this.elements;
          return e = t[1],
          t[1] = t[3],
          t[3] = e,
          e = t[2],
          t[2] = t[6],
          t[6] = e,
          e = t[5],
          t[5] = t[7],
          t[7] = e,
          this
      }
      getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose()
      }
      transposeIntoArray(e) {
          const t = this.elements;
          return e[0] = t[0],
          e[1] = t[3],
          e[2] = t[6],
          e[3] = t[1],
          e[4] = t[4],
          e[5] = t[7],
          e[6] = t[2],
          e[7] = t[5],
          e[8] = t[8],
          this
      }
      setUvTransform(e, t, i, n, r, s, a) {
          const o = Math.cos(r)
            , l = Math.sin(r);
          return this.set(i * o, i * l, -i * (o * s + l * a) + s + e, -n * l, n * o, -n * (-l * s + o * a) + a + t, 0, 0, 1),
          this
      }
      scale(e, t) {
          return this.premultiply(ed.makeScale(e, t)),
          this
      }
      rotate(e) {
          return this.premultiply(ed.makeRotation(-e)),
          this
      }
      translate(e, t) {
          return this.premultiply(ed.makeTranslation(e, t)),
          this
      }
      makeTranslation(e, t) {
          return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
          this
      }
      makeRotation(e) {
          const t = Math.cos(e)
            , i = Math.sin(e);
          return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
          this
      }
      makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
          this
      }
      equals(e) {
          const t = this.elements
            , i = e.elements;
          for (let e = 0; e < 9; e++)
              if (t[e] !== i[e])
                  return !1;
          return !0
      }
      fromArray(e, t=0) {
          for (let i = 0; i < 9; i++)
              this.elements[i] = e[i + t];
          return this
      }
      toArray(e=[], t=0) {
          const i = this.elements;
          return e[t] = i[0],
          e[t + 1] = i[1],
          e[t + 2] = i[2],
          e[t + 3] = i[3],
          e[t + 4] = i[4],
          e[t + 5] = i[5],
          e[t + 6] = i[6],
          e[t + 7] = i[7],
          e[t + 8] = i[8],
          e
      }
      clone() {
          return (new this.constructor).fromArray(this.elements)
      }
  }
  const ed = new Qh;
  function td(e) {
      for (let t = e.length - 1; t >= 0; --t)
          if (e[t] >= 65535)
              return !0;
      return !1
  }
  function id(e) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", e)
  }
  function nd() {
      const e = id("canvas");
      return e.style.display = "block",
      e
  }
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array;
  const rd = {};
  function sd(e) {
      e in rd || (rd[e] = !0,
      console.warn(e))
  }
  const ad = (new Qh).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
    , od = (new Qh).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
    , ld = {
      [Lh]: {
          transfer: Fh,
          primaries: Uh,
          luminanceCoefficients: [.2126, .7152, .0722],
          toReference: e => e,
          fromReference: e => e
      },
      [Rh]: {
          transfer: Oh,
          primaries: Uh,
          luminanceCoefficients: [.2126, .7152, .0722],
          toReference: e => e.convertSRGBToLinear(),
          fromReference: e => e.convertLinearToSRGB()
      },
      [Nh]: {
          transfer: Fh,
          primaries: Bh,
          luminanceCoefficients: [.2289, .6917, .0793],
          toReference: e => e.applyMatrix3(od),
          fromReference: e => e.applyMatrix3(ad)
      },
      [Ih]: {
          transfer: Oh,
          primaries: Bh,
          luminanceCoefficients: [.2289, .6917, .0793],
          toReference: e => e.convertSRGBToLinear().applyMatrix3(od),
          fromReference: e => e.applyMatrix3(ad).convertLinearToSRGB()
      }
  }
    , cd = new Set([Lh, Nh])
    , ud = {
      enabled: !0,
      _workingColorSpace: Lh,
      get workingColorSpace() {
          return this._workingColorSpace
      },
      set workingColorSpace(e) {
          if (!cd.has(e))
              throw new Error(`Unsupported working color space, "${e}".`);
          this._workingColorSpace = e
      },
      convert: function(e, t, i) {
          if (!1 === this.enabled || t === i || !t || !i)
              return e;
          const n = ld[t].toReference;
          return (0,
          ld[i].fromReference)(n(e))
      },
      fromWorkingColorSpace: function(e, t) {
          return this.convert(e, this._workingColorSpace, t)
      },
      toWorkingColorSpace: function(e, t) {
          return this.convert(e, t, this._workingColorSpace)
      },
      getPrimaries: function(e) {
          return ld[e].primaries
      },
      getTransfer: function(e) {
          return e === Ph ? Fh : ld[e].transfer
      },
      getLuminanceCoefficients: function(e, t=this._workingColorSpace) {
          return e.fromArray(ld[t].luminanceCoefficients)
      }
  };
  function hd(e) {
      return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
  }
  function dd(e) {
      return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
  }
  let pd;
  class fd {
      static getDataURL(e) {
          if (/^data:/i.test(e.src))
              return e.src;
          if ("undefined" == typeof HTMLCanvasElement)
              return e.src;
          let t;
          if (e instanceof HTMLCanvasElement)
              t = e;
          else {
              void 0 === pd && (pd = id("canvas")),
              pd.width = e.width,
              pd.height = e.height;
              const i = pd.getContext("2d");
              e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
              t = pd
          }
          return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
          t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
      }
      static sRGBToLinear(e) {
          if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
              const t = id("canvas");
              t.width = e.width,
              t.height = e.height;
              const i = t.getContext("2d");
              i.drawImage(e, 0, 0, e.width, e.height);
              const n = i.getImageData(0, 0, e.width, e.height)
                , r = n.data;
              for (let e = 0; e < r.length; e++)
                  r[e] = 255 * hd(r[e] / 255);
              return i.putImageData(n, 0, 0),
              t
          }
          if (e.data) {
              const t = e.data.slice(0);
              for (let e = 0; e < t.length; e++)
                  t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * hd(t[e] / 255)) : t[e] = hd(t[e]);
              return {
                  data: t,
                  width: e.width,
                  height: e.height
              }
          }
          return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
          e
      }
  }
  let md = 0;
  class gd {
      constructor(e=null) {
          this.isSource = !0,
          Object.defineProperty(this, "id", {
              value: md++
          }),
          this.uuid = jh(),
          this.data = e,
          this.dataReady = !0,
          this.version = 0
      }
      set needsUpdate(e) {
          !0 === e && this.version++
      }
      toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.images[this.uuid])
              return e.images[this.uuid];
          const i = {
              uuid: this.uuid,
              url: ""
          }
            , n = this.data;
          if (null !== n) {
              let e;
              if (Array.isArray(n)) {
                  e = [];
                  for (let t = 0, i = n.length; t < i; t++)
                      n[t].isDataTexture ? e.push(vd(n[t].image)) : e.push(vd(n[t]))
              } else
                  e = vd(n);
              i.url = e
          }
          return t || (e.images[this.uuid] = i),
          i
      }
  }
  function vd(e) {
      return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? fd.getDataURL(e) : e.data ? {
          data: Array.from(e.data),
          width: e.width,
          height: e.height,
          type: e.data.constructor.name
      } : (console.warn("THREE.Texture: Unable to serialize Texture."),
      {})
  }
  let _d = 0;
  class yd extends Gh {
      constructor(e=yd.DEFAULT_IMAGE, t=yd.DEFAULT_MAPPING, i=1001, n=1001, r=1006, s=1008, a=zu, o=Tu, l=yd.DEFAULT_ANISOTROPY, c="") {
          super(),
          this.isTexture = !0,
          Object.defineProperty(this, "id", {
              value: _d++
          }),
          this.uuid = jh(),
          this.name = "",
          this.source = new gd(e),
          this.mipmaps = [],
          this.mapping = t,
          this.channel = 0,
          this.wrapS = i,
          this.wrapT = n,
          this.magFilter = r,
          this.minFilter = s,
          this.anisotropy = l,
          this.format = a,
          this.internalFormat = null,
          this.type = o,
          this.offset = new Jh(0,0),
          this.repeat = new Jh(1,1),
          this.center = new Jh(0,0),
          this.rotation = 0,
          this.matrixAutoUpdate = !0,
          this.matrix = new Qh,
          this.generateMipmaps = !0,
          this.premultiplyAlpha = !1,
          this.flipY = !0,
          this.unpackAlignment = 4,
          this.colorSpace = c,
          this.userData = {},
          this.version = 0,
          this.onUpdate = null,
          this.isRenderTargetTexture = !1,
          this.pmremVersion = 0
      }
      get image() {
          return this.source.data
      }
      set image(e=null) {
          this.source.data = e
      }
      updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
      }
      clone() {
          return (new this.constructor).copy(this)
      }
      copy(e) {
          return this.name = e.name,
          this.source = e.source,
          this.mipmaps = e.mipmaps.slice(0),
          this.mapping = e.mapping,
          this.channel = e.channel,
          this.wrapS = e.wrapS,
          this.wrapT = e.wrapT,
          this.magFilter = e.magFilter,
          this.minFilter = e.minFilter,
          this.anisotropy = e.anisotropy,
          this.format = e.format,
          this.internalFormat = e.internalFormat,
          this.type = e.type,
          this.offset.copy(e.offset),
          this.repeat.copy(e.repeat),
          this.center.copy(e.center),
          this.rotation = e.rotation,
          this.matrixAutoUpdate = e.matrixAutoUpdate,
          this.matrix.copy(e.matrix),
          this.generateMipmaps = e.generateMipmaps,
          this.premultiplyAlpha = e.premultiplyAlpha,
          this.flipY = e.flipY,
          this.unpackAlignment = e.unpackAlignment,
          this.colorSpace = e.colorSpace,
          this.userData = JSON.parse(JSON.stringify(e.userData)),
          this.needsUpdate = !0,
          this
      }
      toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.textures[this.uuid])
              return e.textures[this.uuid];
          const i = {
              metadata: {
                  version: 4.6,
                  type: "Texture",
                  generator: "Texture.toJSON"
              },
              uuid: this.uuid,
              name: this.name,
              image: this.source.toJSON(e).uuid,
              mapping: this.mapping,
              channel: this.channel,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              internalFormat: this.internalFormat,
              type: this.type,
              colorSpace: this.colorSpace,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              generateMipmaps: this.generateMipmaps,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment
          };
          return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
          t || (e.textures[this.uuid] = i),
          i
      }
      dispose() {
          this.dispatchEvent({
              type: "dispose"
          })
      }
      transformUv(e) {
          if (300 !== this.mapping)
              return e;
          if (e.applyMatrix3(this.matrix),
          e.x < 0 || e.x > 1)
              switch (this.wrapS) {
              case vu:
                  e.x = e.x - Math.floor(e.x);
                  break;
              case _u:
                  e.x = e.x < 0 ? 0 : 1;
                  break;
              case yu:
                  1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
              }
          if (e.y < 0 || e.y > 1)
              switch (this.wrapT) {
              case vu:
                  e.y = e.y - Math.floor(e.y);
                  break;
              case _u:
                  e.y = e.y < 0 ? 0 : 1;
                  break;
              case yu:
                  1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
              }
          return this.flipY && (e.y = 1 - e.y),
          e
      }
      set needsUpdate(e) {
          !0 === e && (this.version++,
          this.source.needsUpdate = !0)
      }
      set needsPMREMUpdate(e) {
          !0 === e && this.pmremVersion++
      }
  }
  yd.DEFAULT_IMAGE = null,
  yd.DEFAULT_MAPPING = 300,
  yd.DEFAULT_ANISOTROPY = 1;
  class xd {
      constructor(e=0, t=0, i=0, n=1) {
          xd.prototype.isVector4 = !0,
          this.x = e,
          this.y = t,
          this.z = i,
          this.w = n
      }
      get width() {
          return this.z
      }
      set width(e) {
          this.z = e
      }
      get height() {
          return this.w
      }
      set height(e) {
          this.w = e
      }
      set(e, t, i, n) {
          return this.x = e,
          this.y = t,
          this.z = i,
          this.w = n,
          this
      }
      setScalar(e) {
          return this.x = e,
          this.y = e,
          this.z = e,
          this.w = e,
          this
      }
      setX(e) {
          return this.x = e,
          this
      }
      setY(e) {
          return this.y = e,
          this
      }
      setZ(e) {
          return this.z = e,
          this
      }
      setW(e) {
          return this.w = e,
          this
      }
      setComponent(e, t) {
          switch (e) {
          case 0:
              this.x = t;
              break;
          case 1:
              this.y = t;
              break;
          case 2:
              this.z = t;
              break;
          case 3:
              this.w = t;
              break;
          default:
              throw new Error("index is out of range: " + e)
          }
          return this
      }
      getComponent(e) {
          switch (e) {
          case 0:
              return this.x;
          case 1:
              return this.y;
          case 2:
              return this.z;
          case 3:
              return this.w;
          default:
              throw new Error("index is out of range: " + e)
          }
      }
      clone() {
          return new this.constructor(this.x,this.y,this.z,this.w)
      }
      copy(e) {
          return this.x = e.x,
          this.y = e.y,
          this.z = e.z,
          this.w = void 0 !== e.w ? e.w : 1,
          this
      }
      add(e) {
          return this.x += e.x,
          this.y += e.y,
          this.z += e.z,
          this.w += e.w,
          this
      }
      addScalar(e) {
          return this.x += e,
          this.y += e,
          this.z += e,
          this.w += e,
          this
      }
      addVectors(e, t) {
          return this.x = e.x + t.x,
          this.y = e.y + t.y,
          this.z = e.z + t.z,
          this.w = e.w + t.w,
          this
      }
      addScaledVector(e, t) {
          return this.x += e.x * t,
          this.y += e.y * t,
          this.z += e.z * t,
          this.w += e.w * t,
          this
      }
      sub(e) {
          return this.x -= e.x,
          this.y -= e.y,
          this.z -= e.z,
          this.w -= e.w,
          this
      }
      subScalar(e) {
          return this.x -= e,
          this.y -= e,
          this.z -= e,
          this.w -= e,
          this
      }
      subVectors(e, t) {
          return this.x = e.x - t.x,
          this.y = e.y - t.y,
          this.z = e.z - t.z,
          this.w = e.w - t.w,
          this
      }
      multiply(e) {
          return this.x *= e.x,
          this.y *= e.y,
          this.z *= e.z,
          this.w *= e.w,
          this
      }
      multiplyScalar(e) {
          return this.x *= e,
          this.y *= e,
          this.z *= e,
          this.w *= e,
          this
      }
      applyMatrix4(e) {
          const t = this.x
            , i = this.y
            , n = this.z
            , r = this.w
            , s = e.elements;
          return this.x = s[0] * t + s[4] * i + s[8] * n + s[12] * r,
          this.y = s[1] * t + s[5] * i + s[9] * n + s[13] * r,
          this.z = s[2] * t + s[6] * i + s[10] * n + s[14] * r,
          this.w = s[3] * t + s[7] * i + s[11] * n + s[15] * r,
          this
      }
      divideScalar(e) {
          return this.multiplyScalar(1 / e)
      }
      setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return t < 1e-4 ? (this.x = 1,
          this.y = 0,
          this.z = 0) : (this.x = e.x / t,
          this.y = e.y / t,
          this.z = e.z / t),
          this
      }
      setAxisAngleFromRotationMatrix(e) {
          let t, i, n, r;
          const s = .01
            , a = .1
            , o = e.elements
            , l = o[0]
            , c = o[4]
            , u = o[8]
            , h = o[1]
            , d = o[5]
            , p = o[9]
            , f = o[2]
            , m = o[6]
            , g = o[10];
          if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
              if (Math.abs(c + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a)
                  return this.set(1, 0, 0, 0),
                  this;
              t = Math.PI;
              const e = (l + 1) / 2
                , o = (d + 1) / 2
                , v = (g + 1) / 2
                , _ = (c + h) / 4
                , y = (u + f) / 4
                , x = (p + m) / 4;
              return e > o && e > v ? e < s ? (i = 0,
              n = .707106781,
              r = .707106781) : (i = Math.sqrt(e),
              n = _ / i,
              r = y / i) : o > v ? o < s ? (i = .707106781,
              n = 0,
              r = .707106781) : (n = Math.sqrt(o),
              i = _ / n,
              r = x / n) : v < s ? (i = .707106781,
              n = .707106781,
              r = 0) : (r = Math.sqrt(v),
              i = y / r,
              n = x / r),
              this.set(i, n, r, t),
              this
          }
          let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
          return Math.abs(v) < .001 && (v = 1),
          this.x = (m - p) / v,
          this.y = (u - f) / v,
          this.z = (h - c) / v,
          this.w = Math.acos((l + d + g - 1) / 2),
          this
      }
      setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12],
          this.y = t[13],
          this.z = t[14],
          this.w = t[15],
          this
      }
      min(e) {
          return this.x = Math.min(this.x, e.x),
          this.y = Math.min(this.y, e.y),
          this.z = Math.min(this.z, e.z),
          this.w = Math.min(this.w, e.w),
          this
      }
      max(e) {
          return this.x = Math.max(this.x, e.x),
          this.y = Math.max(this.y, e.y),
          this.z = Math.max(this.z, e.z),
          this.w = Math.max(this.w, e.w),
          this
      }
      clamp(e, t) {
          return this.x = Math.max(e.x, Math.min(t.x, this.x)),
          this.y = Math.max(e.y, Math.min(t.y, this.y)),
          this.z = Math.max(e.z, Math.min(t.z, this.z)),
          this.w = Math.max(e.w, Math.min(t.w, this.w)),
          this
      }
      clampScalar(e, t) {
          return this.x = Math.max(e, Math.min(t, this.x)),
          this.y = Math.max(e, Math.min(t, this.y)),
          this.z = Math.max(e, Math.min(t, this.z)),
          this.w = Math.max(e, Math.min(t, this.w)),
          this
      }
      clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
      }
      floor() {
          return this.x = Math.floor(this.x),
          this.y = Math.floor(this.y),
          this.z = Math.floor(this.z),
          this.w = Math.floor(this.w),
          this
      }
      ceil() {
          return this.x = Math.ceil(this.x),
          this.y = Math.ceil(this.y),
          this.z = Math.ceil(this.z),
          this.w = Math.ceil(this.w),
          this
      }
      round() {
          return this.x = Math.round(this.x),
          this.y = Math.round(this.y),
          this.z = Math.round(this.z),
          this.w = Math.round(this.w),
          this
      }
      roundToZero() {
          return this.x = Math.trunc(this.x),
          this.y = Math.trunc(this.y),
          this.z = Math.trunc(this.z),
          this.w = Math.trunc(this.w),
          this
      }
      negate() {
          return this.x = -this.x,
          this.y = -this.y,
          this.z = -this.z,
          this.w = -this.w,
          this
      }
      dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
      }
      lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      }
      length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
      }
      manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
      }
      normalize() {
          return this.divideScalar(this.length() || 1)
      }
      setLength(e) {
          return this.normalize().multiplyScalar(e)
      }
      lerp(e, t) {
          return this.x += (e.x - this.x) * t,
          this.y += (e.y - this.y) * t,
          this.z += (e.z - this.z) * t,
          this.w += (e.w - this.w) * t,
          this
      }
      lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i,
          this.y = e.y + (t.y - e.y) * i,
          this.z = e.z + (t.z - e.z) * i,
          this.w = e.w + (t.w - e.w) * i,
          this
      }
      equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
      }
      fromArray(e, t=0) {
          return this.x = e[t],
          this.y = e[t + 1],
          this.z = e[t + 2],
          this.w = e[t + 3],
          this
      }
      toArray(e=[], t=0) {
          return e[t] = this.x,
          e[t + 1] = this.y,
          e[t + 2] = this.z,
          e[t + 3] = this.w,
          e
      }
      fromBufferAttribute(e, t) {
          return this.x = e.getX(t),
          this.y = e.getY(t),
          this.z = e.getZ(t),
          this.w = e.getW(t),
          this
      }
      random() {
          return this.x = Math.random(),
          this.y = Math.random(),
          this.z = Math.random(),
          this.w = Math.random(),
          this
      }
      *[Symbol.iterator]() {
          yield this.x,
          yield this.y,
          yield this.z,
          yield this.w
      }
  }
  class Sd extends Gh {
      constructor(e=1, t=1, i={}) {
          super(),
          this.isRenderTarget = !0,
          this.width = e,
          this.height = t,
          this.depth = 1,
          this.scissor = new xd(0,0,e,t),
          this.scissorTest = !1,
          this.viewport = new xd(0,0,e,t);
          const n = {
              width: e,
              height: t,
              depth: 1
          };
          i = Object.assign({
              generateMipmaps: !1,
              internalFormat: null,
              minFilter: Eu,
              depthBuffer: !0,
              stencilBuffer: !1,
              resolveDepthBuffer: !0,
              resolveStencilBuffer: !0,
              depthTexture: null,
              samples: 0,
              count: 1
          }, i);
          const r = new yd(n,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);
          r.flipY = !1,
          r.generateMipmaps = i.generateMipmaps,
          r.internalFormat = i.internalFormat,
          this.textures = [];
          const s = i.count;
          for (let e = 0; e < s; e++)
              this.textures[e] = r.clone(),
              this.textures[e].isRenderTargetTexture = !0;
          this.depthBuffer = i.depthBuffer,
          this.stencilBuffer = i.stencilBuffer,
          this.resolveDepthBuffer = i.resolveDepthBuffer,
          this.resolveStencilBuffer = i.resolveStencilBuffer,
          this.depthTexture = i.depthTexture,
          this.samples = i.samples
      }
      get texture() {
          return this.textures[0]
      }
      set texture(e) {
          this.textures[0] = e
      }
      setSize(e, t, i=1) {
          if (this.width !== e || this.height !== t || this.depth !== i) {
              this.width = e,
              this.height = t,
              this.depth = i;
              for (let n = 0, r = this.textures.length; n < r; n++)
                  this.textures[n].image.width = e,
                  this.textures[n].image.height = t,
                  this.textures[n].image.depth = i;
              this.dispose()
          }
          this.viewport.set(0, 0, e, t),
          this.scissor.set(0, 0, e, t)
      }
      clone() {
          return (new this.constructor).copy(this)
      }
      copy(e) {
          this.width = e.width,
          this.height = e.height,
          this.depth = e.depth,
          this.scissor.copy(e.scissor),
          this.scissorTest = e.scissorTest,
          this.viewport.copy(e.viewport),
          this.textures.length = 0;
          for (let t = 0, i = e.textures.length; t < i; t++)
              this.textures[t] = e.textures[t].clone(),
              this.textures[t].isRenderTargetTexture = !0;
          const t = Object.assign({}, e.texture.image);
          return this.texture.source = new gd(t),
          this.depthBuffer = e.depthBuffer,
          this.stencilBuffer = e.stencilBuffer,
          this.resolveDepthBuffer = e.resolveDepthBuffer,
          this.resolveStencilBuffer = e.resolveStencilBuffer,
          null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
          this.samples = e.samples,
          this
      }
      dispose() {
          this.dispatchEvent({
              type: "dispose"
          })
      }
  }
  class Ed extends Sd {
      constructor(e=1, t=1, i={}) {
          super(e, t, i),
          this.isWebGLRenderTarget = !0
      }
  }
  class Md extends yd {
      constructor(e=null, t=1, i=1, n=1) {
          super(null),
          this.isDataArrayTexture = !0,
          this.image = {
              data: e,
              width: t,
              height: i,
              depth: n
          },
          this.magFilter = xu,
          this.minFilter = xu,
          this.wrapR = _u,
          this.generateMipmaps = !1,
          this.flipY = !1,
          this.unpackAlignment = 1,
          this.layerUpdates = new Set
      }
      addLayerUpdate(e) {
          this.layerUpdates.add(e)
      }
      clearLayerUpdates() {
          this.layerUpdates.clear()
      }
  }
  class bd extends yd {
      constructor(e=null, t=1, i=1, n=1) {
          super(null),
          this.isData3DTexture = !0,
          this.image = {
              data: e,
              width: t,
              height: i,
              depth: n
          },
          this.magFilter = xu,
          this.minFilter = xu,
          this.wrapR = _u,
          this.generateMipmaps = !1,
          this.flipY = !1,
          this.unpackAlignment = 1
      }
  }
  class Td {
      constructor(e=0, t=0, i=0, n=1) {
          this.isQuaternion = !0,
          this._x = e,
          this._y = t,
          this._z = i,
          this._w = n
      }
      static slerpFlat(e, t, i, n, r, s, a) {
          let o = i[n + 0]
            , l = i[n + 1]
            , c = i[n + 2]
            , u = i[n + 3];
          const h = r[s + 0]
            , d = r[s + 1]
            , p = r[s + 2]
            , f = r[s + 3];
          if (0 === a)
              return e[t + 0] = o,
              e[t + 1] = l,
              e[t + 2] = c,
              void (e[t + 3] = u);
          if (1 === a)
              return e[t + 0] = h,
              e[t + 1] = d,
              e[t + 2] = p,
              void (e[t + 3] = f);
          if (u !== f || o !== h || l !== d || c !== p) {
              let e = 1 - a;
              const t = o * h + l * d + c * p + u * f
                , i = t >= 0 ? 1 : -1
                , n = 1 - t * t;
              if (n > Number.EPSILON) {
                  const r = Math.sqrt(n)
                    , s = Math.atan2(r, t * i);
                  e = Math.sin(e * s) / r,
                  a = Math.sin(a * s) / r
              }
              const r = a * i;
              if (o = o * e + h * r,
              l = l * e + d * r,
              c = c * e + p * r,
              u = u * e + f * r,
              e === 1 - a) {
                  const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
                  o *= e,
                  l *= e,
                  c *= e,
                  u *= e
              }
          }
          e[t] = o,
          e[t + 1] = l,
          e[t + 2] = c,
          e[t + 3] = u
      }
      static multiplyQuaternionsFlat(e, t, i, n, r, s) {
          const a = i[n]
            , o = i[n + 1]
            , l = i[n + 2]
            , c = i[n + 3]
            , u = r[s]
            , h = r[s + 1]
            , d = r[s + 2]
            , p = r[s + 3];
          return e[t] = a * p + c * u + o * d - l * h,
          e[t + 1] = o * p + c * h + l * u - a * d,
          e[t + 2] = l * p + c * d + a * h - o * u,
          e[t + 3] = c * p - a * u - o * h - l * d,
          e
      }
      get x() {
          return this._x
      }
      set x(e) {
          this._x = e,
          this._onChangeCallback()
      }
      get y() {
          return this._y
      }
      set y(e) {
          this._y = e,
          this._onChangeCallback()
      }
      get z() {
          return this._z
      }
      set z(e) {
          this._z = e,
          this._onChangeCallback()
      }
      get w() {
          return this._w
      }
      set w(e) {
          this._w = e,
          this._onChangeCallback()
      }
      set(e, t, i, n) {
          return this._x = e,
          this._y = t,
          this._z = i,
          this._w = n,
          this._onChangeCallback(),
          this
      }
      clone() {
          return new this.constructor(this._x,this._y,this._z,this._w)
      }
      copy(e) {
          return this._x = e.x,
          this._y = e.y,
          this._z = e.z,
          this._w = e.w,
          this._onChangeCallback(),
          this
      }
      setFromEuler(e, t=!0) {
          const i = e._x
            , n = e._y
            , r = e._z
            , s = e._order
            , a = Math.cos
            , o = Math.sin
            , l = a(i / 2)
            , c = a(n / 2)
            , u = a(r / 2)
            , h = o(i / 2)
            , d = o(n / 2)
            , p = o(r / 2);
          switch (s) {
          case "XYZ":
              this._x = h * c * u + l * d * p,
              this._y = l * d * u - h * c * p,
              this._z = l * c * p + h * d * u,
              this._w = l * c * u - h * d * p;
              break;
          case "YXZ":
              this._x = h * c * u + l * d * p,
              this._y = l * d * u - h * c * p,
              this._z = l * c * p - h * d * u,
              this._w = l * c * u + h * d * p;
              break;
          case "ZXY":
              this._x = h * c * u - l * d * p,
              this._y = l * d * u + h * c * p,
              this._z = l * c * p + h * d * u,
              this._w = l * c * u - h * d * p;
              break;
          case "ZYX":
              this._x = h * c * u - l * d * p,
              this._y = l * d * u + h * c * p,
              this._z = l * c * p - h * d * u,
              this._w = l * c * u + h * d * p;
              break;
          case "YZX":
              this._x = h * c * u + l * d * p,
              this._y = l * d * u + h * c * p,
              this._z = l * c * p - h * d * u,
              this._w = l * c * u - h * d * p;
              break;
          case "XZY":
              this._x = h * c * u - l * d * p,
              this._y = l * d * u - h * c * p,
              this._z = l * c * p + h * d * u,
              this._w = l * c * u + h * d * p;
              break;
          default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
          }
          return !0 === t && this._onChangeCallback(),
          this
      }
      setFromAxisAngle(e, t) {
          const i = t / 2
            , n = Math.sin(i);
          return this._x = e.x * n,
          this._y = e.y * n,
          this._z = e.z * n,
          this._w = Math.cos(i),
          this._onChangeCallback(),
          this
      }
      setFromRotationMatrix(e) {
          const t = e.elements
            , i = t[0]
            , n = t[4]
            , r = t[8]
            , s = t[1]
            , a = t[5]
            , o = t[9]
            , l = t[2]
            , c = t[6]
            , u = t[10]
            , h = i + a + u;
          if (h > 0) {
              const e = .5 / Math.sqrt(h + 1);
              this._w = .25 / e,
              this._x = (c - o) * e,
              this._y = (r - l) * e,
              this._z = (s - n) * e
          } else if (i > a && i > u) {
              const e = 2 * Math.sqrt(1 + i - a - u);
              this._w = (c - o) / e,
              this._x = .25 * e,
              this._y = (n + s) / e,
              this._z = (r + l) / e
          } else if (a > u) {
              const e = 2 * Math.sqrt(1 + a - i - u);
              this._w = (r - l) / e,
              this._x = (n + s) / e,
              this._y = .25 * e,
              this._z = (o + c) / e
          } else {
              const e = 2 * Math.sqrt(1 + u - i - a);
              this._w = (s - n) / e,
              this._x = (r + l) / e,
              this._y = (o + c) / e,
              this._z = .25 * e
          }
          return this._onChangeCallback(),
          this
      }
      setFromUnitVectors(e, t) {
          let i = e.dot(t) + 1;
          return i < Number.EPSILON ? (i = 0,
          Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
          this._y = e.x,
          this._z = 0,
          this._w = i) : (this._x = 0,
          this._y = -e.z,
          this._z = e.y,
          this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
          this._y = e.z * t.x - e.x * t.z,
          this._z = e.x * t.y - e.y * t.x,
          this._w = i),
          this.normalize()
      }
      angleTo(e) {
          return 2 * Math.acos(Math.abs(Yh(this.dot(e), -1, 1)))
      }
      rotateTowards(e, t) {
          const i = this.angleTo(e);
          if (0 === i)
              return this;
          const n = Math.min(1, t / i);
          return this.slerp(e, n),
          this
      }
      identity() {
          return this.set(0, 0, 0, 1)
      }
      invert() {
          return this.conjugate()
      }
      conjugate() {
          return this._x *= -1,
          this._y *= -1,
          this._z *= -1,
          this._onChangeCallback(),
          this
      }
      dot(e) {
          return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
      }
      lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
      }
      length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
      }
      normalize() {
          let e = this.length();
          return 0 === e ? (this._x = 0,
          this._y = 0,
          this._z = 0,
          this._w = 1) : (e = 1 / e,
          this._x = this._x * e,
          this._y = this._y * e,
          this._z = this._z * e,
          this._w = this._w * e),
          this._onChangeCallback(),
          this
      }
      multiply(e) {
          return this.multiplyQuaternions(this, e)
      }
      premultiply(e) {
          return this.multiplyQuaternions(e, this)
      }
      multiplyQuaternions(e, t) {
          const i = e._x
            , n = e._y
            , r = e._z
            , s = e._w
            , a = t._x
            , o = t._y
            , l = t._z
            , c = t._w;
          return this._x = i * c + s * a + n * l - r * o,
          this._y = n * c + s * o + r * a - i * l,
          this._z = r * c + s * l + i * o - n * a,
          this._w = s * c - i * a - n * o - r * l,
          this._onChangeCallback(),
          this
      }
      slerp(e, t) {
          if (0 === t)
              return this;
          if (1 === t)
              return this.copy(e);
          const i = this._x
            , n = this._y
            , r = this._z
            , s = this._w;
          let a = s * e._w + i * e._x + n * e._y + r * e._z;
          if (a < 0 ? (this._w = -e._w,
          this._x = -e._x,
          this._y = -e._y,
          this._z = -e._z,
          a = -a) : this.copy(e),
          a >= 1)
              return this._w = s,
              this._x = i,
              this._y = n,
              this._z = r,
              this;
          const o = 1 - a * a;
          if (o <= Number.EPSILON) {
              const e = 1 - t;
              return this._w = e * s + t * this._w,
              this._x = e * i + t * this._x,
              this._y = e * n + t * this._y,
              this._z = e * r + t * this._z,
              this.normalize(),
              this
          }
          const l = Math.sqrt(o)
            , c = Math.atan2(l, a)
            , u = Math.sin((1 - t) * c) / l
            , h = Math.sin(t * c) / l;
          return this._w = s * u + this._w * h,
          this._x = i * u + this._x * h,
          this._y = n * u + this._y * h,
          this._z = r * u + this._z * h,
          this._onChangeCallback(),
          this
      }
      slerpQuaternions(e, t, i) {
          return this.copy(e).slerp(t, i)
      }
      random() {
          const e = 2 * Math.PI * Math.random()
            , t = 2 * Math.PI * Math.random()
            , i = Math.random()
            , n = Math.sqrt(1 - i)
            , r = Math.sqrt(i);
          return this.set(n * Math.sin(e), n * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
      }
      equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
      }
      fromArray(e, t=0) {
          return this._x = e[t],
          this._y = e[t + 1],
          this._z = e[t + 2],
          this._w = e[t + 3],
          this._onChangeCallback(),
          this
      }
      toArray(e=[], t=0) {
          return e[t] = this._x,
          e[t + 1] = this._y,
          e[t + 2] = this._z,
          e[t + 3] = this._w,
          e
      }
      fromBufferAttribute(e, t) {
          return this._x = e.getX(t),
          this._y = e.getY(t),
          this._z = e.getZ(t),
          this._w = e.getW(t),
          this._onChangeCallback(),
          this
      }
      toJSON() {
          return this.toArray()
      }
      _onChange(e) {
          return this._onChangeCallback = e,
          this
      }
      _onChangeCallback() {}
      *[Symbol.iterator]() {
          yield this._x,
          yield this._y,
          yield this._z,
          yield this._w
      }
  }
  class wd {
      constructor(e=0, t=0, i=0) {
          wd.prototype.isVector3 = !0,
          this.x = e,
          this.y = t,
          this.z = i
      }
      set(e, t, i) {
          return void 0 === i && (i = this.z),
          this.x = e,
          this.y = t,
          this.z = i,
          this
      }
      setScalar(e) {
          return this.x = e,
          this.y = e,
          this.z = e,
          this
      }
      setX(e) {
          return this.x = e,
          this
      }
      setY(e) {
          return this.y = e,
          this
      }
      setZ(e) {
          return this.z = e,
          this
      }
      setComponent(e, t) {
          switch (e) {
          case 0:
              this.x = t;
              break;
          case 1:
              this.y = t;
              break;
          case 2:
              this.z = t;
              break;
          default:
              throw new Error("index is out of range: " + e)
          }
          return this
      }
      getComponent(e) {
          switch (e) {
          case 0:
              return this.x;
          case 1:
              return this.y;
          case 2:
              return this.z;
          default:
              throw new Error("index is out of range: " + e)
          }
      }
      clone() {
          return new this.constructor(this.x,this.y,this.z)
      }
      copy(e) {
          return this.x = e.x,
          this.y = e.y,
          this.z = e.z,
          this
      }
      add(e) {
          return this.x += e.x,
          this.y += e.y,
          this.z += e.z,
          this
      }
      addScalar(e) {
          return this.x += e,
          this.y += e,
          this.z += e,
          this
      }
      addVectors(e, t) {
          return this.x = e.x + t.x,
          this.y = e.y + t.y,
          this.z = e.z + t.z,
          this
      }
      addScaledVector(e, t) {
          return this.x += e.x * t,
          this.y += e.y * t,
          this.z += e.z * t,
          this
      }
      sub(e) {
          return this.x -= e.x,
          this.y -= e.y,
          this.z -= e.z,
          this
      }
      subScalar(e) {
          return this.x -= e,
          this.y -= e,
          this.z -= e,
          this
      }
      subVectors(e, t) {
          return this.x = e.x - t.x,
          this.y = e.y - t.y,
          this.z = e.z - t.z,
          this
      }
      multiply(e) {
          return this.x *= e.x,
          this.y *= e.y,
          this.z *= e.z,
          this
      }
      multiplyScalar(e) {
          return this.x *= e,
          this.y *= e,
          this.z *= e,
          this
      }
      multiplyVectors(e, t) {
          return this.x = e.x * t.x,
          this.y = e.y * t.y,
          this.z = e.z * t.z,
          this
      }
      applyEuler(e) {
          return this.applyQuaternion(Cd.setFromEuler(e))
      }
      applyAxisAngle(e, t) {
          return this.applyQuaternion(Cd.setFromAxisAngle(e, t))
      }
      applyMatrix3(e) {
          const t = this.x
            , i = this.y
            , n = this.z
            , r = e.elements;
          return this.x = r[0] * t + r[3] * i + r[6] * n,
          this.y = r[1] * t + r[4] * i + r[7] * n,
          this.z = r[2] * t + r[5] * i + r[8] * n,
          this
      }
      applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize()
      }
      applyMatrix4(e) {
          const t = this.x
            , i = this.y
            , n = this.z
            , r = e.elements
            , s = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
          return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * s,
          this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * s,
          this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * s,
          this
      }
      applyQuaternion(e) {
          const t = this.x
            , i = this.y
            , n = this.z
            , r = e.x
            , s = e.y
            , a = e.z
            , o = e.w
            , l = 2 * (s * n - a * i)
            , c = 2 * (a * t - r * n)
            , u = 2 * (r * i - s * t);
          return this.x = t + o * l + s * u - a * c,
          this.y = i + o * c + a * l - r * u,
          this.z = n + o * u + r * c - s * l,
          this
      }
      project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
      }
      unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
      }
      transformDirection(e) {
          const t = this.x
            , i = this.y
            , n = this.z
            , r = e.elements;
          return this.x = r[0] * t + r[4] * i + r[8] * n,
          this.y = r[1] * t + r[5] * i + r[9] * n,
          this.z = r[2] * t + r[6] * i + r[10] * n,
          this.normalize()
      }
      divide(e) {
          return this.x /= e.x,
          this.y /= e.y,
          this.z /= e.z,
          this
      }
      divideScalar(e) {
          return this.multiplyScalar(1 / e)
      }
      min(e) {
          return this.x = Math.min(this.x, e.x),
          this.y = Math.min(this.y, e.y),
          this.z = Math.min(this.z, e.z),
          this
      }
      max(e) {
          return this.x = Math.max(this.x, e.x),
          this.y = Math.max(this.y, e.y),
          this.z = Math.max(this.z, e.z),
          this
      }
      clamp(e, t) {
          return this.x = Math.max(e.x, Math.min(t.x, this.x)),
          this.y = Math.max(e.y, Math.min(t.y, this.y)),
          this.z = Math.max(e.z, Math.min(t.z, this.z)),
          this
      }
      clampScalar(e, t) {
          return this.x = Math.max(e, Math.min(t, this.x)),
          this.y = Math.max(e, Math.min(t, this.y)),
          this.z = Math.max(e, Math.min(t, this.z)),
          this
      }
      clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
      }
      floor() {
          return this.x = Math.floor(this.x),
          this.y = Math.floor(this.y),
          this.z = Math.floor(this.z),
          this
      }
      ceil() {
          return this.x = Math.ceil(this.x),
          this.y = Math.ceil(this.y),
          this.z = Math.ceil(this.z),
          this
      }
      round() {
          return this.x = Math.round(this.x),
          this.y = Math.round(this.y),
          this.z = Math.round(this.z),
          this
      }
      roundToZero() {
          return this.x = Math.trunc(this.x),
          this.y = Math.trunc(this.y),
          this.z = Math.trunc(this.z),
          this
      }
      negate() {
          return this.x = -this.x,
          this.y = -this.y,
          this.z = -this.z,
          this
      }
      dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z
      }
      lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z
      }
      length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
      }
      manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
      }
      normalize() {
          return this.divideScalar(this.length() || 1)
      }
      setLength(e) {
          return this.normalize().multiplyScalar(e)
      }
      lerp(e, t) {
          return this.x += (e.x - this.x) * t,
          this.y += (e.y - this.y) * t,
          this.z += (e.z - this.z) * t,
          this
      }
      lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i,
          this.y = e.y + (t.y - e.y) * i,
          this.z = e.z + (t.z - e.z) * i,
          this
      }
      cross(e) {
          return this.crossVectors(this, e)
      }
      crossVectors(e, t) {
          const i = e.x
            , n = e.y
            , r = e.z
            , s = t.x
            , a = t.y
            , o = t.z;
          return this.x = n * o - r * a,
          this.y = r * s - i * o,
          this.z = i * a - n * s,
          this
      }
      projectOnVector(e) {
          const t = e.lengthSq();
          if (0 === t)
              return this.set(0, 0, 0);
          const i = e.dot(this) / t;
          return this.copy(e).multiplyScalar(i)
      }
      projectOnPlane(e) {
          return Dd.copy(this).projectOnVector(e),
          this.sub(Dd)
      }
      reflect(e) {
          return this.sub(Dd.copy(e).multiplyScalar(2 * this.dot(e)))
      }
      angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t)
              return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(Yh(i, -1, 1))
      }
      distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e))
      }
      distanceToSquared(e) {
          const t = this.x - e.x
            , i = this.y - e.y
            , n = this.z - e.z;
          return t * t + i * i + n * n
      }
      manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
      }
      setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
      }
      setFromSphericalCoords(e, t, i) {
          const n = Math.sin(t) * e;
          return this.x = n * Math.sin(i),
          this.y = Math.cos(t) * e,
          this.z = n * Math.cos(i),
          this
      }
      setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
      }
      setFromCylindricalCoords(e, t, i) {
          return this.x = e * Math.sin(t),
          this.y = i,
          this.z = e * Math.cos(t),
          this
      }
      setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12],
          this.y = t[13],
          this.z = t[14],
          this
      }
      setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length()
            , i = this.setFromMatrixColumn(e, 1).length()
            , n = this.setFromMatrixColumn(e, 2).length();
          return this.x = t,
          this.y = i,
          this.z = n,
          this
      }
      setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, 4 * t)
      }
      setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, 3 * t)
      }
      setFromEuler(e) {
          return this.x = e._x,
          this.y = e._y,
          this.z = e._z,
          this
      }
      setFromColor(e) {
          return this.x = e.r,
          this.y = e.g,
          this.z = e.b,
          this
      }
      equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z
      }
      fromArray(e, t=0) {
          return this.x = e[t],
          this.y = e[t + 1],
          this.z = e[t + 2],
          this
      }
      toArray(e=[], t=0) {
          return e[t] = this.x,
          e[t + 1] = this.y,
          e[t + 2] = this.z,
          e
      }
      fromBufferAttribute(e, t) {
          return this.x = e.getX(t),
          this.y = e.getY(t),
          this.z = e.getZ(t),
          this
      }
      random() {
          return this.x = Math.random(),
          this.y = Math.random(),
          this.z = Math.random(),
          this
      }
      randomDirection() {
          const e = Math.random() * Math.PI * 2
            , t = 2 * Math.random() - 1
            , i = Math.sqrt(1 - t * t);
          return this.x = i * Math.cos(e),
          this.y = t,
          this.z = i * Math.sin(e),
          this
      }
      *[Symbol.iterator]() {
          yield this.x,
          yield this.y,
          yield this.z
      }
  }
  const Dd = new wd
    , Cd = new Td;
  class Ad {
      constructor(e=new wd(1 / 0,1 / 0,1 / 0), t=new wd(-1 / 0,-1 / 0,-1 / 0)) {
          this.isBox3 = !0,
          this.min = e,
          this.max = t
      }
      set(e, t) {
          return this.min.copy(e),
          this.max.copy(t),
          this
      }
      setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t += 3)
              this.expandByPoint(Rd.fromArray(e, t));
          return this
      }
      setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, i = e.count; t < i; t++)
              this.expandByPoint(Rd.fromBufferAttribute(e, t));
          return this
      }
      setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t++)
              this.expandByPoint(e[t]);
          return this
      }
      setFromCenterAndSize(e, t) {
          const i = Rd.copy(t).multiplyScalar(.5);
          return this.min.copy(e).sub(i),
          this.max.copy(e).add(i),
          this
      }
      setFromObject(e, t=!1) {
          return this.makeEmpty(),
          this.expandByObject(e, t)
      }
      clone() {
          return (new this.constructor).copy(this)
      }
      copy(e) {
          return this.min.copy(e.min),
          this.max.copy(e.max),
          this
      }
      makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0,
          this.max.x = this.max.y = this.max.z = -1 / 0,
          this
      }
      isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
      }
      getCenter(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
      }
      getSize(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
      }
      expandByPoint(e) {
          return this.min.min(e),
          this.max.max(e),
          this
      }
      expandByVector(e) {
          return this.min.sub(e),
          this.max.add(e),
          this
      }
      expandByScalar(e) {
          return this.min.addScalar(-e),
          this.max.addScalar(e),
          this
      }
      expandByObject(e, t=!1) {
          e.updateWorldMatrix(!1, !1);
          const i = e.geometry;
          if (void 0 !== i) {
              const n = i.getAttribute("position");
              if (!0 === t && void 0 !== n && !0 !== e.isInstancedMesh)
                  for (let t = 0, i = n.count; t < i; t++)
                      !0 === e.isMesh ? e.getVertexPosition(t, Rd) : Rd.fromBufferAttribute(n, t),
                      Rd.applyMatrix4(e.matrixWorld),
                      this.expandByPoint(Rd);
              else
                  void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(),
                  Ld.copy(e.boundingBox)) : (null === i.boundingBox && i.computeBoundingBox(),
                  Ld.copy(i.boundingBox)),
                  Ld.applyMatrix4(e.matrixWorld),
                  this.union(Ld)
          }
          const n = e.children;
          for (let e = 0, i = n.length; e < i; e++)
              this.expandByObject(n[e], t);
          return this
      }
      containsPoint(e) {
          return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
      }
      containsBox(e) {
          return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
      }
      getParameter(e, t) {
          return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
      }
      intersectsBox(e) {
          return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
      }
      intersectsSphere(e) {
          return this.clampPoint(e.center, Rd),
          Rd.distanceToSquared(e.center) <= e.radius * e.radius
      }
      intersectsPlane(e) {
          let t, i;
          return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
          i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
          i = e.normal.x * this.min.x),
          e.normal.y > 0 ? (t += e.normal.y * this.min.y,
          i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
          i += e.normal.y * this.min.y),
          e.normal.z > 0 ? (t += e.normal.z * this.min.z,
          i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
          i += e.normal.z * this.min.z),
          t <= -e.constant && i >= -e.constant
      }
      intersectsTriangle(e) {
          if (this.isEmpty())
              return !1;
          this.getCenter(zd),
          kd.subVectors(this.max, zd),
          Id.subVectors(e.a, zd),
          Nd.subVectors(e.b, zd),
          Fd.subVectors(e.c, zd),
          Od.subVectors(Nd, Id),
          Ud.subVectors(Fd, Nd),
          Bd.subVectors(Id, Fd);
          let t = [0, -Od.z, Od.y, 0, -Ud.z, Ud.y, 0, -Bd.z, Bd.y, Od.z, 0, -Od.x, Ud.z, 0, -Ud.x, Bd.z, 0, -Bd.x, -Od.y, Od.x, 0, -Ud.y, Ud.x, 0, -Bd.y, Bd.x, 0];
          return !!Gd(t, Id, Nd, Fd, kd) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
          !!Gd(t, Id, Nd, Fd, kd) && (Vd.crossVectors(Od, Ud),
          t = [Vd.x, Vd.y, Vd.z],
          Gd(t, Id, Nd, Fd, kd)))
      }
      clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max)
      }
      distanceToPoint(e) {
          return this.clampPoint(e, Rd).distanceTo(e)
      }
      getBoundingSphere(e) {
          return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
          e.radius = .5 * this.getSize(Rd).length()),
          e
      }
      intersect(e) {
          return this.min.max(e.min),
          this.max.min(e.max),
          this.isEmpty() && this.makeEmpty(),
          this
      }
      union(e) {
          return this.min.min(e.min),
          this.max.max(e.max),
          this
      }
      applyMatrix4(e) {
          return this.isEmpty() || (Pd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
          Pd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
          Pd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
          Pd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
          Pd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
          Pd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
          Pd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
          Pd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
          this.setFromPoints(Pd)),
          this
      }
      translate(e) {
          return this.min.add(e),
          this.max.add(e),
          this
      }
      equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max)
      }
  }
  const Pd = [new wd, new wd, new wd, new wd, new wd, new wd, new wd, new wd]
    , Rd = new wd
    , Ld = new Ad
    , Id = new wd
    , Nd = new wd
    , Fd = new wd
    , Od = new wd
    , Ud = new wd
    , Bd = new wd
    , zd = new wd
    , kd = new wd
    , Vd = new wd
    , Hd = new wd;
  function Gd(e, t, i, n, r) {
      for (let s = 0, a = e.length - 3; s <= a; s += 3) {
          Hd.fromArray(e, s);
          const a = r.x * Math.abs(Hd.x) + r.y * Math.abs(Hd.y) + r.z * Math.abs(Hd.z)
            , o = t.dot(Hd)
            , l = i.dot(Hd)
            , c = n.dot(Hd);
          if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a)
              return !1
      }
      return !0
  }
  const Wd = new Ad
    , Xd = new wd
    , qd = new wd;
  class jd {
      constructor(e=new wd, t=-1) {
          this.isSphere = !0,
          this.center = e,
          this.radius = t
      }
      set(e, t) {
          return this.center.copy(e),
          this.radius = t,
          this
      }
      setFromPoints(e, t) {
          const i = this.center;
          void 0 !== t ? i.copy(t) : Wd.setFromPoints(e).getCenter(i);
          let n = 0;
          for (let t = 0, r = e.length; t < r; t++)
              n = Math.max(n, i.distanceToSquared(e[t]));
          return this.radius = Math.sqrt(n),
          this
      }
      copy(e) {
          return this.center.copy(e.center),
          this.radius = e.radius,
          this
      }
      isEmpty() {
          return this.radius < 0
      }
      makeEmpty() {
          return this.center.set(0, 0, 0),
          this.radius = -1,
          this
      }
      containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius
      }
      distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius
      }
      intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t
      }
      intersectsBox(e) {
          return e.intersectsSphere(this)
      }
      intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius
      }
      clampPoint(e, t) {
          const i = this.center.distanceToSquared(e);
          return t.copy(e),
          i > this.radius * this.radius && (t.sub(this.center).normalize(),
          t.multiplyScalar(this.radius).add(this.center)),
          t
      }
      getBoundingBox(e) {
          return this.isEmpty() ? (e.makeEmpty(),
          e) : (e.set(this.center, this.center),
          e.expandByScalar(this.radius),
          e)
      }
      applyMatrix4(e) {
          return this.center.applyMatrix4(e),
          this.radius = this.radius * e.getMaxScaleOnAxis(),
          this
      }
      translate(e) {
          return this.center.add(e),
          this
      }
      expandByPoint(e) {
          if (this.isEmpty())
              return this.center.copy(e),
              this.radius = 0,
              this;
          Xd.subVectors(e, this.center);
          const t = Xd.lengthSq();
          if (t > this.radius * this.radius) {
              const e = Math.sqrt(t)
                , i = .5 * (e - this.radius);
              this.center.addScaledVector(Xd, i / e),
              this.radius += i
          }
          return this
      }
      union(e) {
          return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
          this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (qd.subVectors(e.center, this.center).setLength(e.radius),
          this.expandByPoint(Xd.copy(e.center).add(qd)),
          this.expandByPoint(Xd.copy(e.center).sub(qd))),
          this)
      }
      equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius
      }
      clone() {
          return (new this.constructor).copy(this)
      }
  }
  const Yd = new wd
    , Kd = new wd
    , Zd = new wd
    , $d = new wd
    , Jd = new wd
    , Qd = new wd
    , ep = new wd;
  class tp {
      constructor(e=new wd, t=new wd(0,0,-1)) {
          this.origin = e,
          this.direction = t
      }
      set(e, t) {
          return this.origin.copy(e),
          this.direction.copy(t),
          this
      }
      copy(e) {
          return this.origin.copy(e.origin),
          this.direction.copy(e.direction),
          this
      }
      at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e)
      }
      lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(),
          this
      }
      recast(e) {
          return this.origin.copy(this.at(e, Yd)),
          this
      }
      closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const i = t.dot(this.direction);
          return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
      }
      distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e))
      }
      distanceSqToPoint(e) {
          const t = Yd.subVectors(e, this.origin).dot(this.direction);
          return t < 0 ? this.origin.distanceToSquared(e) : (Yd.copy(this.origin).addScaledVector(this.direction, t),
          Yd.distanceToSquared(e))
      }
      distanceSqToSegment(e, t, i, n) {
          Kd.copy(e).add(t).multiplyScalar(.5),
          Zd.copy(t).sub(e).normalize(),
          $d.copy(this.origin).sub(Kd);
          const r = .5 * e.distanceTo(t)
            , s = -this.direction.dot(Zd)
            , a = $d.dot(this.direction)
            , o = -$d.dot(Zd)
            , l = $d.lengthSq()
            , c = Math.abs(1 - s * s);
          let u, h, d, p;
          if (c > 0)
              if (u = s * o - a,
              h = s * a - o,
              p = r * c,
              u >= 0)
                  if (h >= -p)
                      if (h <= p) {
                          const e = 1 / c;
                          u *= e,
                          h *= e,
                          d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l
                      } else
                          h = r,
                          u = Math.max(0, -(s * h + a)),
                          d = -u * u + h * (h + 2 * o) + l;
                  else
                      h = -r,
                      u = Math.max(0, -(s * h + a)),
                      d = -u * u + h * (h + 2 * o) + l;
              else
                  h <= -p ? (u = Math.max(0, -(-s * r + a)),
                  h = u > 0 ? -r : Math.min(Math.max(-r, -o), r),
                  d = -u * u + h * (h + 2 * o) + l) : h <= p ? (u = 0,
                  h = Math.min(Math.max(-r, -o), r),
                  d = h * (h + 2 * o) + l) : (u = Math.max(0, -(s * r + a)),
                  h = u > 0 ? r : Math.min(Math.max(-r, -o), r),
                  d = -u * u + h * (h + 2 * o) + l);
          else
              h = s > 0 ? -r : r,
              u = Math.max(0, -(s * h + a)),
              d = -u * u + h * (h + 2 * o) + l;
          return i && i.copy(this.origin).addScaledVector(this.direction, u),
          n && n.copy(Kd).addScaledVector(Zd, h),
          d
      }
      intersectSphere(e, t) {
          Yd.subVectors(e.center, this.origin);
          const i = Yd.dot(this.direction)
            , n = Yd.dot(Yd) - i * i
            , r = e.radius * e.radius;
          if (n > r)
              return null;
          const s = Math.sqrt(r - n)
            , a = i - s
            , o = i + s;
          return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
      }
      intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius
      }
      distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (0 === t)
              return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          const i = -(this.origin.dot(e.normal) + e.constant) / t;
          return i >= 0 ? i : null
      }
      intersectPlane(e, t) {
          const i = this.distanceToPlane(e);
          return null === i ? null : this.at(i, t)
      }
      intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return 0 === t || e.normal.dot(this.direction) * t < 0
      }
      intersectBox(e, t) {
          let i, n, r, s, a, o;
          const l = 1 / this.direction.x
            , c = 1 / this.direction.y
            , u = 1 / this.direction.z
            , h = this.origin;
          return l >= 0 ? (i = (e.min.x - h.x) * l,
          n = (e.max.x - h.x) * l) : (i = (e.max.x - h.x) * l,
          n = (e.min.x - h.x) * l),
          c >= 0 ? (r = (e.min.y - h.y) * c,
          s = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c,
          s = (e.min.y - h.y) * c),
          i > s || r > n ? null : ((r > i || isNaN(i)) && (i = r),
          (s < n || isNaN(n)) && (n = s),
          u >= 0 ? (a = (e.min.z - h.z) * u,
          o = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u,
          o = (e.min.z - h.z) * u),
          i > o || a > n ? null : ((a > i || i != i) && (i = a),
          (o < n || n != n) && (n = o),
          n < 0 ? null : this.at(i >= 0 ? i : n, t)))
      }
      intersectsBox(e) {
          return null !== this.intersectBox(e, Yd)
      }
      intersectTriangle(e, t, i, n, r) {
          Jd.subVectors(t, e),
          Qd.subVectors(i, e),
          ep.crossVectors(Jd, Qd);
          let s, a = this.direction.dot(ep);
          if (a > 0) {
              if (n)
                  return null;
              s = 1
          } else {
              if (!(a < 0))
                  return null;
              s = -1,
              a = -a
          }
          $d.subVectors(this.origin, e);
          const o = s * this.direction.dot(Qd.crossVectors($d, Qd));
          if (o < 0)
              return null;
          const l = s * this.direction.dot(Jd.cross($d));
          if (l < 0)
              return null;
          if (o + l > a)
              return null;
          const c = -s * $d.dot(ep);
          return c < 0 ? null : this.at(c / a, r)
      }
      applyMatrix4(e) {
          return this.origin.applyMatrix4(e),
          this.direction.transformDirection(e),
          this
      }
      equals(e) {
          return e.origin.equals(this.origin) && e.direction.equals(this.direction)
      }
      clone() {
          return (new this.constructor).copy(this)
      }
  }
  class ip {
      constructor(e, t, i, n, r, s, a, o, l, c, u, h, d, p, f, m) {
          ip.prototype.isMatrix4 = !0,
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
          void 0 !== e && this.set(e, t, i, n, r, s, a, o, l, c, u, h, d, p, f, m)
      }
      set(e, t, i, n, r, s, a, o, l, c, u, h, d, p, f, m) {
          const g = this.elements;
          return g[0] = e,
          g[4] = t,
          g[8] = i,
          g[12] = n,
          g[1] = r,
          g[5] = s,
          g[9] = a,
          g[13] = o,
          g[2] = l,
          g[6] = c,
          g[10] = u,
          g[14] = h,
          g[3] = d,
          g[7] = p,
          g[11] = f,
          g[15] = m,
          this
      }
      identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
          this
      }
      clone() {
          return (new ip).fromArray(this.elements)
      }
      copy(e) {
          const t = this.elements
            , i = e.elements;
          return t[0] = i[0],
          t[1] = i[1],
          t[2] = i[2],
          t[3] = i[3],
          t[4] = i[4],
          t[5] = i[5],
          t[6] = i[6],
          t[7] = i[7],
          t[8] = i[8],
          t[9] = i[9],
          t[10] = i[10],
          t[11] = i[11],
          t[12] = i[12],
          t[13] = i[13],
          t[14] = i[14],
          t[15] = i[15],
          this
      }
      copyPosition(e) {
          const t = this.elements
            , i = e.elements;
          return t[12] = i[12],
          t[13] = i[13],
          t[14] = i[14],
          this
      }
      setFromMatrix3(e) {
          const t = e.elements;
          return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
          this
      }
      extractBasis(e, t, i) {
          return e.setFromMatrixColumn(this, 0),
          t.setFromMatrixColumn(this, 1),
          i.setFromMatrixColumn(this, 2),
          this
      }
      makeBasis(e, t, i) {
          return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
          this
      }
      extractRotation(e) {
          const t = this.elements
            , i = e.elements
            , n = 1 / np.setFromMatrixColumn(e, 0).length()
            , r = 1 / np.setFromMatrixColumn(e, 1).length()
            , s = 1 / np.setFromMatrixColumn(e, 2).length();
          return t[0] = i[0] * n,
          t[1] = i[1] * n,
          t[2] = i[2] * n,
          t[3] = 0,
          t[4] = i[4] * r,
          t[5] = i[5] * r,
          t[6] = i[6] * r,
          t[7] = 0,
          t[8] = i[8] * s,
          t[9] = i[9] * s,
          t[10] = i[10] * s,
          t[11] = 0,
          t[12] = 0,
          t[13] = 0,
          t[14] = 0,
          t[15] = 1,
          this
      }
      makeRotationFromEuler(e) {
          const t = this.elements
            , i = e.x
            , n = e.y
            , r = e.z
            , s = Math.cos(i)
            , a = Math.sin(i)
            , o = Math.cos(n)
            , l = Math.sin(n)
            , c = Math.cos(r)
            , u = Math.sin(r);
          if ("XYZ" === e.order) {
              const e = s * c
                , i = s * u
                , n = a * c
                , r = a * u;
              t[0] = o * c,
              t[4] = -o * u,
              t[8] = l,
              t[1] = i + n * l,
              t[5] = e - r * l,
              t[9] = -a * o,
              t[2] = r - e * l,
              t[6] = n + i * l,
              t[10] = s * o
          } else if ("YXZ" === e.order) {
              const e = o * c
                , i = o * u
                , n = l * c
                , r = l * u;
              t[0] = e + r * a,
              t[4] = n * a - i,
              t[8] = s * l,
              t[1] = s * u,
              t[5] = s * c,
              t[9] = -a,
              t[2] = i * a - n,
              t[6] = r + e * a,
              t[10] = s * o
          } else if ("ZXY" === e.order) {
              const e = o * c
                , i = o * u
                , n = l * c
                , r = l * u;
              t[0] = e - r * a,
              t[4] = -s * u,
              t[8] = n + i * a,
              t[1] = i + n * a,
              t[5] = s * c,
              t[9] = r - e * a,
              t[2] = -s * l,
              t[6] = a,
              t[10] = s * o
          } else if ("ZYX" === e.order) {
              const e = s * c
                , i = s * u
                , n = a * c
                , r = a * u;
              t[0] = o * c,
              t[4] = n * l - i,
              t[8] = e * l + r,
              t[1] = o * u,
              t[5] = r * l + e,
              t[9] = i * l - n,
              t[2] = -l,
              t[6] = a * o,
              t[10] = s * o
          } else if ("YZX" === e.order) {
              const e = s * o
                , i = s * l
                , n = a * o
                , r = a * l;
              t[0] = o * c,
              t[4] = r - e * u,
              t[8] = n * u + i,
              t[1] = u,
              t[5] = s * c,
              t[9] = -a * c,
              t[2] = -l * c,
              t[6] = i * u + n,
              t[10] = e - r * u
          } else if ("XZY" === e.order) {
              const e = s * o
                , i = s * l
                , n = a * o
                , r = a * l;
              t[0] = o * c,
              t[4] = -u,
              t[8] = l * c,
              t[1] = e * u + r,
              t[5] = s * c,
              t[9] = i * u - n,
              t[2] = n * u - i,
              t[6] = a * c,
              t[10] = r * u + e
          }
          return t[3] = 0,
          t[7] = 0,
          t[11] = 0,
          t[12] = 0,
          t[13] = 0,
          t[14] = 0,
          t[15] = 1,
          this
      }
      makeRotationFromQuaternion(e) {
          return this.compose(sp, e, ap)
      }
      lookAt(e, t, i) {
          const n = this.elements;
          return cp.subVectors(e, t),
          0 === cp.lengthSq() && (cp.z = 1),
          cp.normalize(),
          op.crossVectors(i, cp),
          0 === op.lengthSq() && (1 === Math.abs(i.z) ? cp.x += 1e-4 : cp.z += 1e-4,
          cp.normalize(),
          op.crossVectors(i, cp)),
          op.normalize(),
          lp.crossVectors(cp, op),
          n[0] = op.x,
          n[4] = lp.x,
          n[8] = cp.x,
          n[1] = op.y,
          n[5] = lp.y,
          n[9] = cp.y,
          n[2] = op.z,
          n[6] = lp.z,
          n[10] = cp.z,
          this
      }
      multiply(e) {
          return this.multiplyMatrices(this, e)
      }
      premultiply(e) {
          return this.multiplyMatrices(e, this)
      }
      multiplyMatrices(e, t) {
          const i = e.elements
            , n = t.elements
            , r = this.elements
            , s = i[0]
            , a = i[4]
            , o = i[8]
            , l = i[12]
            , c = i[1]
            , u = i[5]
            , h = i[9]
            , d = i[13]
            , p = i[2]
            , f = i[6]
            , m = i[10]
            , g = i[14]
            , v = i[3]
            , _ = i[7]
            , y = i[11]
            , x = i[15]
            , S = n[0]
            , E = n[4]
            , M = n[8]
            , b = n[12]
            , T = n[1]
            , w = n[5]
            , D = n[9]
            , C = n[13]
            , A = n[2]
            , P = n[6]
            , R = n[10]
            , L = n[14]
            , I = n[3]
            , N = n[7]
            , F = n[11]
            , O = n[15];
          return r[0] = s * S + a * T + o * A + l * I,
          r[4] = s * E + a * w + o * P + l * N,
          r[8] = s * M + a * D + o * R + l * F,
          r[12] = s * b + a * C + o * L + l * O,
          r[1] = c * S + u * T + h * A + d * I,
          r[5] = c * E + u * w + h * P + d * N,
          r[9] = c * M + u * D + h * R + d * F,
          r[13] = c * b + u * C + h * L + d * O,
          r[2] = p * S + f * T + m * A + g * I,
          r[6] = p * E + f * w + m * P + g * N,
          r[10] = p * M + f * D + m * R + g * F,
          r[14] = p * b + f * C + m * L + g * O,
          r[3] = v * S + _ * T + y * A + x * I,
          r[7] = v * E + _ * w + y * P + x * N,
          r[11] = v * M + _ * D + y * R + x * F,
          r[15] = v * b + _ * C + y * L + x * O,
          this
      }
      multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e,
          t[4] *= e,
          t[8] *= e,
          t[12] *= e,
          t[1] *= e,
          t[5] *= e,
          t[9] *= e,
          t[13] *= e,
          t[2] *= e,
          t[6] *= e,
          t[10] *= e,
          t[14] *= e,
          t[3] *= e,
          t[7] *= e,
          t[11] *= e,
          t[15] *= e,
          this
      }
      determinant() {
          const e = this.elements
            , t = e[0]
            , i = e[4]
            , n = e[8]
            , r = e[12]
            , s = e[1]
            , a = e[5]
            , o = e[9]
            , l = e[13]
            , c = e[2]
            , u = e[6]
            , h = e[10]
            , d = e[14];
          return e[3] * (+r * o * u - n * l * u - r * a * h + i * l * h + n * a * d - i * o * d) + e[7] * (+t * o * d - t * l * h + r * s * h - n * s * d + n * l * c - r * o * c) + e[11] * (+t * l * u - t * a * d - r * s * u + i * s * d + r * a * c - i * l * c) + e[15] * (-n * a * c - t * o * u + t * a * h + n * s * u - i * s * h + i * o * c)
      }
      transpose() {
          const e = this.elements;
          let t;
          return t = e[1],
          e[1] = e[4],
          e[4] = t,
          t = e[2],
          e[2] = e[8],
          e[8] = t,
          t = e[6],
          e[6] = e[9],
          e[9] = t,
          t = e[3],
          e[3] = e[12],
          e[12] = t,
          t = e[7],
          e[7] = e[13],
          e[13] = t,
          t = e[11],
          e[11] = e[14],
          e[14] = t,
          this
      }
      setPosition(e, t, i) {
          const n = this.elements;
          return e.isVector3 ? (n[12] = e.x,
          n[13] = e.y,
          n[14] = e.z) : (n[12] = e,
          n[13] = t,
          n[14] = i),
          this
      }
      invert() {
          const e = this.elements
            , t = e[0]
            , i = e[1]
            , n = e[2]
            , r = e[3]
            , s = e[4]
            , a = e[5]
            , o = e[6]
            , l = e[7]
            , c = e[8]
            , u = e[9]
            , h = e[10]
            , d = e[11]
            , p = e[12]
            , f = e[13]
            , m = e[14]
            , g = e[15]
            , v = u * m * l - f * h * l + f * o * d - a * m * d - u * o * g + a * h * g
            , _ = p * h * l - c * m * l - p * o * d + s * m * d + c * o * g - s * h * g
            , y = c * f * l - p * u * l + p * a * d - s * f * d - c * a * g + s * u * g
            , x = p * u * o - c * f * o - p * a * h + s * f * h + c * a * m - s * u * m
            , S = t * v + i * _ + n * y + r * x;
          if (0 === S)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const E = 1 / S;
          return e[0] = v * E,
          e[1] = (f * h * r - u * m * r - f * n * d + i * m * d + u * n * g - i * h * g) * E,
          e[2] = (a * m * r - f * o * r + f * n * l - i * m * l - a * n * g + i * o * g) * E,
          e[3] = (u * o * r - a * h * r - u * n * l + i * h * l + a * n * d - i * o * d) * E,
          e[4] = _ * E,
          e[5] = (c * m * r - p * h * r + p * n * d - t * m * d - c * n * g + t * h * g) * E,
          e[6] = (p * o * r - s * m * r - p * n * l + t * m * l + s * n * g - t * o * g) * E,
          e[7] = (s * h * r - c * o * r + c * n * l - t * h * l - s * n * d + t * o * d) * E,
          e[8] = y * E,
          e[9] = (p * u * r - c * f * r - p * i * d + t * f * d + c * i * g - t * u * g) * E,
          e[10] = (s * f * r - p * a * r + p * i * l - t * f * l - s * i * g + t * a * g) * E,
          e[11] = (c * a * r - s * u * r - c * i * l + t * u * l + s * i * d - t * a * d) * E,
          e[12] = x * E,
          e[13] = (c * f * n - p * u * n + p * i * h - t * f * h - c * i * m + t * u * m) * E,
          e[14] = (p * a * n - s * f * n - p * i * o + t * f * o + s * i * m - t * a * m) * E,
          e[15] = (s * u * n - c * a * n + c * i * o - t * u * o - s * i * h + t * a * h) * E,
          this
      }
      scale(e) {
          const t = this.elements
            , i = e.x
            , n = e.y
            , r = e.z;
          return t[0] *= i,
          t[4] *= n,
          t[8] *= r,
          t[1] *= i,
          t[5] *= n,
          t[9] *= r,
          t[2] *= i,
          t[6] *= n,
          t[10] *= r,
          t[3] *= i,
          t[7] *= n,
          t[11] *= r,
          this
      }
      getMaxScaleOnAxis() {
          const e = this.elements
            , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
            , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
            , n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, i, n))
      }
      makeTranslation(e, t, i) {
          return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
          this
      }
      makeRotationX(e) {
          const t = Math.cos(e)
            , i = Math.sin(e);
          return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
          this
      }
      makeRotationY(e) {
          const t = Math.cos(e)
            , i = Math.sin(e);
          return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
          this
      }
      makeRotationZ(e) {
          const t = Math.cos(e)
            , i = Math.sin(e);
          return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
          this
      }
      makeRotationAxis(e, t) {
          const i = Math.cos(t)
            , n = Math.sin(t)
            , r = 1 - i
            , s = e.x
            , a = e.y
            , o = e.z
            , l = r * s
            , c = r * a;
          return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, c * a + i, c * o - n * s, 0, l * o - n * a, c * o + n * s, r * o * o + i, 0, 0, 0, 0, 1),
          this
      }
      makeScale(e, t, i) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
          this
      }
      makeShear(e, t, i, n, r, s) {
          return this.set(1, i, r, 0, e, 1, s, 0, t, n, 1, 0, 0, 0, 0, 1),
          this
      }
      compose(e, t, i) {
          const n = this.elements
            , r = t._x
            , s = t._y
            , a = t._z
            , o = t._w
            , l = r + r
            , c = s + s
            , u = a + a
            , h = r * l
            , d = r * c
            , p = r * u
            , f = s * c
            , m = s * u
            , g = a * u
            , v = o * l
            , _ = o * c
            , y = o * u
            , x = i.x
            , S = i.y
            , E = i.z;
          return n[0] = (1 - (f + g)) * x,
          n[1] = (d + y) * x,
          n[2] = (p - _) * x,
          n[3] = 0,
          n[4] = (d - y) * S,
          n[5] = (1 - (h + g)) * S,
          n[6] = (m + v) * S,
          n[7] = 0,
          n[8] = (p + _) * E,
          n[9] = (m - v) * E,
          n[10] = (1 - (h + f)) * E,
          n[11] = 0,
          n[12] = e.x,
          n[13] = e.y,
          n[14] = e.z,
          n[15] = 1,
          this
      }
      decompose(e, t, i) {
          const n = this.elements;
          let r = np.set(n[0], n[1], n[2]).length();
          const s = np.set(n[4], n[5], n[6]).length()
            , a = np.set(n[8], n[9], n[10]).length();
          this.determinant() < 0 && (r = -r),
          e.x = n[12],
          e.y = n[13],
          e.z = n[14],
          rp.copy(this);
          const o = 1 / r
            , l = 1 / s
            , c = 1 / a;
          return rp.elements[0] *= o,
          rp.elements[1] *= o,
          rp.elements[2] *= o,
          rp.elements[4] *= l,
          rp.elements[5] *= l,
          rp.elements[6] *= l,
          rp.elements[8] *= c,
          rp.elements[9] *= c,
          rp.elements[10] *= c,
          t.setFromRotationMatrix(rp),
          i.x = r,
          i.y = s,
          i.z = a,
          this
      }
      makePerspective(e, t, i, n, r, s, a=2e3) {
          const o = this.elements
            , l = 2 * r / (t - e)
            , c = 2 * r / (i - n)
            , u = (t + e) / (t - e)
            , h = (i + n) / (i - n);
          let d, p;
          if (a === Vh)
              d = -(s + r) / (s - r),
              p = -2 * s * r / (s - r);
          else {
              if (a !== Hh)
                  throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
              d = -s / (s - r),
              p = -s * r / (s - r)
          }
          return o[0] = l,
          o[4] = 0,
          o[8] = u,
          o[12] = 0,
          o[1] = 0,
          o[5] = c,
          o[9] = h,
          o[13] = 0,
          o[2] = 0,
          o[6] = 0,
          o[10] = d,
          o[14] = p,
          o[3] = 0,
          o[7] = 0,
          o[11] = -1,
          o[15] = 0,
          this
      }
      makeOrthographic(e, t, i, n, r, s, a=2e3) {
          const o = this.elements
            , l = 1 / (t - e)
            , c = 1 / (i - n)
            , u = 1 / (s - r)
            , h = (t + e) * l
            , d = (i + n) * c;
          let p, f;
          if (a === Vh)
              p = (s + r) * u,
              f = -2 * u;
          else {
              if (a !== Hh)
                  throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
              p = r * u,
              f = -1 * u
          }
          return o[0] = 2 * l,
          o[4] = 0,
          o[8] = 0,
          o[12] = -h,
          o[1] = 0,
          o[5] = 2 * c,
          o[9] = 0,
          o[13] = -d,
          o[2] = 0,
          o[6] = 0,
          o[10] = f,
          o[14] = -p,
          o[3] = 0,
          o[7] = 0,
          o[11] = 0,
          o[15] = 1,
          this
      }
      equals(e) {
          const t = this.elements
            , i = e.elements;
          for (let e = 0; e < 16; e++)
              if (t[e] !== i[e])
                  return !1;
          return !0
      }
      fromArray(e, t=0) {
          for (let i = 0; i < 16; i++)
              this.elements[i] = e[i + t];
          return this
      }
      toArray(e=[], t=0) {
          const i = this.elements;
          return e[t] = i[0],
          e[t + 1] = i[1],
          e[t + 2] = i[2],
          e[t + 3] = i[3],
          e[t + 4] = i[4],
          e[t + 5] = i[5],
          e[t + 6] = i[6],
          e[t + 7] = i[7],
          e[t + 8] = i[8],
          e[t + 9] = i[9],
          e[t + 10] = i[10],
          e[t + 11] = i[11],
          e[t + 12] = i[12],
          e[t + 13] = i[13],
          e[t + 14] = i[14],
          e[t + 15] = i[15],
          e
      }
  }
  const np = new wd
    , rp = new ip
    , sp = new wd(0,0,0)
    , ap = new wd(1,1,1)
    , op = new wd
    , lp = new wd
    , cp = new wd
    , up = new ip
    , hp = new Td;
  class dp {
      constructor(e=0, t=0, i=0, n=dp.DEFAULT_ORDER) {
          this.isEuler = !0,
          this._x = e,
          this._y = t,
          this._z = i,
          this._order = n
      }
      get x() {
          return this._x
      }
      set x(e) {
          this._x = e,
          this._onChangeCallback()
      }
      get y() {
          return this._y
      }
      set y(e) {
          this._y = e,
          this._onChangeCallback()
      }
      get z() {
          return this._z
      }
      set z(e) {
          this._z = e,
          this._onChangeCallback()
      }
      get order() {
          return this._order
      }
      set order(e) {
          this._order = e,
          this._onChangeCallback()
      }
      set(e, t, i, n=this._order) {
          return this._x = e,
          this._y = t,
          this._z = i,
          this._order = n,
          this._onChangeCallback(),
          this
      }
      clone() {
          return new this.constructor(this._x,this._y,this._z,this._order)
      }
      copy(e) {
          return this._x = e._x,
          this._y = e._y,
          this._z = e._z,
          this._order = e._order,
          this._onChangeCallback(),
          this
      }
      setFromRotationMatrix(e, t=this._order, i=!0) {
          const n = e.elements
            , r = n[0]
            , s = n[4]
            , a = n[8]
            , o = n[1]
            , l = n[5]
            , c = n[9]
            , u = n[2]
            , h = n[6]
            , d = n[10];
          switch (t) {
          case "XYZ":
              this._y = Math.asin(Yh(a, -1, 1)),
              Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d),
              this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l),
              this._z = 0);
              break;
          case "YXZ":
              this._x = Math.asin(-Yh(c, -1, 1)),
              Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d),
              this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, r),
              this._z = 0);
              break;
          case "ZXY":
              this._x = Math.asin(Yh(h, -1, 1)),
              Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d),
              this._z = Math.atan2(-s, l)) : (this._y = 0,
              this._z = Math.atan2(o, r));
              break;
          case "ZYX":
              this._y = Math.asin(-Yh(u, -1, 1)),
              Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d),
              this._z = Math.atan2(o, r)) : (this._x = 0,
              this._z = Math.atan2(-s, l));
              break;
          case "YZX":
              this._z = Math.asin(Yh(o, -1, 1)),
              Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
              this._y = Math.atan2(-u, r)) : (this._x = 0,
              this._y = Math.atan2(a, d));
              break;
          case "XZY":
              this._z = Math.asin(-Yh(s, -1, 1)),
              Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l),
              this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d),
              this._y = 0);
              break;
          default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
          }
          return this._order = t,
          !0 === i && this._onChangeCallback(),
          this
      }
      setFromQuaternion(e, t, i) {
          return up.makeRotationFromQuaternion(e),
          this.setFromRotationMatrix(up, t, i)
      }
      setFromVector3(e, t=this._order) {
          return this.set(e.x, e.y, e.z, t)
      }
      reorder(e) {
          return hp.setFromEuler(this),
          this.setFromQuaternion(hp, e)
      }
      equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
      }
      fromArray(e) {
          return this._x = e[0],
          this._y = e[1],
          this._z = e[2],
          void 0 !== e[3] && (this._order = e[3]),
          this._onChangeCallback(),
          this
      }
      toArray(e=[], t=0) {
          return e[t] = this._x,
          e[t + 1] = this._y,
          e[t + 2] = this._z,
          e[t + 3] = this._order,
          e
      }
      _onChange(e) {
          return this._onChangeCallback = e,
          this
      }
      _onChangeCallback() {}
      *[Symbol.iterator]() {
          yield this._x,
          yield this._y,
          yield this._z,
          yield this._order
      }
  }
  dp.DEFAULT_ORDER = "XYZ";
  class pp {
      constructor() {
          this.mask = 1
      }
      set(e) {
          this.mask = (1 << e | 0) >>> 0
      }
      enable(e) {
          this.mask |= 1 << e | 0
      }
      enableAll() {
          this.mask = -1
      }
      toggle(e) {
          this.mask ^= 1 << e | 0
      }
      disable(e) {
          this.mask &= ~(1 << e | 0)
      }
      disableAll() {
          this.mask = 0
      }
      test(e) {
          return 0 != (this.mask & e.mask)
      }
      isEnabled(e) {
          return 0 != (this.mask & (1 << e | 0))
      }
  }
  let fp = 0;
  const mp = new wd
    , gp = new Td
    , vp = new ip
    , _p = new wd
    , yp = new wd
    , xp = new wd
    , Sp = new Td
    , Ep = new wd(1,0,0)
    , Mp = new wd(0,1,0)
    , bp = new wd(0,0,1)
    , Tp = {
      type: "added"
  }
    , wp = {
      type: "removed"
  }
    , Dp = {
      type: "childadded",
      child: null
  }
    , Cp = {
      type: "childremoved",
      child: null
  };
  class Ap extends Gh {
      constructor() {
          super(),
          this.isObject3D = !0,
          Object.defineProperty(this, "id", {
              value: fp++
          }),
          this.uuid = jh(),
          this.name = "",
          this.type = "Object3D",
          this.parent = null,
          this.children = [],
          this.up = Ap.DEFAULT_UP.clone();
          const e = new wd
            , t = new dp
            , i = new Td
            , n = new wd(1,1,1);
          t._onChange((function() {
              i.setFromEuler(t, !1)
          }
          )),
          i._onChange((function() {
              t.setFromQuaternion(i, void 0, !1)
          }
          )),
          Object.defineProperties(this, {
              position: {
                  configurable: !0,
                  enumerable: !0,
                  value: e
              },
              rotation: {
                  configurable: !0,
                  enumerable: !0,
                  value: t
              },
              quaternion: {
                  configurable: !0,
                  enumerable: !0,
                  value: i
              },
              scale: {
                  configurable: !0,
                  enumerable: !0,
                  value: n
              },
              modelViewMatrix: {
                  value: new ip
              },
              normalMatrix: {
                  value: new Qh
              }
          }),
          this.matrix = new ip,
          this.matrixWorld = new ip,
          this.matrixAutoUpdate = Ap.DEFAULT_MATRIX_AUTO_UPDATE,
          this.matrixWorldAutoUpdate = Ap.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
          this.matrixWorldNeedsUpdate = !1,
          this.layers = new pp,
          this.visible = !0,
          this.castShadow = !1,
          this.receiveShadow = !1,
          this.frustumCulled = !0,
          this.renderOrder = 0,
          this.animations = [],
          this.userData = {}
      }
      onBeforeShadow() {}
      onAfterShadow() {}
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(e),
          this.matrix.decompose(this.position, this.quaternion, this.scale)
      }
      applyQuaternion(e) {
          return this.quaternion.premultiply(e),
          this
      }
      setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t)
      }
      setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0)
      }
      setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e)
      }
      setRotationFromQuaternion(e) {
          this.quaternion.copy(e)
      }
      rotateOnAxis(e, t) {
          return gp.setFromAxisAngle(e, t),
          this.quaternion.multiply(gp),
          this
      }
      rotateOnWorldAxis(e, t) {
          return gp.setFromAxisAngle(e, t),
          this.quaternion.premultiply(gp),
          this
      }
      rotateX(e) {
          return this.rotateOnAxis(Ep, e)
      }
      rotateY(e) {
          return this.rotateOnAxis(Mp, e)
      }
      rotateZ(e) {
          return this.rotateOnAxis(bp, e)
      }
      translateOnAxis(e, t) {
          return mp.copy(e).applyQuaternion(this.quaternion),
          this.position.add(mp.multiplyScalar(t)),
          this
      }
      translateX(e) {
          return this.translateOnAxis(Ep, e)
      }
      translateY(e) {
          return this.translateOnAxis(Mp, e)
      }
      translateZ(e) {
          return this.translateOnAxis(bp, e)
      }
      localToWorld(e) {
          return this.updateWorldMatrix(!0, !1),
          e.applyMatrix4(this.matrixWorld)
      }
      worldToLocal(e) {
          return this.updateWorldMatrix(!0, !1),
          e.applyMatrix4(vp.copy(this.matrixWorld).invert())
      }
      lookAt(e, t, i) {
          e.isVector3 ? _p.copy(e) : _p.set(e, t, i);
          const n = this.parent;
          this.updateWorldMatrix(!0, !1),
          yp.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight ? vp.lookAt(yp, _p, this.up) : vp.lookAt(_p, yp, this.up),
          this.quaternion.setFromRotationMatrix(vp),
          n && (vp.extractRotation(n.matrixWorld),
          gp.setFromRotationMatrix(vp),
          this.quaternion.premultiply(gp.invert()))
      }
      add(e) {
          if (arguments.length > 1) {
              for (let e = 0; e < arguments.length; e++)
                  this.add(arguments[e]);
              return this
          }
          return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
          this) : (e && e.isObject3D ? (e.removeFromParent(),
          e.parent = this,
          this.children.push(e),
          e.dispatchEvent(Tp),
          Dp.child = e,
          this.dispatchEvent(Dp),
          Dp.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
          this)
      }
      remove(e) {
          if (arguments.length > 1) {
              for (let e = 0; e < arguments.length; e++)
                  this.remove(arguments[e]);
              return this
          }
          const t = this.children.indexOf(e);
          return -1 !== t && (e.parent = null,
          this.children.splice(t, 1),
          e.dispatchEvent(wp),
          Cp.child = e,
          this.dispatchEvent(Cp),
          Cp.child = null),
          this
      }
      removeFromParent() {
          const e = this.parent;
          return null !== e && e.remove(this),
          this
      }
      clear() {
          return this.remove(...this.children)
      }
      attach(e) {
          return this.updateWorldMatrix(!0, !1),
          vp.copy(this.matrixWorld).invert(),
          null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
          vp.multiply(e.parent.matrixWorld)),
          e.applyMatrix4(vp),
          e.removeFromParent(),
          e.parent = this,
          this.children.push(e),
          e.updateWorldMatrix(!1, !0),
          e.dispatchEvent(Tp),
          Dp.child = e,
          this.dispatchEvent(Dp),
          Dp.child = null,
          this
      }
      getObjectById(e) {
          return this.getObjectByProperty("id", e)
      }
      getObjectByName(e) {
          return this.getObjectByProperty("name", e)
      }
      getObjectByProperty(e, t) {
          if (this[e] === t)
              return this;
          for (let i = 0, n = this.children.length; i < n; i++) {
              const n = this.children[i].getObjectByProperty(e, t);
              if (void 0 !== n)
                  return n
          }
      }
      getObjectsByProperty(e, t, i=[]) {
          this[e] === t && i.push(this);
          const n = this.children;
          for (let r = 0, s = n.length; r < s; r++)
              n[r].getObjectsByProperty(e, t, i);
          return i
      }
      getWorldPosition(e) {
          return this.updateWorldMatrix(!0, !1),
          e.setFromMatrixPosition(this.matrixWorld)
      }
      getWorldQuaternion(e) {
          return this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(yp, e, xp),
          e
      }
      getWorldScale(e) {
          return this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(yp, Sp, e),
          e
      }
      getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize()
      }
      raycast() {}
      traverse(e) {
          e(this);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++)
              t[i].traverse(e)
      }
      traverseVisible(e) {
          if (!1 === this.visible)
              return;
          e(this);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++)
              t[i].traverseVisible(e)
      }
      traverseAncestors(e) {
          const t = this.parent;
          null !== t && (e(t),
          t.traverseAncestors(e))
      }
      updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
          this.matrixWorldNeedsUpdate = !0
      }
      updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
          this.matrixWorldNeedsUpdate = !1,
          e = !0);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++)
              t[i].updateMatrixWorld(e)
      }
      updateWorldMatrix(e, t) {
          const i = this.parent;
          if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
          !0 === t) {
              const e = this.children;
              for (let t = 0, i = e.length; t < i; t++)
                  e[t].updateWorldMatrix(!1, !0)
          }
      }
      toJSON(e) {
          const t = void 0 === e || "string" == typeof e
            , i = {};
          t && (e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {}
          },
          i.metadata = {
              version: 4.6,
              type: "Object",
              generator: "Object3D.toJSON"
          });
          const n = {};
          function r(t, i) {
              return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)),
              i.uuid
          }
          if (n.uuid = this.uuid,
          n.type = this.type,
          "" !== this.name && (n.name = this.name),
          !0 === this.castShadow && (n.castShadow = !0),
          !0 === this.receiveShadow && (n.receiveShadow = !0),
          !1 === this.visible && (n.visible = !1),
          !1 === this.frustumCulled && (n.frustumCulled = !1),
          0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
          Object.keys(this.userData).length > 0 && (n.userData = this.userData),
          n.layers = this.layers.mask,
          n.matrix = this.matrix.toArray(),
          n.up = this.up.toArray(),
          !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
          this.isInstancedMesh && (n.type = "InstancedMesh",
          n.count = this.count,
          n.instanceMatrix = this.instanceMatrix.toJSON(),
          null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())),
          this.isBatchedMesh && (n.type = "BatchedMesh",
          n.perObjectFrustumCulled = this.perObjectFrustumCulled,
          n.sortObjects = this.sortObjects,
          n.drawRanges = this._drawRanges,
          n.reservedRanges = this._reservedRanges,
          n.visibility = this._visibility,
          n.active = this._active,
          n.bounds = this._bounds.map((e => ({
              boxInitialized: e.boxInitialized,
              boxMin: e.box.min.toArray(),
              boxMax: e.box.max.toArray(),
              sphereInitialized: e.sphereInitialized,
              sphereRadius: e.sphere.radius,
              sphereCenter: e.sphere.center.toArray()
          }))),
          n.maxInstanceCount = this._maxInstanceCount,
          n.maxVertexCount = this._maxVertexCount,
          n.maxIndexCount = this._maxIndexCount,
          n.geometryInitialized = this._geometryInitialized,
          n.geometryCount = this._geometryCount,
          n.matricesTexture = this._matricesTexture.toJSON(e),
          null !== this._colorsTexture && (n.colorsTexture = this._colorsTexture.toJSON(e)),
          null !== this.boundingSphere && (n.boundingSphere = {
              center: n.boundingSphere.center.toArray(),
              radius: n.boundingSphere.radius
          }),
          null !== this.boundingBox && (n.boundingBox = {
              min: n.boundingBox.min.toArray(),
              max: n.boundingBox.max.toArray()
          })),
          this.isScene)
              this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)),
              this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (n.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
              n.geometry = r(e.geometries, this.geometry);
              const t = this.geometry.parameters;
              if (void 0 !== t && void 0 !== t.shapes) {
                  const i = t.shapes;
                  if (Array.isArray(i))
                      for (let t = 0, n = i.length; t < n; t++) {
                          const n = i[t];
                          r(e.shapes, n)
                      }
                  else
                      r(e.shapes, i)
              }
          }
          if (this.isSkinnedMesh && (n.bindMode = this.bindMode,
          n.bindMatrix = this.bindMatrix.toArray(),
          void 0 !== this.skeleton && (r(e.skeletons, this.skeleton),
          n.skeleton = this.skeleton.uuid)),
          void 0 !== this.material)
              if (Array.isArray(this.material)) {
                  const t = [];
                  for (let i = 0, n = this.material.length; i < n; i++)
                      t.push(r(e.materials, this.material[i]));
                  n.material = t
              } else
                  n.material = r(e.materials, this.material);
          if (this.children.length > 0) {
              n.children = [];
              for (let t = 0; t < this.children.length; t++)
                  n.children.push(this.children[t].toJSON(e).object)
          }
          if (this.animations.length > 0) {
              n.animations = [];
              for (let t = 0; t < this.animations.length; t++) {
                  const i = this.animations[t];
                  n.animations.push(r(e.animations, i))
              }
          }
          if (t) {
              const t = s(e.geometries)
                , n = s(e.materials)
                , r = s(e.textures)
                , a = s(e.images)
                , o = s(e.shapes)
                , l = s(e.skeletons)
                , c = s(e.animations)
                , u = s(e.nodes);
              t.length > 0 && (i.geometries = t),
              n.length > 0 && (i.materials = n),
              r.length > 0 && (i.textures = r),
              a.length > 0 && (i.images = a),
              o.length > 0 && (i.shapes = o),
              l.length > 0 && (i.skeletons = l),
              c.length > 0 && (i.animations = c),
              u.length > 0 && (i.nodes = u)
          }
          return i.object = n,
          i;
          function s(e) {
              const t = [];
              for (const i in e) {
                  const n = e[i];
                  delete n.metadata,
                  t.push(n)
              }
              return t
          }
      }
      clone(e) {
          return (new this.constructor).copy(this, e)
      }
      copy(e, t=!0) {
          if (this.name = e.name,
          this.up.copy(e.up),
          this.position.copy(e.position),
          this.rotation.order = e.rotation.order,
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          this.matrixAutoUpdate = e.matrixAutoUpdate,
          this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
          this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
          this.layers.mask = e.layers.mask,
          this.visible = e.visible,
          this.castShadow = e.castShadow,
          this.receiveShadow = e.receiveShadow,
          this.frustumCulled = e.frustumCulled,
          this.renderOrder = e.renderOrder,
          this.animations = e.animations.slice(),
          this.userData = JSON.parse(JSON.stringify(e.userData)),
          !0 === t)
              for (let t = 0; t < e.children.length; t++) {
                  const i = e.children[t];
                  this.add(i.clone())
              }
          return this
      }
  }
  Ap.DEFAULT_UP = new wd(0,1,0),
  Ap.DEFAULT_MATRIX_AUTO_UPDATE = !0,
  Ap.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
  const Pp = new wd
    , Rp = new wd
    , Lp = new wd
    , Ip = new wd
    , Np = new wd
    , Fp = new wd
    , Op = new wd
    , Up = new wd
    , Bp = new wd
    , zp = new wd;
  class kp {
      constructor(e=new wd, t=new wd, i=new wd) {
          this.a = e,
          this.b = t,
          this.c = i
      }
      static getNormal(e, t, i, n) {
          n.subVectors(i, t),
          Pp.subVectors(e, t),
          n.cross(Pp);
          const r = n.lengthSq();
          return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
      }
      static getBarycoord(e, t, i, n, r) {
          Pp.subVectors(n, t),
          Rp.subVectors(i, t),
          Lp.subVectors(e, t);
          const s = Pp.dot(Pp)
            , a = Pp.dot(Rp)
            , o = Pp.dot(Lp)
            , l = Rp.dot(Rp)
            , c = Rp.dot(Lp)
            , u = s * l - a * a;
          if (0 === u)
              return r.set(0, 0, 0),
              null;
          const h = 1 / u
            , d = (l * o - a * c) * h
            , p = (s * c - a * o) * h;
          return r.set(1 - d - p, p, d)
      }
      static containsPoint(e, t, i, n) {
          return null !== this.getBarycoord(e, t, i, n, Ip) && Ip.x >= 0 && Ip.y >= 0 && Ip.x + Ip.y <= 1
      }
      static getInterpolation(e, t, i, n, r, s, a, o) {
          return null === this.getBarycoord(e, t, i, n, Ip) ? (o.x = 0,
          o.y = 0,
          "z"in o && (o.z = 0),
          "w"in o && (o.w = 0),
          null) : (o.setScalar(0),
          o.addScaledVector(r, Ip.x),
          o.addScaledVector(s, Ip.y),
          o.addScaledVector(a, Ip.z),
          o)
      }
      static isFrontFacing(e, t, i, n) {
          return Pp.subVectors(i, t),
          Rp.subVectors(e, t),
          Pp.cross(Rp).dot(n) < 0
      }
      set(e, t, i) {
          return this.a.copy(e),
          this.b.copy(t),
          this.c.copy(i),
          this
      }
      setFromPointsAndIndices(e, t, i, n) {
          return this.a.copy(e[t]),
          this.b.copy(e[i]),
          this.c.copy(e[n]),
          this
      }
      setFromAttributeAndIndices(e, t, i, n) {
          return this.a.fromBufferAttribute(e, t),
          this.b.fromBufferAttribute(e, i),
          this.c.fromBufferAttribute(e, n),
          this
      }
      clone() {
          return (new this.constructor).copy(this)
      }
      copy(e) {
          return this.a.copy(e.a),
          this.b.copy(e.b),
          this.c.copy(e.c),
          this
      }
      getArea() {
          return Pp.subVectors(this.c, this.b),
          Rp.subVectors(this.a, this.b),
          .5 * Pp.cross(Rp).length()
      }
      getMidpoint(e) {
          return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
      }
      getNormal(e) {
          return kp.getNormal(this.a, this.b, this.c, e)
      }
      getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c)
      }
      getBarycoord(e, t) {
          return kp.getBarycoord(e, this.a, this.b, this.c, t)
      }
      getInterpolation(e, t, i, n, r) {
          return kp.getInterpolation(e, this.a, this.b, this.c, t, i, n, r)
      }
      containsPoint(e) {
          return kp.containsPoint(e, this.a, this.b, this.c)
      }
      isFrontFacing(e) {
          return kp.isFrontFacing(this.a, this.b, this.c, e)
      }
      intersectsBox(e) {
          return e.intersectsTriangle(this)
      }
      closestPointToPoint(e, t) {
          const i = this.a
            , n = this.b
            , r = this.c;
          let s, a;
          Np.subVectors(n, i),
          Fp.subVectors(r, i),
          Up.subVectors(e, i);
          const o = Np.dot(Up)
            , l = Fp.dot(Up);
          if (o <= 0 && l <= 0)
              return t.copy(i);
          Bp.subVectors(e, n);
          const c = Np.dot(Bp)
            , u = Fp.dot(Bp);
          if (c >= 0 && u <= c)
              return t.copy(n);
          const h = o * u - c * l;
          if (h <= 0 && o >= 0 && c <= 0)
              return s = o / (o - c),
              t.copy(i).addScaledVector(Np, s);
          zp.subVectors(e, r);
          const d = Np.dot(zp)
            , p = Fp.dot(zp);
          if (p >= 0 && d <= p)
              return t.copy(r);
          const f = d * l - o * p;
          if (f <= 0 && l >= 0 && p <= 0)
              return a = l / (l - p),
              t.copy(i).addScaledVector(Fp, a);
          const m = c * p - d * u;
          if (m <= 0 && u - c >= 0 && d - p >= 0)
              return Op.subVectors(r, n),
              a = (u - c) / (u - c + (d - p)),
              t.copy(n).addScaledVector(Op, a);
          const g = 1 / (m + f + h);
          return s = f * g,
          a = h * g,
          t.copy(i).addScaledVector(Np, s).addScaledVector(Fp, a)
      }
      equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
      }
  }
  const Vp = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
  }
    , Hp = {
      h: 0,
      s: 0,
      l: 0
  }
    , Gp = {
      h: 0,
      s: 0,
      l: 0
  };
  function Wp(e, t, i) {
      return i < 0 && (i += 1),
      i > 1 && (i -= 1),
      i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
  }
  class Xp {
      constructor(e, t, i) {
          return this.isColor = !0,
          this.r = 1,
          this.g = 1,
          this.b = 1,
          this.set(e, t, i)
      }
      set(e, t, i) {
          if (void 0 === t && void 0 === i) {
              const t = e;
              t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
          } else
              this.setRGB(e, t, i);
          return this
      }
      setScalar(e) {
          return this.r = e,
          this.g = e,
          this.b = e,
          this
      }
      setHex(e, t=Rh) {
          return e = Math.floor(e),
          this.r = (e >> 16 & 255) / 255,
          this.g = (e >> 8 & 255) / 255,
          this.b = (255 & e) / 255,
          ud.toWorkingColorSpace(this, t),
          this
      }
      setRGB(e, t, i, n=ud.workingColorSpace) {
          return this.r = e,
          this.g = t,
          this.b = i,
          ud.toWorkingColorSpace(this, n),
          this
      }
      setHSL(e, t, i, n=ud.workingColorSpace) {
          if (e = function(e, t) {
              return (e % t + t) % t
          }(e, 1),
          t = Yh(t, 0, 1),
          i = Yh(i, 0, 1),
          0 === t)
              this.r = this.g = this.b = i;
          else {
              const n = i <= .5 ? i * (1 + t) : i + t - i * t
                , r = 2 * i - n;
              this.r = Wp(r, n, e + 1 / 3),
              this.g = Wp(r, n, e),
              this.b = Wp(r, n, e - 1 / 3)
          }
          return ud.toWorkingColorSpace(this, n),
          this
      }
      setStyle(e, t=Rh) {
          function i(t) {
              void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
          }
          let n;
          if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
              let r;
              const s = n[1]
                , a = n[2];
              switch (s) {
              case "rgb":
              case "rgba":
                  if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                      return i(r[4]),
                      this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                  if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                      return i(r[4]),
                      this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                  break;
              case "hsl":
              case "hsla":
                  if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                      return i(r[4]),
                      this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                  break;
              default:
                  console.warn("THREE.Color: Unknown color model " + e)
              }
          } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
              const i = n[1]
                , r = i.length;
              if (3 === r)
                  return this.setRGB(parseInt(i.charAt(0), 16) / 15, parseInt(i.charAt(1), 16) / 15, parseInt(i.charAt(2), 16) / 15, t);
              if (6 === r)
                  return this.setHex(parseInt(i, 16), t);
              console.warn("THREE.Color: Invalid hex color " + e)
          } else if (e && e.length > 0)
              return this.setColorName(e, t);
          return this
      }
      setColorName(e, t=Rh) {
          const i = Vp[e.toLowerCase()];
          return void 0 !== i ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
          this
      }
      clone() {
          return new this.constructor(this.r,this.g,this.b)
      }
      copy(e) {
          return this.r = e.r,
          this.g = e.g,
          this.b = e.b,
          this
      }
      copySRGBToLinear(e) {
          return this.r = hd(e.r),
          this.g = hd(e.g),
          this.b = hd(e.b),
          this
      }
      copyLinearToSRGB(e) {
          return this.r = dd(e.r),
          this.g = dd(e.g),
          this.b = dd(e.b),
          this
      }
      convertSRGBToLinear() {
          return this.copySRGBToLinear(this),
          this
      }
      convertLinearToSRGB() {
          return this.copyLinearToSRGB(this),
          this
      }
      getHex(e=Rh) {
          return ud.fromWorkingColorSpace(qp.copy(this), e),
          65536 * Math.round(Yh(255 * qp.r, 0, 255)) + 256 * Math.round(Yh(255 * qp.g, 0, 255)) + Math.round(Yh(255 * qp.b, 0, 255))
      }
      getHexString(e=Rh) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6)
      }
      getHSL(e, t=ud.workingColorSpace) {
          ud.fromWorkingColorSpace(qp.copy(this), t);
          const i = qp.r
            , n = qp.g
            , r = qp.b
            , s = Math.max(i, n, r)
            , a = Math.min(i, n, r);
          let o, l;
          const c = (a + s) / 2;
          if (a === s)
              o = 0,
              l = 0;
          else {
              const e = s - a;
              switch (l = c <= .5 ? e / (s + a) : e / (2 - s - a),
              s) {
              case i:
                  o = (n - r) / e + (n < r ? 6 : 0);
                  break;
              case n:
                  o = (r - i) / e + 2;
                  break;
              case r:
                  o = (i - n) / e + 4
              }
              o /= 6
          }
          return e.h = o,
          e.s = l,
          e.l = c,
          e
      }
      getRGB(e, t=ud.workingColorSpace) {
          return ud.fromWorkingColorSpace(qp.copy(this), t),
          e.r = qp.r,
          e.g = qp.g,
          e.b = qp.b,
          e
      }
      getStyle(e=Rh) {
          ud.fromWorkingColorSpace(qp.copy(this), e);
          const t = qp.r
            , i = qp.g
            , n = qp.b;
          return e !== Rh ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * i)},${Math.round(255 * n)})`
      }
      offsetHSL(e, t, i) {
          return this.getHSL(Hp),
          this.setHSL(Hp.h + e, Hp.s + t, Hp.l + i)
      }
      add(e) {
          return this.r += e.r,
          this.g += e.g,
          this.b += e.b,
          this
      }
      addColors(e, t) {
          return this.r = e.r + t.r,
          this.g = e.g + t.g,
          this.b = e.b + t.b,
          this
      }
      addScalar(e) {
          return this.r += e,
          this.g += e,
          this.b += e,
          this
      }
      sub(e) {
          return this.r = Math.max(0, this.r - e.r),
          this.g = Math.max(0, this.g - e.g),
          this.b = Math.max(0, this.b - e.b),
          this
      }
      multiply(e) {
          return this.r *= e.r,
          this.g *= e.g,
          this.b *= e.b,
          this
      }
      multiplyScalar(e) {
          return this.r *= e,
          this.g *= e,
          this.b *= e,
          this
      }
      lerp(e, t) {
          return this.r += (e.r - this.r) * t,
          this.g += (e.g - this.g) * t,
          this.b += (e.b - this.b) * t,
          this
      }
      lerpColors(e, t, i) {
          return this.r = e.r + (t.r - e.r) * i,
          this.g = e.g + (t.g - e.g) * i,
          this.b = e.b + (t.b - e.b) * i,
          this
      }
      lerpHSL(e, t) {
          this.getHSL(Hp),
          e.getHSL(Gp);
          const i = Kh(Hp.h, Gp.h, t)
            , n = Kh(Hp.s, Gp.s, t)
            , r = Kh(Hp.l, Gp.l, t);
          return this.setHSL(i, n, r),
          this
      }
      setFromVector3(e) {
          return this.r = e.x,
          this.g = e.y,
          this.b = e.z,
          this
      }
      applyMatrix3(e) {
          const t = this.r
            , i = this.g
            , n = this.b
            , r = e.elements;
          return this.r = r[0] * t + r[3] * i + r[6] * n,
          this.g = r[1] * t + r[4] * i + r[7] * n,
          this.b = r[2] * t + r[5] * i + r[8] * n,
          this
      }
      equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b
      }
      fromArray(e, t=0) {
          return this.r = e[t],
          this.g = e[t + 1],
          this.b = e[t + 2],
          this
      }
      toArray(e=[], t=0) {
          return e[t] = this.r,
          e[t + 1] = this.g,
          e[t + 2] = this.b,
          e
      }
      fromBufferAttribute(e, t) {
          return this.r = e.getX(t),
          this.g = e.getY(t),
          this.b = e.getZ(t),
          this
      }
      toJSON() {
          return this.getHex()
      }
      *[Symbol.iterator]() {
          yield this.r,
          yield this.g,
          yield this.b
      }
  }
  const qp = new Xp;
  Xp.NAMES = Vp;
  let jp = 0;
  class Yp extends Gh {
      constructor() {
          super(),
          this.isMaterial = !0,
          Object.defineProperty(this, "id", {
              value: jp++
          }),
          this.uuid = jh(),
          this.name = "",
          this.type = "Material",
          this.blending = 1,
          this.side = 0,
          this.vertexColors = !1,
          this.opacity = 1,
          this.transparent = !1,
          this.alphaHash = !1,
          this.blendSrc = 204,
          this.blendDst = 205,
          this.blendEquation = iu,
          this.blendSrcAlpha = null,
          this.blendDstAlpha = null,
          this.blendEquationAlpha = null,
          this.blendColor = new Xp(0,0,0),
          this.blendAlpha = 0,
          this.depthFunc = 3,
          this.depthTest = !0,
          this.depthWrite = !0,
          this.stencilWriteMask = 255,
          this.stencilFunc = 519,
          this.stencilRef = 0,
          this.stencilFuncMask = 255,
          this.stencilFail = zh,
          this.stencilZFail = zh,
          this.stencilZPass = zh,
          this.stencilWrite = !1,
          this.clippingPlanes = null,
          this.clipIntersection = !1,
          this.clipShadows = !1,
          this.shadowSide = null,
          this.colorWrite = !0,
          this.precision = null,
          this.polygonOffset = !1,
          this.polygonOffsetFactor = 0,
          this.polygonOffsetUnits = 0,
          this.dithering = !1,
          this.alphaToCoverage = !1,
          this.premultipliedAlpha = !1,
          this.forceSinglePass = !1,
          this.visible = !0,
          this.toneMapped = !0,
          this.userData = {},
          this.version = 0,
          this._alphaTest = 0
      }
      get alphaTest() {
          return this._alphaTest
      }
      set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++,
          this._alphaTest = e
      }
      onBeforeCompile() {}
      customProgramCacheKey() {
          return this.onBeforeCompile.toString()
      }
      setValues(e) {
          if (void 0 !== e)
              for (const t in e) {
                  const i = e[t];
                  if (void 0 === i) {
                      console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                      continue
                  }
                  const n = this[t];
                  void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`)
              }
      }
      toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          t && (e = {
              textures: {},
              images: {}
          });
          const i = {
              metadata: {
                  version: 4.6,
                  type: "Material",
                  generator: "Material.toJSON"
              }
          };
          function n(e) {
              const t = [];
              for (const i in e) {
                  const n = e[i];
                  delete n.metadata,
                  t.push(n)
              }
              return t
          }
          if (i.uuid = this.uuid,
          i.type = this.type,
          "" !== this.name && (i.name = this.name),
          this.color && this.color.isColor && (i.color = this.color.getHex()),
          void 0 !== this.roughness && (i.roughness = this.roughness),
          void 0 !== this.metalness && (i.metalness = this.metalness),
          void 0 !== this.sheen && (i.sheen = this.sheen),
          this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
          void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness),
          this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
          void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
          this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
          void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity),
          this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
          void 0 !== this.shininess && (i.shininess = this.shininess),
          void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
          this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
          this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
          i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
          void 0 !== this.dispersion && (i.dispersion = this.dispersion),
          void 0 !== this.iridescence && (i.iridescence = this.iridescence),
          void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR),
          void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
          this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
          this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
          void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy),
          void 0 !== this.anisotropyRotation && (i.anisotropyRotation = this.anisotropyRotation),
          this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
          this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
          this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
          this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
          this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
          i.lightMapIntensity = this.lightMapIntensity),
          this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
          i.aoMapIntensity = this.aoMapIntensity),
          this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
          i.bumpScale = this.bumpScale),
          this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
          i.normalMapType = this.normalMapType,
          i.normalScale = this.normalScale.toArray()),
          this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
          i.displacementScale = this.displacementScale,
          i.displacementBias = this.displacementBias),
          this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
          this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
          this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
          this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
          this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
          this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
          this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
          void 0 !== this.combine && (i.combine = this.combine)),
          void 0 !== this.envMapRotation && (i.envMapRotation = this.envMapRotation.toArray()),
          void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity),
          void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
          void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio),
          this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
          void 0 !== this.transmission && (i.transmission = this.transmission),
          this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
          void 0 !== this.thickness && (i.thickness = this.thickness),
          this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
          void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
          void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()),
          void 0 !== this.size && (i.size = this.size),
          null !== this.shadowSide && (i.shadowSide = this.shadowSide),
          void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
          1 !== this.blending && (i.blending = this.blending),
          0 !== this.side && (i.side = this.side),
          !0 === this.vertexColors && (i.vertexColors = !0),
          this.opacity < 1 && (i.opacity = this.opacity),
          !0 === this.transparent && (i.transparent = !0),
          204 !== this.blendSrc && (i.blendSrc = this.blendSrc),
          205 !== this.blendDst && (i.blendDst = this.blendDst),
          this.blendEquation !== iu && (i.blendEquation = this.blendEquation),
          null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha),
          null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha),
          null !== this.blendEquationAlpha && (i.blendEquationAlpha = this.blendEquationAlpha),
          this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
          0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha),
          3 !== this.depthFunc && (i.depthFunc = this.depthFunc),
          !1 === this.depthTest && (i.depthTest = this.depthTest),
          !1 === this.depthWrite && (i.depthWrite = this.depthWrite),
          !1 === this.colorWrite && (i.colorWrite = this.colorWrite),
          255 !== this.stencilWriteMask && (i.stencilWriteMask = this.stencilWriteMask),
          519 !== this.stencilFunc && (i.stencilFunc = this.stencilFunc),
          0 !== this.stencilRef && (i.stencilRef = this.stencilRef),
          255 !== this.stencilFuncMask && (i.stencilFuncMask = this.stencilFuncMask),
          this.stencilFail !== zh && (i.stencilFail = this.stencilFail),
          this.stencilZFail !== zh && (i.stencilZFail = this.stencilZFail),
          this.stencilZPass !== zh && (i.stencilZPass = this.stencilZPass),
          !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite),
          void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
          !0 === this.polygonOffset && (i.polygonOffset = !0),
          0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
          void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
          void 0 !== this.dashSize && (i.dashSize = this.dashSize),
          void 0 !== this.gapSize && (i.gapSize = this.gapSize),
          void 0 !== this.scale && (i.scale = this.scale),
          !0 === this.dithering && (i.dithering = !0),
          this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
          !0 === this.alphaHash && (i.alphaHash = !0),
          !0 === this.alphaToCoverage && (i.alphaToCoverage = !0),
          !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0),
          !0 === this.forceSinglePass && (i.forceSinglePass = !0),
          !0 === this.wireframe && (i.wireframe = !0),
          this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.flatShading && (i.flatShading = !0),
          !1 === this.visible && (i.visible = !1),
          !1 === this.toneMapped && (i.toneMapped = !1),
          !1 === this.fog && (i.fog = !1),
          Object.keys(this.userData).length > 0 && (i.userData = this.userData),
          t) {
              const t = n(e.textures)
                , r = n(e.images);
              t.length > 0 && (i.textures = t),
              r.length > 0 && (i.images = r)
          }
          return i
      }
      clone() {
          return (new this.constructor).copy(this)
      }
      copy(e) {
          this.name = e.name,
          this.blending = e.blending,
          this.side = e.side,
          this.vertexColors = e.vertexColors,
          this.opacity = e.opacity,
          this.transparent = e.transparent,
          this.blendSrc = e.blendSrc,
          this.blendDst = e.blendDst,
          this.blendEquation = e.blendEquation,
          this.blendSrcAlpha = e.blendSrcAlpha,
          this.blendDstAlpha = e.blendDstAlpha,
          this.blendEquationAlpha = e.blendEquationAlpha,
          this.blendColor.copy(e.blendColor),
          this.blendAlpha = e.blendAlpha,
          this.depthFunc = e.depthFunc,
          this.depthTest = e.depthTest,
          this.depthWrite = e.depthWrite,
          this.stencilWriteMask = e.stencilWriteMask,
          this.stencilFunc = e.stencilFunc,
          this.stencilRef = e.stencilRef,
          this.stencilFuncMask = e.stencilFuncMask,
          this.stencilFail = e.stencilFail,
          this.stencilZFail = e.stencilZFail,
          this.stencilZPass = e.stencilZPass,
          this.stencilWrite = e.stencilWrite;
          const t = e.clippingPlanes;
          let i = null;
          if (null !== t) {
              const e = t.length;
              i = new Array(e);
              for (let n = 0; n !== e; ++n)
                  i[n] = t[n].clone()
          }
          return this.clippingPlanes = i,
          this.clipIntersection = e.clipIntersection,
          this.clipShadows = e.clipShadows,
          this.shadowSide = e.shadowSide,
          this.colorWrite = e.colorWrite,
          this.precision = e.precision,
          this.polygonOffset = e.polygonOffset,
          this.polygonOffsetFactor = e.polygonOffsetFactor,
          this.polygonOffsetUnits = e.polygonOffsetUnits,
          this.dithering = e.dithering,
          this.alphaTest = e.alphaTest,
          this.alphaHash = e.alphaHash,
          this.alphaToCoverage = e.alphaToCoverage,
          this.premultipliedAlpha = e.premultipliedAlpha,
          this.forceSinglePass = e.forceSinglePass,
          this.visible = e.visible,
          this.toneMapped = e.toneMapped,
          this.userData = JSON.parse(JSON.stringify(e.userData)),
          this
      }
      dispose() {
          this.dispatchEvent({
              type: "dispose"
          })
      }
      set needsUpdate(e) {
          !0 === e && this.version++
      }
      onBuild() {
          console.warn("Material: onBuild() has been removed.")
      }
      onBeforeRender() {
          console.warn("Material: onBeforeRender() has been removed.")
      }
  }
  class Kp extends Yp {
      constructor(e) {
          super(),
          this.isMeshBasicMaterial = !0,
          this.type = "MeshBasicMaterial",
          this.color = new Xp(16777215),
          this.map = null,
          this.lightMap = null,
          this.lightMapIntensity = 1,
          this.aoMap = null,
          this.aoMapIntensity = 1,
          this.specularMap = null,
          this.alphaMap = null,
          this.envMap = null,
          this.envMapRotation = new dp,
          this.combine = nu,
          this.reflectivity = 1,
          this.refractionRatio = .98,
          this.wireframe = !1,
          this.wireframeLinewidth = 1,
          this.wireframeLinecap = "round",
          this.wireframeLinejoin = "round",
          this.fog = !0,
          this.setValues(e)
      }
      copy(e) {
          return super.copy(e),
          this.color.copy(e.color),
          this.map = e.map,
          this.lightMap = e.lightMap,
          this.lightMapIntensity = e.lightMapIntensity,
          this.aoMap = e.aoMap,
          this.aoMapIntensity = e.aoMapIntensity,
          this.specularMap = e.specularMap,
          this.alphaMap = e.alphaMap,
          this.envMap = e.envMap,
          this.envMapRotation.copy(e.envMapRotation),
          this.combine = e.combine,
          this.reflectivity = e.reflectivity,
          this.refractionRatio = e.refractionRatio,
          this.wireframe = e.wireframe,
          this.wireframeLinewidth = e.wireframeLinewidth,
          this.wireframeLinecap = e.wireframeLinecap,
          this.wireframeLinejoin = e.wireframeLinejoin,
          this.fog = e.fog,
          this
      }
  }
  const Zp = new wd
    , $p = new Jh;
  class Jp {
      constructor(e, t, i=!1) {
          if (Array.isArray(e))
              throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = !0,
          this.name = "",
          this.array = e,
          this.itemSize = t,
          this.count = void 0 !== e ? e.length / t : 0,
          this.normalized = i,
          this.usage = 35044,
          this._updateRange = {
              offset: 0,
              count: -1
          },
          this.updateRanges = [],
          this.gpuType = Ru,
          this.version = 0
      }
      onUploadCallback() {}
      set needsUpdate(e) {
          !0 === e && this.version++
      }
      get updateRange() {
          return sd("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
          this._updateRange
      }
      setUsage(e) {
          return this.usage = e,
          this
      }
      addUpdateRange(e, t) {
          this.updateRanges.push({
              start: e,
              count: t
          })
      }
      clearUpdateRanges() {
          this.updateRanges.length = 0
      }
      copy(e) {
          return this.name = e.name,
          this.array = new e.array.constructor(e.array),
          this.itemSize = e.itemSize,
          this.count = e.count,
          this.normalized = e.normalized,
          this.usage = e.usage,
          this.gpuType = e.gpuType,
          this
      }
      copyAt(e, t, i) {
          e *= this.itemSize,
          i *= t.itemSize;
          for (let n = 0, r = this.itemSize; n < r; n++)
              this.array[e + n] = t.array[i + n];
          return this
      }
      copyArray(e) {
          return this.array.set(e),
          this
      }
      applyMatrix3(e) {
          if (2 === this.itemSize)
              for (let t = 0, i = this.count; t < i; t++)
                  $p.fromBufferAttribute(this, t),
                  $p.applyMatrix3(e),
                  this.setXY(t, $p.x, $p.y);
          else if (3 === this.itemSize)
              for (let t = 0, i = this.count; t < i; t++)
                  Zp.fromBufferAttribute(this, t),
                  Zp.applyMatrix3(e),
                  this.setXYZ(t, Zp.x, Zp.y, Zp.z);
          return this
      }
      applyMatrix4(e) {
          for (let t = 0, i = this.count; t < i; t++)
              Zp.fromBufferAttribute(this, t),
              Zp.applyMatrix4(e),
              this.setXYZ(t, Zp.x, Zp.y, Zp.z);
          return this
      }
      applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++)
              Zp.fromBufferAttribute(this, t),
              Zp.applyNormalMatrix(e),
              this.setXYZ(t, Zp.x, Zp.y, Zp.z);
          return this
      }
      transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++)
              Zp.fromBufferAttribute(this, t),
              Zp.transformDirection(e),
              this.setXYZ(t, Zp.x, Zp.y, Zp.z);
          return this
      }
      set(e, t=0) {
          return this.array.set(e, t),
          this
      }
      getComponent(e, t) {
          let i = this.array[e * this.itemSize + t];
          return this.normalized && (i = Zh(i, this.array)),
          i
      }
      setComponent(e, t, i) {
          return this.normalized && (i = $h(i, this.array)),
          this.array[e * this.itemSize + t] = i,
          this
      }
      getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = Zh(t, this.array)),
          t
      }
      setX(e, t) {
          return this.normalized && (t = $h(t, this.array)),
          this.array[e * this.itemSize] = t,
          this
      }
      getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = Zh(t, this.array)),
          t
      }
      setY(e, t) {
          return this.normalized && (t = $h(t, this.array)),
          this.array[e * this.itemSize + 1] = t,
          this
      }
      getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = Zh(t, this.array)),
          t
      }
      setZ(e, t) {
          return this.normalized && (t = $h(t, this.array)),
          this.array[e * this.itemSize + 2] = t,
          this
      }
      getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = Zh(t, this.array)),
          t
      }
      setW(e, t) {
          return this.normalized && (t = $h(t, this.array)),
          this.array[e * this.itemSize + 3] = t,
          this
      }
      setXY(e, t, i) {
          return e *= this.itemSize,
          this.normalized && (t = $h(t, this.array),
          i = $h(i, this.array)),
          this.array[e + 0] = t,
          this.array[e + 1] = i,
          this
      }
      setXYZ(e, t, i, n) {
          return e *= this.itemSize,
          this.normalized && (t = $h(t, this.array),
          i = $h(i, this.array),
          n = $h(n, this.array)),
          this.array[e + 0] = t,
          this.array[e + 1] = i,
          this.array[e + 2] = n,
          this
      }
      setXYZW(e, t, i, n, r) {
          return e *= this.itemSize,
          this.normalized && (t = $h(t, this.array),
          i = $h(i, this.array),
          n = $h(n, this.array),
          r = $h(r, this.array)),
          this.array[e + 0] = t,
          this.array[e + 1] = i,
          this.array[e + 2] = n,
          this.array[e + 3] = r,
          this
      }
      onUpload(e) {
          return this.onUploadCallback = e,
          this
      }
      clone() {
          return new this.constructor(this.array,this.itemSize).copy(this)
      }
      toJSON() {
          const e = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.from(this.array),
              normalized: this.normalized
          };
          return "" !== this.name && (e.name = this.name),
          35044 !== this.usage && (e.usage = this.usage),
          e
      }
  }
  class Qp extends Jp {
      constructor(e, t, i) {
          super(new Uint16Array(e), t, i)
      }
  }
  class ef extends Jp {
      constructor(e, t, i) {
          super(new Uint32Array(e), t, i)
      }
  }
  class tf extends Jp {
      constructor(e, t, i) {
          super(new Float32Array(e), t, i)
      }
  }
  let nf = 0;
  const rf = new ip
    , sf = new Ap
    , af = new wd
    , of = new Ad
    , lf = new Ad
    , cf = new wd;
  class uf extends Gh {
      constructor() {
          super(),
          this.isBufferGeometry = !0,
          Object.defineProperty(this, "id", {
              value: nf++
          }),
          this.uuid = jh(),
          this.name = "",
          this.type = "BufferGeometry",
          this.index = null,
          this.attributes = {},
          this.morphAttributes = {},
          this.morphTargetsRelative = !1,
          this.groups = [],
          this.boundingBox = null,
          this.boundingSphere = null,
          this.drawRange = {
              start: 0,
              count: 1 / 0
          },
          this.userData = {}
      }
      getIndex() {
          return this.index
      }
      setIndex(e) {
          return Array.isArray(e) ? this.index = new (td(e) ? ef : Qp)(e,1) : this.index = e,
          this
      }
      getAttribute(e) {
          return this.attributes[e]
      }
      setAttribute(e, t) {
          return this.attributes[e] = t,
          this
      }
      deleteAttribute(e) {
          return delete this.attributes[e],
          this
      }
      hasAttribute(e) {
          return void 0 !== this.attributes[e]
      }
      addGroup(e, t, i=0) {
          this.groups.push({
              start: e,
              count: t,
              materialIndex: i
          })
      }
      clearGroups() {
          this.groups = []
      }
      setDrawRange(e, t) {
          this.drawRange.start = e,
          this.drawRange.count = t
      }
      applyMatrix4(e) {
          const t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e),
          t.needsUpdate = !0);
          const i = this.attributes.normal;
          if (void 0 !== i) {
              const t = (new Qh).getNormalMatrix(e);
              i.applyNormalMatrix(t),
              i.needsUpdate = !0
          }
          const n = this.attributes.tangent;
          return void 0 !== n && (n.transformDirection(e),
          n.needsUpdate = !0),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
      }
      applyQuaternion(e) {
          return rf.makeRotationFromQuaternion(e),
          this.applyMatrix4(rf),
          this
      }
      rotateX(e) {
          return rf.makeRotationX(e),
          this.applyMatrix4(rf),
          this
      }
      rotateY(e) {
          return rf.makeRotationY(e),
          this.applyMatrix4(rf),
          this
      }
      rotateZ(e) {
          return rf.makeRotationZ(e),
          this.applyMatrix4(rf),
          this
      }
      translate(e, t, i) {
          return rf.makeTranslation(e, t, i),
          this.applyMatrix4(rf),
          this
      }
      scale(e, t, i) {
          return rf.makeScale(e, t, i),
          this.applyMatrix4(rf),
          this
      }
      lookAt(e) {
          return sf.lookAt(e),
          sf.updateMatrix(),
          this.applyMatrix4(sf.matrix),
          this
      }
      center() {
          return this.computeBoundingBox(),
          this.boundingBox.getCenter(af).negate(),
          this.translate(af.x, af.y, af.z),
          this
      }
      setFromPoints(e) {
          const t = [];
          for (let i = 0, n = e.length; i < n; i++) {
              const n = e[i];
              t.push(n.x, n.y, n.z || 0)
          }
          return this.setAttribute("position", new tf(t,3)),
          this
      }
      computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Ad);
          const e = this.attributes.position
            , t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
              return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
              void this.boundingBox.set(new wd(-1 / 0,-1 / 0,-1 / 0), new wd(1 / 0,1 / 0,1 / 0));
          if (void 0 !== e) {
              if (this.boundingBox.setFromBufferAttribute(e),
              t)
                  for (let e = 0, i = t.length; e < i; e++) {
                      const i = t[e];
                      of.setFromBufferAttribute(i),
                      this.morphTargetsRelative ? (cf.addVectors(this.boundingBox.min, of.min),
                      this.boundingBox.expandByPoint(cf),
                      cf.addVectors(this.boundingBox.max, of.max),
                      this.boundingBox.expandByPoint(cf)) : (this.boundingBox.expandByPoint(of.min),
                      this.boundingBox.expandByPoint(of.max))
                  }
          } else
              this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
      }
      computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new jd);
          const e = this.attributes.position
            , t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
              return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
              void this.boundingSphere.set(new wd, 1 / 0);
          if (e) {
              const i = this.boundingSphere.center;
              if (of.setFromBufferAttribute(e),
              t)
                  for (let e = 0, i = t.length; e < i; e++) {
                      const i = t[e];
                      lf.setFromBufferAttribute(i),
                      this.morphTargetsRelative ? (cf.addVectors(of.min, lf.min),
                      of.expandByPoint(cf),
                      cf.addVectors(of.max, lf.max),
                      of.expandByPoint(cf)) : (of.expandByPoint(lf.min),
                      of.expandByPoint(lf.max))
                  }
              of.getCenter(i);
              let n = 0;
              for (let t = 0, r = e.count; t < r; t++)
                  cf.fromBufferAttribute(e, t),
                  n = Math.max(n, i.distanceToSquared(cf));
              if (t)
                  for (let r = 0, s = t.length; r < s; r++) {
                      const s = t[r]
                        , a = this.morphTargetsRelative;
                      for (let t = 0, r = s.count; t < r; t++)
                          cf.fromBufferAttribute(s, t),
                          a && (af.fromBufferAttribute(e, t),
                          cf.add(af)),
                          n = Math.max(n, i.distanceToSquared(cf))
                  }
              this.boundingSphere.radius = Math.sqrt(n),
              isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
          }
      }
      computeTangents() {
          const e = this.index
            , t = this.attributes;
          if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
              return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          const i = t.position
            , n = t.normal
            , r = t.uv;
          !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Jp(new Float32Array(4 * i.count),4));
          const s = this.getAttribute("tangent")
            , a = []
            , o = [];
          for (let e = 0; e < i.count; e++)
              a[e] = new wd,
              o[e] = new wd;
          const l = new wd
            , c = new wd
            , u = new wd
            , h = new Jh
            , d = new Jh
            , p = new Jh
            , f = new wd
            , m = new wd;
          function g(e, t, n) {
              l.fromBufferAttribute(i, e),
              c.fromBufferAttribute(i, t),
              u.fromBufferAttribute(i, n),
              h.fromBufferAttribute(r, e),
              d.fromBufferAttribute(r, t),
              p.fromBufferAttribute(r, n),
              c.sub(l),
              u.sub(l),
              d.sub(h),
              p.sub(h);
              const s = 1 / (d.x * p.y - p.x * d.y);
              isFinite(s) && (f.copy(c).multiplyScalar(p.y).addScaledVector(u, -d.y).multiplyScalar(s),
              m.copy(u).multiplyScalar(d.x).addScaledVector(c, -p.x).multiplyScalar(s),
              a[e].add(f),
              a[t].add(f),
              a[n].add(f),
              o[e].add(m),
              o[t].add(m),
              o[n].add(m))
          }
          let v = this.groups;
          0 === v.length && (v = [{
              start: 0,
              count: e.count
          }]);
          for (let t = 0, i = v.length; t < i; ++t) {
              const i = v[t]
                , n = i.start;
              for (let t = n, r = n + i.count; t < r; t += 3)
                  g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
          }
          const _ = new wd
            , y = new wd
            , x = new wd
            , S = new wd;
          function E(e) {
              x.fromBufferAttribute(n, e),
              S.copy(x);
              const t = a[e];
              _.copy(t),
              _.sub(x.multiplyScalar(x.dot(t))).normalize(),
              y.crossVectors(S, t);
              const i = y.dot(o[e]) < 0 ? -1 : 1;
              s.setXYZW(e, _.x, _.y, _.z, i)
          }
          for (let t = 0, i = v.length; t < i; ++t) {
              const i = v[t]
                , n = i.start;
              for (let t = n, r = n + i.count; t < r; t += 3)
                  E(e.getX(t + 0)),
                  E(e.getX(t + 1)),
                  E(e.getX(t + 2))
          }
      }
      computeVertexNormals() {
          const e = this.index
            , t = this.getAttribute("position");
          if (void 0 !== t) {
              let i = this.getAttribute("normal");
              if (void 0 === i)
                  i = new Jp(new Float32Array(3 * t.count),3),
                  this.setAttribute("normal", i);
              else
                  for (let e = 0, t = i.count; e < t; e++)
                      i.setXYZ(e, 0, 0, 0);
              const n = new wd
                , r = new wd
                , s = new wd
                , a = new wd
                , o = new wd
                , l = new wd
                , c = new wd
                , u = new wd;
              if (e)
                  for (let h = 0, d = e.count; h < d; h += 3) {
                      const d = e.getX(h + 0)
                        , p = e.getX(h + 1)
                        , f = e.getX(h + 2);
                      n.fromBufferAttribute(t, d),
                      r.fromBufferAttribute(t, p),
                      s.fromBufferAttribute(t, f),
                      c.subVectors(s, r),
                      u.subVectors(n, r),
                      c.cross(u),
                      a.fromBufferAttribute(i, d),
                      o.fromBufferAttribute(i, p),
                      l.fromBufferAttribute(i, f),
                      a.add(c),
                      o.add(c),
                      l.add(c),
                      i.setXYZ(d, a.x, a.y, a.z),
                      i.setXYZ(p, o.x, o.y, o.z),
                      i.setXYZ(f, l.x, l.y, l.z)
                  }
              else
                  for (let e = 0, a = t.count; e < a; e += 3)
                      n.fromBufferAttribute(t, e + 0),
                      r.fromBufferAttribute(t, e + 1),
                      s.fromBufferAttribute(t, e + 2),
                      c.subVectors(s, r),
                      u.subVectors(n, r),
                      c.cross(u),
                      i.setXYZ(e + 0, c.x, c.y, c.z),
                      i.setXYZ(e + 1, c.x, c.y, c.z),
                      i.setXYZ(e + 2, c.x, c.y, c.z);
              this.normalizeNormals(),
              i.needsUpdate = !0
          }
      }
      normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, i = e.count; t < i; t++)
              cf.fromBufferAttribute(e, t),
              cf.normalize(),
              e.setXYZ(t, cf.x, cf.y, cf.z)
      }
      toNonIndexed() {
          function e(e, t) {
              const i = e.array
                , n = e.itemSize
                , r = e.normalized
                , s = new i.constructor(t.length * n);
              let a = 0
                , o = 0;
              for (let r = 0, l = t.length; r < l; r++) {
                  a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * n;
                  for (let e = 0; e < n; e++)
                      s[o++] = i[a++]
              }
              return new Jp(s,n,r)
          }
          if (null === this.index)
              return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
              this;
          const t = new uf
            , i = this.index.array
            , n = this.attributes;
          for (const r in n) {
              const s = e(n[r], i);
              t.setAttribute(r, s)
          }
          const r = this.morphAttributes;
          for (const n in r) {
              const s = []
                , a = r[n];
              for (let t = 0, n = a.length; t < n; t++) {
                  const n = e(a[t], i);
                  s.push(n)
              }
              t.morphAttributes[n] = s
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const s = this.groups;
          for (let e = 0, i = s.length; e < i; e++) {
              const i = s[e];
              t.addGroup(i.start, i.count, i.materialIndex)
          }
          return t
      }
      toJSON() {
          const e = {
              metadata: {
                  version: 4.6,
                  type: "BufferGeometry",
                  generator: "BufferGeometry.toJSON"
              }
          };
          if (e.uuid = this.uuid,
          e.type = this.type,
          "" !== this.name && (e.name = this.name),
          Object.keys(this.userData).length > 0 && (e.userData = this.userData),
          void 0 !== this.parameters) {
              const t = this.parameters;
              for (const i in t)
                  void 0 !== t[i] && (e[i] = t[i]);
              return e
          }
          e.data = {
              attributes: {}
          };
          const t = this.index;
          null !== t && (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array)
          });
          const i = this.attributes;
          for (const t in i) {
              const n = i[t];
              e.data.attributes[t] = n.toJSON(e.data)
          }
          const n = {};
          let r = !1;
          for (const t in this.morphAttributes) {
              const i = this.morphAttributes[t]
                , s = [];
              for (let t = 0, n = i.length; t < n; t++) {
                  const n = i[t];
                  s.push(n.toJSON(e.data))
              }
              s.length > 0 && (n[t] = s,
              r = !0)
          }
          r && (e.data.morphAttributes = n,
          e.data.morphTargetsRelative = this.morphTargetsRelative);
          const s = this.groups;
          s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
          const a = this.boundingSphere;
          return null !== a && (e.data.boundingSphere = {
              center: a.center.toArray(),
              radius: a.radius
          }),
          e
      }
      clone() {
          return (new this.constructor).copy(this)
      }
      copy(e) {
          this.index = null,
          this.attributes = {},
          this.morphAttributes = {},
          this.groups = [],
          this.boundingBox = null,
          this.boundingSphere = null;
          const t = {};
          this.name = e.name;
          const i = e.index;
          null !== i && this.setIndex(i.clone(t));
          const n = e.attributes;
          for (const e in n) {
              const i = n[e];
              this.setAttribute(e, i.clone(t))
          }
          const r = e.morphAttributes;
          for (const e in r) {
              const i = []
                , n = r[e];
              for (let e = 0, r = n.length; e < r; e++)
                  i.push(n[e].clone(t));
              this.morphAttributes[e] = i
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const s = e.groups;
          for (let e = 0, t = s.length; e < t; e++) {
              const t = s[e];
              this.addGroup(t.start, t.count, t.materialIndex)
          }
          const a = e.boundingBox;
          null !== a && (this.boundingBox = a.clone());
          const o = e.boundingSphere;
          return null !== o && (this.boundingSphere = o.clone()),
          this.drawRange.start = e.drawRange.start,
          this.drawRange.count = e.drawRange.count,
          this.userData = e.userData,
          this
      }
      dispose() {
          this.dispatchEvent({
              type: "dispose"
          })
      }
  }
  const hf = new ip
    , df = new tp
    , pf = new jd
    , ff = new wd
    , mf = new wd
    , gf = new wd
    , vf = new wd
    , _f = new wd
    , yf = new wd
    , xf = new Jh
    , Sf = new Jh
    , Ef = new Jh
    , Mf = new wd
    , bf = new wd
    , Tf = new wd
    , wf = new wd
    , Df = new wd;
  class Cf extends Ap {
      constructor(e=new uf, t=new Kp) {
          super(),
          this.isMesh = !0,
          this.type = "Mesh",
          this.geometry = e,
          this.material = t,
          this.updateMorphTargets()
      }
      copy(e, t) {
          return super.copy(e, t),
          void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
          void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
          this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
          this.geometry = e.geometry,
          this
      }
      updateMorphTargets() {
          const e = this.geometry.morphAttributes
            , t = Object.keys(e);
          if (t.length > 0) {
              const i = e[t[0]];
              if (void 0 !== i) {
                  this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {};
                  for (let e = 0, t = i.length; e < t; e++) {
                      const t = i[e].name || String(e);
                      this.morphTargetInfluences.push(0),
                      this.morphTargetDictionary[t] = e
                  }
              }
          }
      }
      getVertexPosition(e, t) {
          const i = this.geometry
            , n = i.attributes.position
            , r = i.morphAttributes.position
            , s = i.morphTargetsRelative;
          t.fromBufferAttribute(n, e);
          const a = this.morphTargetInfluences;
          if (r && a) {
              yf.set(0, 0, 0);
              for (let i = 0, n = r.length; i < n; i++) {
                  const n = a[i]
                    , o = r[i];
                  0 !== n && (_f.fromBufferAttribute(o, e),
                  s ? yf.addScaledVector(_f, n) : yf.addScaledVector(_f.sub(t), n))
              }
              t.add(yf)
          }
          return t
      }
      raycast(e, t) {
          const i = this.geometry
            , n = this.material
            , r = this.matrixWorld;
          if (void 0 !== n) {
              if (null === i.boundingSphere && i.computeBoundingSphere(),
              pf.copy(i.boundingSphere),
              pf.applyMatrix4(r),
              df.copy(e.ray).recast(e.near),
              !1 === pf.containsPoint(df.origin)) {
                  if (null === df.intersectSphere(pf, ff))
                      return;
                  if (df.origin.distanceToSquared(ff) > (e.far - e.near) ** 2)
                      return
              }
              hf.copy(r).invert(),
              df.copy(e.ray).applyMatrix4(hf),
              null !== i.boundingBox && !1 === df.intersectsBox(i.boundingBox) || this._computeIntersections(e, t, df)
          }
      }
      _computeIntersections(e, t, i) {
          let n;
          const r = this.geometry
            , s = this.material
            , a = r.index
            , o = r.attributes.position
            , l = r.attributes.uv
            , c = r.attributes.uv1
            , u = r.attributes.normal
            , h = r.groups
            , d = r.drawRange;
          if (null !== a)
              if (Array.isArray(s))
                  for (let r = 0, o = h.length; r < o; r++) {
                      const o = h[r]
                        , p = s[o.materialIndex];
                      for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3)
                          n = Af(this, p, e, i, l, c, u, a.getX(r), a.getX(r + 1), a.getX(r + 2)),
                          n && (n.faceIndex = Math.floor(r / 3),
                          n.face.materialIndex = o.materialIndex,
                          t.push(n))
                  }
              else
                  for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3)
                      n = Af(this, s, e, i, l, c, u, a.getX(r), a.getX(r + 1), a.getX(r + 2)),
                      n && (n.faceIndex = Math.floor(r / 3),
                      t.push(n));
          else if (void 0 !== o)
              if (Array.isArray(s))
                  for (let r = 0, a = h.length; r < a; r++) {
                      const a = h[r]
                        , p = s[a.materialIndex];
                      for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3)
                          n = Af(this, p, e, i, l, c, u, r, r + 1, r + 2),
                          n && (n.faceIndex = Math.floor(r / 3),
                          n.face.materialIndex = a.materialIndex,
                          t.push(n))
                  }
              else
                  for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3)
                      n = Af(this, s, e, i, l, c, u, r, r + 1, r + 2),
                      n && (n.faceIndex = Math.floor(r / 3),
                      t.push(n))
      }
  }
  function Af(e, t, i, n, r, s, a, o, l, c) {
      e.getVertexPosition(o, mf),
      e.getVertexPosition(l, gf),
      e.getVertexPosition(c, vf);
      const u = function(e, t, i, n, r, s, a, o) {
          let l;
          if (l = 1 === t.side ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, 0 === t.side, o),
          null === l)
              return null;
          Df.copy(o),
          Df.applyMatrix4(e.matrixWorld);
          const c = i.ray.origin.distanceTo(Df);
          return c < i.near || c > i.far ? null : {
              distance: c,
              point: Df.clone(),
              object: e
          }
      }(e, t, i, n, mf, gf, vf, wf);
      if (u) {
          r && (xf.fromBufferAttribute(r, o),
          Sf.fromBufferAttribute(r, l),
          Ef.fromBufferAttribute(r, c),
          u.uv = kp.getInterpolation(wf, mf, gf, vf, xf, Sf, Ef, new Jh)),
          s && (xf.fromBufferAttribute(s, o),
          Sf.fromBufferAttribute(s, l),
          Ef.fromBufferAttribute(s, c),
          u.uv1 = kp.getInterpolation(wf, mf, gf, vf, xf, Sf, Ef, new Jh)),
          a && (Mf.fromBufferAttribute(a, o),
          bf.fromBufferAttribute(a, l),
          Tf.fromBufferAttribute(a, c),
          u.normal = kp.getInterpolation(wf, mf, gf, vf, Mf, bf, Tf, new wd),
          u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
          const e = {
              a: o,
              b: l,
              c,
              normal: new wd,
              materialIndex: 0
          };
          kp.getNormal(mf, gf, vf, e.normal),
          u.face = e
      }
      return u
  }
  class Pf extends uf {
      constructor(e=1, t=1, i=1, n=1, r=1, s=1) {
          super(),
          this.type = "BoxGeometry",
          this.parameters = {
              width: e,
              height: t,
              depth: i,
              widthSegments: n,
              heightSegments: r,
              depthSegments: s
          };
          const a = this;
          n = Math.floor(n),
          r = Math.floor(r),
          s = Math.floor(s);
          const o = []
            , l = []
            , c = []
            , u = [];
          let h = 0
            , d = 0;
          function p(e, t, i, n, r, s, p, f, m, g, v) {
              const _ = s / m
                , y = p / g
                , x = s / 2
                , S = p / 2
                , E = f / 2
                , M = m + 1
                , b = g + 1;
              let T = 0
                , w = 0;
              const D = new wd;
              for (let s = 0; s < b; s++) {
                  const a = s * y - S;
                  for (let o = 0; o < M; o++) {
                      const h = o * _ - x;
                      D[e] = h * n,
                      D[t] = a * r,
                      D[i] = E,
                      l.push(D.x, D.y, D.z),
                      D[e] = 0,
                      D[t] = 0,
                      D[i] = f > 0 ? 1 : -1,
                      c.push(D.x, D.y, D.z),
                      u.push(o / m),
                      u.push(1 - s / g),
                      T += 1
                  }
              }
              for (let e = 0; e < g; e++)
                  for (let t = 0; t < m; t++) {
                      const i = h + t + M * e
                        , n = h + t + M * (e + 1)
                        , r = h + (t + 1) + M * (e + 1)
                        , s = h + (t + 1) + M * e;
                      o.push(i, n, s),
                      o.push(n, r, s),
                      w += 6
                  }
              a.addGroup(d, w, v),
              d += w,
              h += T
          }
          p("z", "y", "x", -1, -1, i, t, e, s, r, 0),
          p("z", "y", "x", 1, -1, i, t, -e, s, r, 1),
          p("x", "z", "y", 1, 1, e, i, t, n, s, 2),
          p("x", "z", "y", 1, -1, e, i, -t, n, s, 3),
          p("x", "y", "z", 1, -1, e, t, i, n, r, 4),
          p("x", "y", "z", -1, -1, e, t, -i, n, r, 5),
          this.setIndex(o),
          this.setAttribute("position", new tf(l,3)),
          this.setAttribute("normal", new tf(c,3)),
          this.setAttribute("uv", new tf(u,2))
      }
      copy(e) {
          return super.copy(e),
          this.parameters = Object.assign({}, e.parameters),
          this
      }
      static fromJSON(e) {
          return new Pf(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
      }
  }
  function Rf(e) {
      const t = {};
      for (const i in e) {
          t[i] = {};
          for (const n in e[i]) {
              const r = e[i][n];
              r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
              t[i][n] = null) : t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r
          }
      }
      return t
  }
  function Lf(e) {
      const t = {};
      for (let i = 0; i < e.length; i++) {
          const n = Rf(e[i]);
          for (const e in n)
              t[e] = n[e]
      }
      return t
  }
  function If(e) {
      const t = e.getRenderTarget();
      return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : ud.workingColorSpace
  }
  const Nf = {
      clone: Rf,
      merge: Lf
  };
  class Ff extends Yp {
      constructor(e) {
          super(),
          this.isShaderMaterial = !0,
          this.type = "ShaderMaterial",
          this.defines = {},
          this.uniforms = {},
          this.uniformsGroups = [],
          this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
          this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
          this.linewidth = 1,
          this.wireframe = !1,
          this.wireframeLinewidth = 1,
          this.fog = !1,
          this.lights = !1,
          this.clipping = !1,
          this.forceSinglePass = !0,
          this.extensions = {
              clipCullDistance: !1,
              multiDraw: !1
          },
          this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv1: [0, 0]
          },
          this.index0AttributeName = void 0,
          this.uniformsNeedUpdate = !1,
          this.glslVersion = null,
          void 0 !== e && this.setValues(e)
      }
      copy(e) {
          return super.copy(e),
          this.fragmentShader = e.fragmentShader,
          this.vertexShader = e.vertexShader,
          this.uniforms = Rf(e.uniforms),
          this.uniformsGroups = function(e) {
              const t = [];
              for (let i = 0; i < e.length; i++)
                  t.push(e[i].clone());
              return t
          }(e.uniformsGroups),
          this.defines = Object.assign({}, e.defines),
          this.wireframe = e.wireframe,
          this.wireframeLinewidth = e.wireframeLinewidth,
          this.fog = e.fog,
          this.lights = e.lights,
          this.clipping = e.clipping,
          this.extensions = Object.assign({}, e.extensions),
          this.glslVersion = e.glslVersion,
          this
      }
      toJSON(e) {
          const t = super.toJSON(e);
          t.glslVersion = this.glslVersion,
          t.uniforms = {};
          for (const i in this.uniforms) {
              const n = this.uniforms[i].value;
              n && n.isTexture ? t.uniforms[i] = {
                  type: "t",
                  value: n.toJSON(e).uuid
              } : n && n.isColor ? t.uniforms[i] = {
                  type: "c",
                  value: n.getHex()
              } : n && n.isVector2 ? t.uniforms[i] = {
                  type: "v2",
                  value: n.toArray()
              } : n && n.isVector3 ? t.uniforms[i] = {
                  type: "v3",
                  value: n.toArray()
              } : n && n.isVector4 ? t.uniforms[i] = {
                  type: "v4",
                  value: n.toArray()
              } : n && n.isMatrix3 ? t.uniforms[i] = {
                  type: "m3",
                  value: n.toArray()
              } : n && n.isMatrix4 ? t.uniforms[i] = {
                  type: "m4",
                  value: n.toArray()
              } : t.uniforms[i] = {
                  value: n
              }
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
          t.vertexShader = this.vertexShader,
          t.fragmentShader = this.fragmentShader,
          t.lights = this.lights,
          t.clipping = this.clipping;
          const i = {};
          for (const e in this.extensions)
              !0 === this.extensions[e] && (i[e] = !0);
          return Object.keys(i).length > 0 && (t.extensions = i),
          t
      }
  }
  class Of extends Ap {
      constructor() {
          super(),
          this.isCamera = !0,
          this.type = "Camera",
          this.matrixWorldInverse = new ip,
          this.projectionMatrix = new ip,
          this.projectionMatrixInverse = new ip,
          this.coordinateSystem = Vh
      }
      copy(e, t) {
          return super.copy(e, t),
          this.matrixWorldInverse.copy(e.matrixWorldInverse),
          this.projectionMatrix.copy(e.projectionMatrix),
          this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
          this.coordinateSystem = e.coordinateSystem,
          this
      }
      getWorldDirection(e) {
          return super.getWorldDirection(e).negate()
      }
      updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
          this.matrixWorldInverse.copy(this.matrixWorld).invert()
      }
      updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
          this.matrixWorldInverse.copy(this.matrixWorld).invert()
      }
      clone() {
          return (new this.constructor).copy(this)
      }
  }
  const Uf = new wd
    , Bf = new Jh
    , zf = new Jh;
  class kf extends Of {
      constructor(e=50, t=1, i=.1, n=2e3) {
          super(),
          this.isPerspectiveCamera = !0,
          this.type = "PerspectiveCamera",
          this.fov = e,
          this.zoom = 1,
          this.near = i,
          this.far = n,
          this.focus = 10,
          this.aspect = t,
          this.view = null,
          this.filmGauge = 35,
          this.filmOffset = 0,
          this.updateProjectionMatrix()
      }
      copy(e, t) {
          return super.copy(e, t),
          this.fov = e.fov,
          this.zoom = e.zoom,
          this.near = e.near,
          this.far = e.far,
          this.focus = e.focus,
          this.aspect = e.aspect,
          this.view = null === e.view ? null : Object.assign({}, e.view),
          this.filmGauge = e.filmGauge,
          this.filmOffset = e.filmOffset,
          this
      }
      setFocalLength(e) {
          const t = .5 * this.getFilmHeight() / e;
          this.fov = 2 * qh * Math.atan(t),
          this.updateProjectionMatrix()
      }
      getFocalLength() {
          const e = Math.tan(.5 * Xh * this.fov);
          return .5 * this.getFilmHeight() / e
      }
      getEffectiveFOV() {
          return 2 * qh * Math.atan(Math.tan(.5 * Xh * this.fov) / this.zoom)
      }
      getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1)
      }
      getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1)
      }
      getViewBounds(e, t, i) {
          Uf.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
          t.set(Uf.x, Uf.y).multiplyScalar(-e / Uf.z),
          Uf.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
          i.set(Uf.x, Uf.y).multiplyScalar(-e / Uf.z)
      }
      getViewSize(e, t) {
          return this.getViewBounds(e, Bf, zf),
          t.subVectors(zf, Bf)
      }
      setViewOffset(e, t, i, n, r, s) {
          this.aspect = e / t,
          null === this.view && (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
          }),
          this.view.enabled = !0,
          this.view.fullWidth = e,
          this.view.fullHeight = t,
          this.view.offsetX = i,
          this.view.offsetY = n,
          this.view.width = r,
          this.view.height = s,
          this.updateProjectionMatrix()
      }
      clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix()
      }
      updateProjectionMatrix() {
          const e = this.near;
          let t = e * Math.tan(.5 * Xh * this.fov) / this.zoom
            , i = 2 * t
            , n = this.aspect * i
            , r = -.5 * n;
          const s = this.view;
          if (null !== this.view && this.view.enabled) {
              const e = s.fullWidth
                , a = s.fullHeight;
              r += s.offsetX * n / e,
              t -= s.offsetY * i / a,
              n *= s.width / e,
              i *= s.height / a
          }
          const a = this.filmOffset;
          0 !== a && (r += e * a / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
      }
      toJSON(e) {
          const t = super.toJSON(e);
          return t.object.fov = this.fov,
          t.object.zoom = this.zoom,
          t.object.near = this.near,
          t.object.far = this.far,
          t.object.focus = this.focus,
          t.object.aspect = this.aspect,
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          t.object.filmGauge = this.filmGauge,
          t.object.filmOffset = this.filmOffset,
          t
      }
  }
  const Vf = -90;
  class Hf extends Ap {
      constructor(e, t, i) {
          super(),
          this.type = "CubeCamera",
          this.renderTarget = i,
          this.coordinateSystem = null,
          this.activeMipmapLevel = 0;
          const n = new kf(Vf,1,e,t);
          n.layers = this.layers,
          this.add(n);
          const r = new kf(Vf,1,e,t);
          r.layers = this.layers,
          this.add(r);
          const s = new kf(Vf,1,e,t);
          s.layers = this.layers,
          this.add(s);
          const a = new kf(Vf,1,e,t);
          a.layers = this.layers,
          this.add(a);
          const o = new kf(Vf,1,e,t);
          o.layers = this.layers,
          this.add(o);
          const l = new kf(Vf,1,e,t);
          l.layers = this.layers,
          this.add(l)
      }
      updateCoordinateSystem() {
          const e = this.coordinateSystem
            , t = this.children.concat()
            , [i,n,r,s,a,o] = t;
          for (const e of t)
              this.remove(e);
          if (e === Vh)
              i.up.set(0, 1, 0),
              i.lookAt(1, 0, 0),
              n.up.set(0, 1, 0),
              n.lookAt(-1, 0, 0),
              r.up.set(0, 0, -1),
              r.lookAt(0, 1, 0),
              s.up.set(0, 0, 1),
              s.lookAt(0, -1, 0),
              a.up.set(0, 1, 0),
              a.lookAt(0, 0, 1),
              o.up.set(0, 1, 0),
              o.lookAt(0, 0, -1);
          else {
              if (e !== Hh)
                  throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
              i.up.set(0, -1, 0),
              i.lookAt(-1, 0, 0),
              n.up.set(0, -1, 0),
              n.lookAt(1, 0, 0),
              r.up.set(0, 0, 1),
              r.lookAt(0, 1, 0),
              s.up.set(0, 0, -1),
              s.lookAt(0, -1, 0),
              a.up.set(0, -1, 0),
              a.lookAt(0, 0, 1),
              o.up.set(0, -1, 0),
              o.lookAt(0, 0, -1)
          }
          for (const e of t)
              this.add(e),
              e.updateMatrixWorld()
      }
      update(e, t) {
          null === this.parent && this.updateMatrixWorld();
          const {renderTarget: i, activeMipmapLevel: n} = this;
          this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
          this.updateCoordinateSystem());
          const [r,s,a,o,l,c] = this.children
            , u = e.getRenderTarget()
            , h = e.getActiveCubeFace()
            , d = e.getActiveMipmapLevel()
            , p = e.xr.enabled;
          e.xr.enabled = !1;
          const f = i.texture.generateMipmaps;
          i.texture.generateMipmaps = !1,
          e.setRenderTarget(i, 0, n),
          e.render(t, r),
          e.setRenderTarget(i, 1, n),
          e.render(t, s),
          e.setRenderTarget(i, 2, n),
          e.render(t, a),
          e.setRenderTarget(i, 3, n),
          e.render(t, o),
          e.setRenderTarget(i, 4, n),
          e.render(t, l),
          i.texture.generateMipmaps = f,
          e.setRenderTarget(i, 5, n),
          e.render(t, c),
          e.setRenderTarget(u, h, d),
          e.xr.enabled = p,
          i.texture.needsPMREMUpdate = !0
      }
  }
  class Gf extends yd {
      constructor(e, t, i, n, r, s, a, o, l, c) {
          super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : fu, i, n, r, s, a, o, l, c),
          this.isCubeTexture = !0,
          this.flipY = !1
      }
      get images() {
          return this.image
      }
      set images(e) {
          this.image = e
      }
  }
  class Wf extends Ed {
      constructor(e=1, t={}) {
          super(e, e, t),
          this.isWebGLCubeRenderTarget = !0;
          const i = {
              width: e,
              height: e,
              depth: 1
          }
            , n = [i, i, i, i, i, i];
          this.texture = new Gf(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
          this.texture.isRenderTargetTexture = !0,
          this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
          this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : Eu
      }
      fromEquirectangularTexture(e, t) {
          this.texture.type = t.type,
          this.texture.colorSpace = t.colorSpace,
          this.texture.generateMipmaps = t.generateMipmaps,
          this.texture.minFilter = t.minFilter,
          this.texture.magFilter = t.magFilter;
          const i = {
              tEquirect: {
                  value: null
              }
          }
            , n = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t"
            , r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
            , s = new Pf(5,5,5)
            , a = new Ff({
              name: "CubemapFromEquirect",
              uniforms: Rf(i),
              vertexShader: n,
              fragmentShader: r,
              side: 1,
              blending: 0
          });
          a.uniforms.tEquirect.value = t;
          const o = new Cf(s,a)
            , l = t.minFilter;
          return t.minFilter === bu && (t.minFilter = Eu),
          new Hf(1,10,this).update(e, o),
          t.minFilter = l,
          o.geometry.dispose(),
          o.material.dispose(),
          this
      }
      clear(e, t, i, n) {
          const r = e.getRenderTarget();
          for (let r = 0; r < 6; r++)
              e.setRenderTarget(this, r),
              e.clear(t, i, n);
          e.setRenderTarget(r)
      }
  }
  const Xf = new wd
    , qf = new wd
    , jf = new Qh;
  class Yf {
      constructor(e=new wd(1,0,0), t=0) {
          this.isPlane = !0,
          this.normal = e,
          this.constant = t
      }
      set(e, t) {
          return this.normal.copy(e),
          this.constant = t,
          this
      }
      setComponents(e, t, i, n) {
          return this.normal.set(e, t, i),
          this.constant = n,
          this
      }
      setFromNormalAndCoplanarPoint(e, t) {
          return this.normal.copy(e),
          this.constant = -t.dot(this.normal),
          this
      }
      setFromCoplanarPoints(e, t, i) {
          const n = Xf.subVectors(i, t).cross(qf.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(n, e),
          this
      }
      copy(e) {
          return this.normal.copy(e.normal),
          this.constant = e.constant,
          this
      }
      normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e),
          this.constant *= e,
          this
      }
      negate() {
          return this.constant *= -1,
          this.normal.negate(),
          this
      }
      distanceToPoint(e) {
          return this.normal.dot(e) + this.constant
      }
      distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius
      }
      projectPoint(e, t) {
          return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
      }
      intersectLine(e, t) {
          const i = e.delta(Xf)
            , n = this.normal.dot(i);
          if (0 === n)
              return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / n;
          return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r)
      }
      intersectsLine(e) {
          const t = this.distanceToPoint(e.start)
            , i = this.distanceToPoint(e.end);
          return t < 0 && i > 0 || i < 0 && t > 0
      }
      intersectsBox(e) {
          return e.intersectsPlane(this)
      }
      intersectsSphere(e) {
          return e.intersectsPlane(this)
      }
      coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant)
      }
      applyMatrix4(e, t) {
          const i = t || jf.getNormalMatrix(e)
            , n = this.coplanarPoint(Xf).applyMatrix4(e)
            , r = this.normal.applyMatrix3(i).normalize();
          return this.constant = -n.dot(r),
          this
      }
      translate(e) {
          return this.constant -= e.dot(this.normal),
          this
      }
      equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant
      }
      clone() {
          return (new this.constructor).copy(this)
      }
  }
  const Kf = new jd
    , Zf = new wd;
  class $f {
      constructor(e=new Yf, t=new Yf, i=new Yf, n=new Yf, r=new Yf, s=new Yf) {
          this.planes = [e, t, i, n, r, s]
      }
      set(e, t, i, n, r, s) {
          const a = this.planes;
          return a[0].copy(e),
          a[1].copy(t),
          a[2].copy(i),
          a[3].copy(n),
          a[4].copy(r),
          a[5].copy(s),
          this
      }
      copy(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++)
              t[i].copy(e.planes[i]);
          return this
      }
      setFromProjectionMatrix(e, t=2e3) {
          const i = this.planes
            , n = e.elements
            , r = n[0]
            , s = n[1]
            , a = n[2]
            , o = n[3]
            , l = n[4]
            , c = n[5]
            , u = n[6]
            , h = n[7]
            , d = n[8]
            , p = n[9]
            , f = n[10]
            , m = n[11]
            , g = n[12]
            , v = n[13]
            , _ = n[14]
            , y = n[15];
          if (i[0].setComponents(o - r, h - l, m - d, y - g).normalize(),
          i[1].setComponents(o + r, h + l, m + d, y + g).normalize(),
          i[2].setComponents(o + s, h + c, m + p, y + v).normalize(),
          i[3].setComponents(o - s, h - c, m - p, y - v).normalize(),
          i[4].setComponents(o - a, h - u, m - f, y - _).normalize(),
          t === Vh)
              i[5].setComponents(o + a, h + u, m + f, y + _).normalize();
          else {
              if (t !== Hh)
                  throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
              i[5].setComponents(a, u, f, _).normalize()
          }
          return this
      }
      intersectsObject(e) {
          if (void 0 !== e.boundingSphere)
              null === e.boundingSphere && e.computeBoundingSphere(),
              Kf.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
              const t = e.geometry;
              null === t.boundingSphere && t.computeBoundingSphere(),
              Kf.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
          }
          return this.intersectsSphere(Kf)
      }
      intersectsSprite(e) {
          return Kf.center.set(0, 0, 0),
          Kf.radius = .7071067811865476,
          Kf.applyMatrix4(e.matrixWorld),
          this.intersectsSphere(Kf)
      }
      intersectsSphere(e) {
          const t = this.planes
            , i = e.center
            , n = -e.radius;
          for (let e = 0; e < 6; e++)
              if (t[e].distanceToPoint(i) < n)
                  return !1;
          return !0
      }
      intersectsBox(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
              const n = t[i];
              if (Zf.x = n.normal.x > 0 ? e.max.x : e.min.x,
              Zf.y = n.normal.y > 0 ? e.max.y : e.min.y,
              Zf.z = n.normal.z > 0 ? e.max.z : e.min.z,
              n.distanceToPoint(Zf) < 0)
                  return !1
          }
          return !0
      }
      containsPoint(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++)
              if (t[i].distanceToPoint(e) < 0)
                  return !1;
          return !0
      }
      clone() {
          return (new this.constructor).copy(this)
      }
  }
  function Jf() {
      let e = null
        , t = !1
        , i = null
        , n = null;
      function r(t, s) {
          i(t, s),
          n = e.requestAnimationFrame(r)
      }
      return {
          start: function() {
              !0 !== t && null !== i && (n = e.requestAnimationFrame(r),
              t = !0)
          },
          stop: function() {
              e.cancelAnimationFrame(n),
              t = !1
          },
          setAnimationLoop: function(e) {
              i = e
          },
          setContext: function(t) {
              e = t
          }
      }
  }
  function Qf(e) {
      const t = new WeakMap;
      return {
          get: function(e) {
              return e.isInterleavedBufferAttribute && (e = e.data),
              t.get(e)
          },
          remove: function(i) {
              i.isInterleavedBufferAttribute && (i = i.data);
              const n = t.get(i);
              n && (e.deleteBuffer(n.buffer),
              t.delete(i))
          },
          update: function(i, n) {
              if (i.isInterleavedBufferAttribute && (i = i.data),
              i.isGLBufferAttribute) {
                  const e = t.get(i);
                  return void ((!e || e.version < i.version) && t.set(i, {
                      buffer: i.buffer,
                      type: i.type,
                      bytesPerElement: i.elementSize,
                      version: i.version
                  }))
              }
              const r = t.get(i);
              if (void 0 === r)
                  t.set(i, function(t, i) {
                      const n = t.array
                        , r = t.usage
                        , s = n.byteLength
                        , a = e.createBuffer();
                      let o;
                      if (e.bindBuffer(i, a),
                      e.bufferData(i, n, r),
                      t.onUploadCallback(),
                      n instanceof Float32Array)
                          o = e.FLOAT;
                      else if (n instanceof Uint16Array)
                          o = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                      else if (n instanceof Int16Array)
                          o = e.SHORT;
                      else if (n instanceof Uint32Array)
                          o = e.UNSIGNED_INT;
                      else if (n instanceof Int32Array)
                          o = e.INT;
                      else if (n instanceof Int8Array)
                          o = e.BYTE;
                      else if (n instanceof Uint8Array)
                          o = e.UNSIGNED_BYTE;
                      else {
                          if (!(n instanceof Uint8ClampedArray))
                              throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + n);
                          o = e.UNSIGNED_BYTE
                      }
                      return {
                          buffer: a,
                          type: o,
                          bytesPerElement: n.BYTES_PER_ELEMENT,
                          version: t.version,
                          size: s
                      }
                  }(i, n));
              else if (r.version < i.version) {
                  if (r.size !== i.array.byteLength)
                      throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                  !function(t, i, n) {
                      const r = i.array
                        , s = i._updateRange
                        , a = i.updateRanges;
                      if (e.bindBuffer(n, t),
                      -1 === s.count && 0 === a.length && e.bufferSubData(n, 0, r),
                      0 !== a.length) {
                          for (let t = 0, i = a.length; t < i; t++) {
                              const i = a[t];
                              e.bufferSubData(n, i.start * r.BYTES_PER_ELEMENT, r, i.start, i.count)
                          }
                          i.clearUpdateRanges()
                      }
                      -1 !== s.count && (e.bufferSubData(n, s.offset * r.BYTES_PER_ELEMENT, r, s.offset, s.count),
                      s.count = -1),
                      i.onUploadCallback()
                  }(r.buffer, i, n),
                  r.version = i.version
              }
          }
      }
  }
  class em extends uf {
      constructor(e=1, t=1, i=1, n=1) {
          super(),
          this.type = "PlaneGeometry",
          this.parameters = {
              width: e,
              height: t,
              widthSegments: i,
              heightSegments: n
          };
          const r = e / 2
            , s = t / 2
            , a = Math.floor(i)
            , o = Math.floor(n)
            , l = a + 1
            , c = o + 1
            , u = e / a
            , h = t / o
            , d = []
            , p = []
            , f = []
            , m = [];
          for (let e = 0; e < c; e++) {
              const t = e * h - s;
              for (let i = 0; i < l; i++) {
                  const n = i * u - r;
                  p.push(n, -t, 0),
                  f.push(0, 0, 1),
                  m.push(i / a),
                  m.push(1 - e / o)
              }
          }
          for (let e = 0; e < o; e++)
              for (let t = 0; t < a; t++) {
                  const i = t + l * e
                    , n = t + l * (e + 1)
                    , r = t + 1 + l * (e + 1)
                    , s = t + 1 + l * e;
                  d.push(i, n, s),
                  d.push(n, r, s)
              }
          this.setIndex(d),
          this.setAttribute("position", new tf(p,3)),
          this.setAttribute("normal", new tf(f,3)),
          this.setAttribute("uv", new tf(m,2))
      }
      copy(e) {
          return super.copy(e),
          this.parameters = Object.assign({}, e.parameters),
          this
      }
      static fromJSON(e) {
          return new em(e.width,e.height,e.widthSegments,e.heightSegments)
      }
  }
  const tm = {
      alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
      alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
      alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
      alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
      alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
      aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
      aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
      batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
      begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
      beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
      iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
      bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
      clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
      common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
      cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
      envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
      envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
      fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
      lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
      lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
      lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
      lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
      lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
      lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
      lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
      lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
      logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
      map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
      morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
      morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
      morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
      morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
      normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
      normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
      normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
      normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
      clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
      clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
      clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
      iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
      opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
      packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
      premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
      shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
      shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
      skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
      transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
      uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
      worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
      distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
      meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
      meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
  }
    , im = {
      common: {
          diffuse: {
              value: new Xp(16777215)
          },
          opacity: {
              value: 1
          },
          map: {
              value: null
          },
          mapTransform: {
              value: new Qh
          },
          alphaMap: {
              value: null
          },
          alphaMapTransform: {
              value: new Qh
          },
          alphaTest: {
              value: 0
          }
      },
      specularmap: {
          specularMap: {
              value: null
          },
          specularMapTransform: {
              value: new Qh
          }
      },
      envmap: {
          envMap: {
              value: null
          },
          envMapRotation: {
              value: new Qh
          },
          flipEnvMap: {
              value: -1
          },
          reflectivity: {
              value: 1
          },
          ior: {
              value: 1.5
          },
          refractionRatio: {
              value: .98
          }
      },
      aomap: {
          aoMap: {
              value: null
          },
          aoMapIntensity: {
              value: 1
          },
          aoMapTransform: {
              value: new Qh
          }
      },
      lightmap: {
          lightMap: {
              value: null
          },
          lightMapIntensity: {
              value: 1
          },
          lightMapTransform: {
              value: new Qh
          }
      },
      bumpmap: {
          bumpMap: {
              value: null
          },
          bumpMapTransform: {
              value: new Qh
          },
          bumpScale: {
              value: 1
          }
      },
      normalmap: {
          normalMap: {
              value: null
          },
          normalMapTransform: {
              value: new Qh
          },
          normalScale: {
              value: new Jh(1,1)
          }
      },
      displacementmap: {
          displacementMap: {
              value: null
          },
          displacementMapTransform: {
              value: new Qh
          },
          displacementScale: {
              value: 1
          },
          displacementBias: {
              value: 0
          }
      },
      emissivemap: {
          emissiveMap: {
              value: null
          },
          emissiveMapTransform: {
              value: new Qh
          }
      },
      metalnessmap: {
          metalnessMap: {
              value: null
          },
          metalnessMapTransform: {
              value: new Qh
          }
      },
      roughnessmap: {
          roughnessMap: {
              value: null
          },
          roughnessMapTransform: {
              value: new Qh
          }
      },
      gradientmap: {
          gradientMap: {
              value: null
          }
      },
      fog: {
          fogDensity: {
              value: 25e-5
          },
          fogNear: {
              value: 1
          },
          fogFar: {
              value: 2e3
          },
          fogColor: {
              value: new Xp(16777215)
          }
      },
      lights: {
          ambientLightColor: {
              value: []
          },
          lightProbe: {
              value: []
          },
          directionalLights: {
              value: [],
              properties: {
                  direction: {},
                  color: {}
              }
          },
          directionalLightShadows: {
              value: [],
              properties: {
                  shadowIntensity: 1,
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {}
              }
          },
          directionalShadowMap: {
              value: []
          },
          directionalShadowMatrix: {
              value: []
          },
          spotLights: {
              value: [],
              properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {}
              }
          },
          spotLightShadows: {
              value: [],
              properties: {
                  shadowIntensity: 1,
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {}
              }
          },
          spotLightMap: {
              value: []
          },
          spotShadowMap: {
              value: []
          },
          spotLightMatrix: {
              value: []
          },
          pointLights: {
              value: [],
              properties: {
                  color: {},
                  position: {},
                  decay: {},
                  distance: {}
              }
          },
          pointLightShadows: {
              value: [],
              properties: {
                  shadowIntensity: 1,
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {}
              }
          },
          pointShadowMap: {
              value: []
          },
          pointShadowMatrix: {
              value: []
          },
          hemisphereLights: {
              value: [],
              properties: {
                  direction: {},
                  skyColor: {},
                  groundColor: {}
              }
          },
          rectAreaLights: {
              value: [],
              properties: {
                  color: {},
                  position: {},
                  width: {},
                  height: {}
              }
          },
          ltc_1: {
              value: null
          },
          ltc_2: {
              value: null
          }
      },
      points: {
          diffuse: {
              value: new Xp(16777215)
          },
          opacity: {
              value: 1
          },
          size: {
              value: 1
          },
          scale: {
              value: 1
          },
          map: {
              value: null
          },
          alphaMap: {
              value: null
          },
          alphaMapTransform: {
              value: new Qh
          },
          alphaTest: {
              value: 0
          },
          uvTransform: {
              value: new Qh
          }
      },
      sprite: {
          diffuse: {
              value: new Xp(16777215)
          },
          opacity: {
              value: 1
          },
          center: {
              value: new Jh(.5,.5)
          },
          rotation: {
              value: 0
          },
          map: {
              value: null
          },
          mapTransform: {
              value: new Qh
          },
          alphaMap: {
              value: null
          },
          alphaMapTransform: {
              value: new Qh
          },
          alphaTest: {
              value: 0
          }
      }
  }
    , nm = {
      basic: {
          uniforms: Lf([im.common, im.specularmap, im.envmap, im.aomap, im.lightmap, im.fog]),
          vertexShader: tm.meshbasic_vert,
          fragmentShader: tm.meshbasic_frag
      },
      lambert: {
          uniforms: Lf([im.common, im.specularmap, im.envmap, im.aomap, im.lightmap, im.emissivemap, im.bumpmap, im.normalmap, im.displacementmap, im.fog, im.lights, {
              emissive: {
                  value: new Xp(0)
              }
          }]),
          vertexShader: tm.meshlambert_vert,
          fragmentShader: tm.meshlambert_frag
      },
      phong: {
          uniforms: Lf([im.common, im.specularmap, im.envmap, im.aomap, im.lightmap, im.emissivemap, im.bumpmap, im.normalmap, im.displacementmap, im.fog, im.lights, {
              emissive: {
                  value: new Xp(0)
              },
              specular: {
                  value: new Xp(1118481)
              },
              shininess: {
                  value: 30
              }
          }]),
          vertexShader: tm.meshphong_vert,
          fragmentShader: tm.meshphong_frag
      },
      standard: {
          uniforms: Lf([im.common, im.envmap, im.aomap, im.lightmap, im.emissivemap, im.bumpmap, im.normalmap, im.displacementmap, im.roughnessmap, im.metalnessmap, im.fog, im.lights, {
              emissive: {
                  value: new Xp(0)
              },
              roughness: {
                  value: 1
              },
              metalness: {
                  value: 0
              },
              envMapIntensity: {
                  value: 1
              }
          }]),
          vertexShader: tm.meshphysical_vert,
          fragmentShader: tm.meshphysical_frag
      },
      toon: {
          uniforms: Lf([im.common, im.aomap, im.lightmap, im.emissivemap, im.bumpmap, im.normalmap, im.displacementmap, im.gradientmap, im.fog, im.lights, {
              emissive: {
                  value: new Xp(0)
              }
          }]),
          vertexShader: tm.meshtoon_vert,
          fragmentShader: tm.meshtoon_frag
      },
      matcap: {
          uniforms: Lf([im.common, im.bumpmap, im.normalmap, im.displacementmap, im.fog, {
              matcap: {
                  value: null
              }
          }]),
          vertexShader: tm.meshmatcap_vert,
          fragmentShader: tm.meshmatcap_frag
      },
      points: {
          uniforms: Lf([im.points, im.fog]),
          vertexShader: tm.points_vert,
          fragmentShader: tm.points_frag
      },
      dashed: {
          uniforms: Lf([im.common, im.fog, {
              scale: {
                  value: 1
              },
              dashSize: {
                  value: 1
              },
              totalSize: {
                  value: 2
              }
          }]),
          vertexShader: tm.linedashed_vert,
          fragmentShader: tm.linedashed_frag
      },
      depth: {
          uniforms: Lf([im.common, im.displacementmap]),
          vertexShader: tm.depth_vert,
          fragmentShader: tm.depth_frag
      },
      normal: {
          uniforms: Lf([im.common, im.bumpmap, im.normalmap, im.displacementmap, {
              opacity: {
                  value: 1
              }
          }]),
          vertexShader: tm.meshnormal_vert,
          fragmentShader: tm.meshnormal_frag
      },
      sprite: {
          uniforms: Lf([im.sprite, im.fog]),
          vertexShader: tm.sprite_vert,
          fragmentShader: tm.sprite_frag
      },
      background: {
          uniforms: {
              uvTransform: {
                  value: new Qh
              },
              t2D: {
                  value: null
              },
              backgroundIntensity: {
                  value: 1
              }
          },
          vertexShader: tm.background_vert,
          fragmentShader: tm.background_frag
      },
      backgroundCube: {
          uniforms: {
              envMap: {
                  value: null
              },
              flipEnvMap: {
                  value: -1
              },
              backgroundBlurriness: {
                  value: 0
              },
              backgroundIntensity: {
                  value: 1
              },
              backgroundRotation: {
                  value: new Qh
              }
          },
          vertexShader: tm.backgroundCube_vert,
          fragmentShader: tm.backgroundCube_frag
      },
      cube: {
          uniforms: {
              tCube: {
                  value: null
              },
              tFlip: {
                  value: -1
              },
              opacity: {
                  value: 1
              }
          },
          vertexShader: tm.cube_vert,
          fragmentShader: tm.cube_frag
      },
      equirect: {
          uniforms: {
              tEquirect: {
                  value: null
              }
          },
          vertexShader: tm.equirect_vert,
          fragmentShader: tm.equirect_frag
      },
      distanceRGBA: {
          uniforms: Lf([im.common, im.displacementmap, {
              referencePosition: {
                  value: new wd
              },
              nearDistance: {
                  value: 1
              },
              farDistance: {
                  value: 1e3
              }
          }]),
          vertexShader: tm.distanceRGBA_vert,
          fragmentShader: tm.distanceRGBA_frag
      },
      shadow: {
          uniforms: Lf([im.lights, im.fog, {
              color: {
                  value: new Xp(0)
              },
              opacity: {
                  value: 1
              }
          }]),
          vertexShader: tm.shadow_vert,
          fragmentShader: tm.shadow_frag
      }
  };
  nm.physical = {
      uniforms: Lf([nm.standard.uniforms, {
          clearcoat: {
              value: 0
          },
          clearcoatMap: {
              value: null
          },
          clearcoatMapTransform: {
              value: new Qh
          },
          clearcoatNormalMap: {
              value: null
          },
          clearcoatNormalMapTransform: {
              value: new Qh
          },
          clearcoatNormalScale: {
              value: new Jh(1,1)
          },
          clearcoatRoughness: {
              value: 0
          },
          clearcoatRoughnessMap: {
              value: null
          },
          clearcoatRoughnessMapTransform: {
              value: new Qh
          },
          dispersion: {
              value: 0
          },
          iridescence: {
              value: 0
          },
          iridescenceMap: {
              value: null
          },
          iridescenceMapTransform: {
              value: new Qh
          },
          iridescenceIOR: {
              value: 1.3
          },
          iridescenceThicknessMinimum: {
              value: 100
          },
          iridescenceThicknessMaximum: {
              value: 400
          },
          iridescenceThicknessMap: {
              value: null
          },
          iridescenceThicknessMapTransform: {
              value: new Qh
          },
          sheen: {
              value: 0
          },
          sheenColor: {
              value: new Xp(0)
          },
          sheenColorMap: {
              value: null
          },
          sheenColorMapTransform: {
              value: new Qh
          },
          sheenRoughness: {
              value: 1
          },
          sheenRoughnessMap: {
              value: null
          },
          sheenRoughnessMapTransform: {
              value: new Qh
          },
          transmission: {
              value: 0
          },
          transmissionMap: {
              value: null
          },
          transmissionMapTransform: {
              value: new Qh
          },
          transmissionSamplerSize: {
              value: new Jh
          },
          transmissionSamplerMap: {
              value: null
          },
          thickness: {
              value: 0
          },
          thicknessMap: {
              value: null
          },
          thicknessMapTransform: {
              value: new Qh
          },
          attenuationDistance: {
              value: 0
          },
          attenuationColor: {
              value: new Xp(0)
          },
          specularColor: {
              value: new Xp(1,1,1)
          },
          specularColorMap: {
              value: null
          },
          specularColorMapTransform: {
              value: new Qh
          },
          specularIntensity: {
              value: 1
          },
          specularIntensityMap: {
              value: null
          },
          specularIntensityMapTransform: {
              value: new Qh
          },
          anisotropyVector: {
              value: new Jh
          },
          anisotropyMap: {
              value: null
          },
          anisotropyMapTransform: {
              value: new Qh
          }
      }]),
      vertexShader: tm.meshphysical_vert,
      fragmentShader: tm.meshphysical_frag
  };
  const rm = {
      r: 0,
      b: 0,
      g: 0
  }
    , sm = new dp
    , am = new ip;
  function om(e, t, i, n, r, s, a) {
      const o = new Xp(0);
      let l, c, u = !0 === s ? 0 : 1, h = null, d = 0, p = null;
      function f(e) {
          let n = !0 === e.isScene ? e.background : null;
          return n && n.isTexture && (n = (e.backgroundBlurriness > 0 ? i : t).get(n)),
          n
      }
      function m(t, i) {
          t.getRGB(rm, If(e)),
          n.buffers.color.setClear(rm.r, rm.g, rm.b, i, a)
      }
      return {
          getClearColor: function() {
              return o
          },
          setClearColor: function(e, t=1) {
              o.set(e),
              u = t,
              m(o, u)
          },
          getClearAlpha: function() {
              return u
          },
          setClearAlpha: function(e) {
              u = e,
              m(o, u)
          },
          render: function(t) {
              let i = !1;
              const r = f(t);
              null === r ? m(o, u) : r && r.isColor && (m(r, 1),
              i = !0);
              const s = e.xr.getEnvironmentBlendMode();
              "additive" === s ? n.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === s && n.buffers.color.setClear(0, 0, 0, 0, a),
              (e.autoClear || i) && (n.buffers.depth.setTest(!0),
              n.buffers.depth.setMask(!0),
              n.buffers.color.setMask(!0),
              e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
          },
          addToRenderList: function(t, i) {
              const n = f(i);
              n && (n.isCubeTexture || n.mapping === gu) ? (void 0 === c && (c = new Cf(new Pf(1,1,1),new Ff({
                  name: "BackgroundCubeMaterial",
                  uniforms: Rf(nm.backgroundCube.uniforms),
                  vertexShader: nm.backgroundCube.vertexShader,
                  fragmentShader: nm.backgroundCube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1
              })),
              c.geometry.deleteAttribute("normal"),
              c.geometry.deleteAttribute("uv"),
              c.onBeforeRender = function(e, t, i) {
                  this.matrixWorld.copyPosition(i.matrixWorld)
              }
              ,
              Object.defineProperty(c.material, "envMap", {
                  get: function() {
                      return this.uniforms.envMap.value
                  }
              }),
              r.update(c)),
              sm.copy(i.backgroundRotation),
              sm.x *= -1,
              sm.y *= -1,
              sm.z *= -1,
              n.isCubeTexture && !1 === n.isRenderTargetTexture && (sm.y *= -1,
              sm.z *= -1),
              c.material.uniforms.envMap.value = n,
              c.material.uniforms.flipEnvMap.value = n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1,
              c.material.uniforms.backgroundBlurriness.value = i.backgroundBlurriness,
              c.material.uniforms.backgroundIntensity.value = i.backgroundIntensity,
              c.material.uniforms.backgroundRotation.value.setFromMatrix4(am.makeRotationFromEuler(sm)),
              c.material.toneMapped = ud.getTransfer(n.colorSpace) !== Oh,
              h === n && d === n.version && p === e.toneMapping || (c.material.needsUpdate = !0,
              h = n,
              d = n.version,
              p = e.toneMapping),
              c.layers.enableAll(),
              t.unshift(c, c.geometry, c.material, 0, 0, null)) : n && n.isTexture && (void 0 === l && (l = new Cf(new em(2,2),new Ff({
                  name: "BackgroundMaterial",
                  uniforms: Rf(nm.background.uniforms),
                  vertexShader: nm.background.vertexShader,
                  fragmentShader: nm.background.fragmentShader,
                  side: 0,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1
              })),
              l.geometry.deleteAttribute("normal"),
              Object.defineProperty(l.material, "map", {
                  get: function() {
                      return this.uniforms.t2D.value
                  }
              }),
              r.update(l)),
              l.material.uniforms.t2D.value = n,
              l.material.uniforms.backgroundIntensity.value = i.backgroundIntensity,
              l.material.toneMapped = ud.getTransfer(n.colorSpace) !== Oh,
              !0 === n.matrixAutoUpdate && n.updateMatrix(),
              l.material.uniforms.uvTransform.value.copy(n.matrix),
              h === n && d === n.version && p === e.toneMapping || (l.material.needsUpdate = !0,
              h = n,
              d = n.version,
              p = e.toneMapping),
              l.layers.enableAll(),
              t.unshift(l, l.geometry, l.material, 0, 0, null))
          }
      }
  }
  function lm(e, t) {
      const i = e.getParameter(e.MAX_VERTEX_ATTRIBS)
        , n = {}
        , r = c(null);
      let s = r
        , a = !1;
      function o(t) {
          return e.bindVertexArray(t)
      }
      function l(t) {
          return e.deleteVertexArray(t)
      }
      function c(e) {
          const t = []
            , n = []
            , r = [];
          for (let e = 0; e < i; e++)
              t[e] = 0,
              n[e] = 0,
              r[e] = 0;
          return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: t,
              enabledAttributes: n,
              attributeDivisors: r,
              object: e,
              attributes: {},
              index: null
          }
      }
      function u() {
          const e = s.newAttributes;
          for (let t = 0, i = e.length; t < i; t++)
              e[t] = 0
      }
      function h(e) {
          d(e, 0)
      }
      function d(t, i) {
          const n = s.newAttributes
            , r = s.enabledAttributes
            , a = s.attributeDivisors;
          n[t] = 1,
          0 === r[t] && (e.enableVertexAttribArray(t),
          r[t] = 1),
          a[t] !== i && (e.vertexAttribDivisor(t, i),
          a[t] = i)
      }
      function p() {
          const t = s.newAttributes
            , i = s.enabledAttributes;
          for (let n = 0, r = i.length; n < r; n++)
              i[n] !== t[n] && (e.disableVertexAttribArray(n),
              i[n] = 0)
      }
      function f(t, i, n, r, s, a, o) {
          !0 === o ? e.vertexAttribIPointer(t, i, n, s, a) : e.vertexAttribPointer(t, i, n, r, s, a)
      }
      function m() {
          g(),
          a = !0,
          s !== r && (s = r,
          o(s.object))
      }
      function g() {
          r.geometry = null,
          r.program = null,
          r.wireframe = !1
      }
      return {
          setup: function(i, r, l, m, g) {
              let v = !1;
              const _ = function(t, i, r) {
                  const s = !0 === r.wireframe;
                  let a = n[t.id];
                  void 0 === a && (a = {},
                  n[t.id] = a);
                  let o = a[i.id];
                  void 0 === o && (o = {},
                  a[i.id] = o);
                  let l = o[s];
                  return void 0 === l && (l = c(e.createVertexArray()),
                  o[s] = l),
                  l
              }(m, l, r);
              s !== _ && (s = _,
              o(s.object)),
              v = function(e, t, i, n) {
                  const r = s.attributes
                    , a = t.attributes;
                  let o = 0;
                  const l = i.getAttributes();
                  for (const t in l)
                      if (l[t].location >= 0) {
                          const i = r[t];
                          let n = a[t];
                          if (void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                          "instanceColor" === t && e.instanceColor && (n = e.instanceColor)),
                          void 0 === i)
                              return !0;
                          if (i.attribute !== n)
                              return !0;
                          if (n && i.data !== n.data)
                              return !0;
                          o++
                      }
                  return s.attributesNum !== o || s.index !== n
              }(i, m, l, g),
              v && function(e, t, i, n) {
                  const r = {}
                    , a = t.attributes;
                  let o = 0;
                  const l = i.getAttributes();
                  for (const t in l)
                      if (l[t].location >= 0) {
                          let i = a[t];
                          void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix),
                          "instanceColor" === t && e.instanceColor && (i = e.instanceColor));
                          const n = {};
                          n.attribute = i,
                          i && i.data && (n.data = i.data),
                          r[t] = n,
                          o++
                      }
                  s.attributes = r,
                  s.attributesNum = o,
                  s.index = n
              }(i, m, l, g),
              null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER),
              (v || a) && (a = !1,
              function(i, n, r, s) {
                  u();
                  const a = s.attributes
                    , o = r.getAttributes()
                    , l = n.defaultAttributeValues;
                  for (const n in o) {
                      const r = o[n];
                      if (r.location >= 0) {
                          let o = a[n];
                          if (void 0 === o && ("instanceMatrix" === n && i.instanceMatrix && (o = i.instanceMatrix),
                          "instanceColor" === n && i.instanceColor && (o = i.instanceColor)),
                          void 0 !== o) {
                              const n = o.normalized
                                , a = o.itemSize
                                , l = t.get(o);
                              if (void 0 === l)
                                  continue;
                              const c = l.buffer
                                , u = l.type
                                , p = l.bytesPerElement
                                , m = u === e.INT || u === e.UNSIGNED_INT || o.gpuType === Au;
                              if (o.isInterleavedBufferAttribute) {
                                  const t = o.data
                                    , l = t.stride
                                    , g = o.offset;
                                  if (t.isInstancedInterleavedBuffer) {
                                      for (let e = 0; e < r.locationSize; e++)
                                          d(r.location + e, t.meshPerAttribute);
                                      !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = t.meshPerAttribute * t.count)
                                  } else
                                      for (let e = 0; e < r.locationSize; e++)
                                          h(r.location + e);
                                  e.bindBuffer(e.ARRAY_BUFFER, c);
                                  for (let e = 0; e < r.locationSize; e++)
                                      f(r.location + e, a / r.locationSize, u, n, l * p, (g + a / r.locationSize * e) * p, m)
                              } else {
                                  if (o.isInstancedBufferAttribute) {
                                      for (let e = 0; e < r.locationSize; e++)
                                          d(r.location + e, o.meshPerAttribute);
                                      !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = o.meshPerAttribute * o.count)
                                  } else
                                      for (let e = 0; e < r.locationSize; e++)
                                          h(r.location + e);
                                  e.bindBuffer(e.ARRAY_BUFFER, c);
                                  for (let e = 0; e < r.locationSize; e++)
                                      f(r.location + e, a / r.locationSize, u, n, a * p, a / r.locationSize * e * p, m)
                              }
                          } else if (void 0 !== l) {
                              const t = l[n];
                              if (void 0 !== t)
                                  switch (t.length) {
                                  case 2:
                                      e.vertexAttrib2fv(r.location, t);
                                      break;
                                  case 3:
                                      e.vertexAttrib3fv(r.location, t);
                                      break;
                                  case 4:
                                      e.vertexAttrib4fv(r.location, t);
                                      break;
                                  default:
                                      e.vertexAttrib1fv(r.location, t)
                                  }
                          }
                      }
                  }
                  p()
              }(i, r, l, m),
              null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer))
          },
          reset: m,
          resetDefaultState: g,
          dispose: function() {
              m();
              for (const e in n) {
                  const t = n[e];
                  for (const e in t) {
                      const i = t[e];
                      for (const e in i)
                          l(i[e].object),
                          delete i[e];
                      delete t[e]
                  }
                  delete n[e]
              }
          },
          releaseStatesOfGeometry: function(e) {
              if (void 0 === n[e.id])
                  return;
              const t = n[e.id];
              for (const e in t) {
                  const i = t[e];
                  for (const e in i)
                      l(i[e].object),
                      delete i[e];
                  delete t[e]
              }
              delete n[e.id]
          },
          releaseStatesOfProgram: function(e) {
              for (const t in n) {
                  const i = n[t];
                  if (void 0 === i[e.id])
                      continue;
                  const r = i[e.id];
                  for (const e in r)
                      l(r[e].object),
                      delete r[e];
                  delete i[e.id]
              }
          },
          initAttributes: u,
          enableAttribute: h,
          disableUnusedAttributes: p
      }
  }
  function cm(e, t, i) {
      let n;
      function r(t, r, s) {
          0 !== s && (e.drawArraysInstanced(n, t, r, s),
          i.update(r, n, s))
      }
      this.setMode = function(e) {
          n = e
      }
      ,
      this.render = function(t, r) {
          e.drawArrays(n, t, r),
          i.update(r, n, 1)
      }
      ,
      this.renderInstances = r,
      this.renderMultiDraw = function(e, r, s) {
          if (0 === s)
              return;
          t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, e, 0, r, 0, s);
          let a = 0;
          for (let e = 0; e < s; e++)
              a += r[e];
          i.update(a, n, 1)
      }
      ,
      this.renderMultiDrawInstances = function(e, s, a, o) {
          if (0 === a)
              return;
          const l = t.get("WEBGL_multi_draw");
          if (null === l)
              for (let t = 0; t < e.length; t++)
                  r(e[t], s[t], o[t]);
          else {
              l.multiDrawArraysInstancedWEBGL(n, e, 0, s, 0, o, 0, a);
              let t = 0;
              for (let e = 0; e < a; e++)
                  t += s[e];
              for (let e = 0; e < o.length; e++)
                  i.update(t, n, o[e])
          }
      }
  }
  function um(e, t, i, n) {
      let r;
      function s(t) {
          if ("highp" === t) {
              if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                  return "highp";
              t = "mediump"
          }
          return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
      }
      let a = void 0 !== i.precision ? i.precision : "highp";
      const o = s(a);
      o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
      a = o);
      const l = !0 === i.logarithmicDepthBuffer
        , c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
        , u = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      return {
          isWebGL2: !0,
          getMaxAnisotropy: function() {
              if (void 0 !== r)
                  return r;
              if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                  const i = t.get("EXT_texture_filter_anisotropic");
                  r = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
              } else
                  r = 0;
              return r
          },
          getMaxPrecision: s,
          textureFormatReadable: function(t) {
              return t === zu || n.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
          },
          textureTypeReadable: function(i) {
              const r = i === Lu && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
              return !(i !== Tu && n.convert(i) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && i !== Ru && !r)
          },
          precision: a,
          logarithmicDepthBuffer: l,
          maxTextures: c,
          maxVertexTextures: u,
          maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
          maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
          maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
          maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
          maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
          maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
          vertexTextures: u > 0,
          maxSamples: e.getParameter(e.MAX_SAMPLES)
      }
  }
  function hm(e) {
      const t = this;
      let i = null
        , n = 0
        , r = !1
        , s = !1;
      const a = new Yf
        , o = new Qh
        , l = {
          value: null,
          needsUpdate: !1
      };
      function c(e, i, n, r) {
          const s = null !== e ? e.length : 0;
          let c = null;
          if (0 !== s) {
              if (c = l.value,
              !0 !== r || null === c) {
                  const t = n + 4 * s
                    , r = i.matrixWorldInverse;
                  o.getNormalMatrix(r),
                  (null === c || c.length < t) && (c = new Float32Array(t));
                  for (let t = 0, i = n; t !== s; ++t,
                  i += 4)
                      a.copy(e[t]).applyMatrix4(r, o),
                      a.normal.toArray(c, i),
                      c[i + 3] = a.constant
              }
              l.value = c,
              l.needsUpdate = !0
          }
          return t.numPlanes = s,
          t.numIntersection = 0,
          c
      }
      this.uniform = l,
      this.numPlanes = 0,
      this.numIntersection = 0,
      this.init = function(e, t) {
          const i = 0 !== e.length || t || 0 !== n || r;
          return r = t,
          n = e.length,
          i
      }
      ,
      this.beginShadows = function() {
          s = !0,
          c(null)
      }
      ,
      this.endShadows = function() {
          s = !1
      }
      ,
      this.setGlobalState = function(e, t) {
          i = c(e, t, 0)
      }
      ,
      this.setState = function(a, o, u) {
          const h = a.clippingPlanes
            , d = a.clipIntersection
            , p = a.clipShadows
            , f = e.get(a);
          if (!r || null === h || 0 === h.length || s && !p)
              s ? c(null) : (l.value !== i && (l.value = i,
              l.needsUpdate = n > 0),
              t.numPlanes = n,
              t.numIntersection = 0);
          else {
              const e = s ? 0 : n
                , t = 4 * e;
              let r = f.clippingState || null;
              l.value = r,
              r = c(h, o, t, u);
              for (let e = 0; e !== t; ++e)
                  r[e] = i[e];
              f.clippingState = r,
              this.numIntersection = d ? this.numPlanes : 0,
              this.numPlanes += e
          }
      }
  }
  function dm(e) {
      let t = new WeakMap;
      function i(e, t) {
          return 303 === t ? e.mapping = fu : 304 === t && (e.mapping = mu),
          e
      }
      function n(e) {
          const i = e.target;
          i.removeEventListener("dispose", n);
          const r = t.get(i);
          void 0 !== r && (t.delete(i),
          r.dispose())
      }
      return {
          get: function(r) {
              if (r && r.isTexture) {
                  const s = r.mapping;
                  if (303 === s || 304 === s) {
                      if (t.has(r))
                          return i(t.get(r).texture, r.mapping);
                      {
                          const s = r.image;
                          if (s && s.height > 0) {
                              const a = new Wf(s.height);
                              return a.fromEquirectangularTexture(e, r),
                              t.set(r, a),
                              r.addEventListener("dispose", n),
                              i(a.texture, r.mapping)
                          }
                          return null
                      }
                  }
              }
              return r
          },
          dispose: function() {
              t = new WeakMap
          }
      }
  }
  class pm extends Of {
      constructor(e=-1, t=1, i=1, n=-1, r=.1, s=2e3) {
          super(),
          this.isOrthographicCamera = !0,
          this.type = "OrthographicCamera",
          this.zoom = 1,
          this.view = null,
          this.left = e,
          this.right = t,
          this.top = i,
          this.bottom = n,
          this.near = r,
          this.far = s,
          this.updateProjectionMatrix()
      }
      copy(e, t) {
          return super.copy(e, t),
          this.left = e.left,
          this.right = e.right,
          this.top = e.top,
          this.bottom = e.bottom,
          this.near = e.near,
          this.far = e.far,
          this.zoom = e.zoom,
          this.view = null === e.view ? null : Object.assign({}, e.view),
          this
      }
      setViewOffset(e, t, i, n, r, s) {
          null === this.view && (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
          }),
          this.view.enabled = !0,
          this.view.fullWidth = e,
          this.view.fullHeight = t,
          this.view.offsetX = i,
          this.view.offsetY = n,
          this.view.width = r,
          this.view.height = s,
          this.updateProjectionMatrix()
      }
      clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix()
      }
      updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom)
            , t = (this.top - this.bottom) / (2 * this.zoom)
            , i = (this.right + this.left) / 2
            , n = (this.top + this.bottom) / 2;
          let r = i - e
            , s = i + e
            , a = n + t
            , o = n - t;
          if (null !== this.view && this.view.enabled) {
              const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              r += e * this.view.offsetX,
              s = r + e * this.view.width,
              a -= t * this.view.offsetY,
              o = a - t * this.view.height
          }
          this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far, this.coordinateSystem),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
      }
      toJSON(e) {
          const t = super.toJSON(e);
          return t.object.zoom = this.zoom,
          t.object.left = this.left,
          t.object.right = this.right,
          t.object.top = this.top,
          t.object.bottom = this.bottom,
          t.object.near = this.near,
          t.object.far = this.far,
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          t
      }
  }
  const fm = [.125, .215, .35, .446, .526, .582]
    , mm = new pm
    , gm = new Xp;
  let vm = null
    , _m = 0
    , ym = 0
    , xm = !1;
  const Sm = (1 + Math.sqrt(5)) / 2
    , Em = 1 / Sm
    , Mm = [new wd(-Sm,Em,0), new wd(Sm,Em,0), new wd(-Em,0,Sm), new wd(Em,0,Sm), new wd(0,Sm,-Em), new wd(0,Sm,Em), new wd(-1,1,-1), new wd(1,1,-1), new wd(-1,1,1), new wd(1,1,1)];
  class bm {
      constructor(e) {
          this._renderer = e,
          this._pingPongRenderTarget = null,
          this._lodMax = 0,
          this._cubeSize = 0,
          this._lodPlanes = [],
          this._sizeLods = [],
          this._sigmas = [],
          this._blurMaterial = null,
          this._cubemapMaterial = null,
          this._equirectMaterial = null,
          this._compileMaterial(this._blurMaterial)
      }
      fromScene(e, t=0, i=.1, n=100) {
          vm = this._renderer.getRenderTarget(),
          _m = this._renderer.getActiveCubeFace(),
          ym = this._renderer.getActiveMipmapLevel(),
          xm = this._renderer.xr.enabled,
          this._renderer.xr.enabled = !1,
          this._setSize(256);
          const r = this._allocateTargets();
          return r.depthBuffer = !0,
          this._sceneToCubeUV(e, i, n, r),
          t > 0 && this._blur(r, 0, 0, t),
          this._applyPMREM(r),
          this._cleanup(r),
          r
      }
      fromEquirectangular(e, t=null) {
          return this._fromTexture(e, t)
      }
      fromCubemap(e, t=null) {
          return this._fromTexture(e, t)
      }
      compileCubemapShader() {
          null === this._cubemapMaterial && (this._cubemapMaterial = Cm(),
          this._compileMaterial(this._cubemapMaterial))
      }
      compileEquirectangularShader() {
          null === this._equirectMaterial && (this._equirectMaterial = Dm(),
          this._compileMaterial(this._equirectMaterial))
      }
      dispose() {
          this._dispose(),
          null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
          null !== this._equirectMaterial && this._equirectMaterial.dispose()
      }
      _setSize(e) {
          this._lodMax = Math.floor(Math.log2(e)),
          this._cubeSize = Math.pow(2, this._lodMax)
      }
      _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(),
          null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
              this._lodPlanes[e].dispose()
      }
      _cleanup(e) {
          this._renderer.setRenderTarget(vm, _m, ym),
          this._renderer.xr.enabled = xm,
          e.scissorTest = !1,
          wm(e, 0, 0, e.width, e.height)
      }
      _fromTexture(e, t) {
          e.mapping === fu || e.mapping === mu ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
          vm = this._renderer.getRenderTarget(),
          _m = this._renderer.getActiveCubeFace(),
          ym = this._renderer.getActiveMipmapLevel(),
          xm = this._renderer.xr.enabled,
          this._renderer.xr.enabled = !1;
          const i = t || this._allocateTargets();
          return this._textureToCubeUV(e, i),
          this._applyPMREM(i),
          this._cleanup(i),
          i
      }
      _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112)
            , t = 4 * this._cubeSize
            , i = {
              magFilter: Eu,
              minFilter: Eu,
              generateMipmaps: !1,
              type: Lu,
              format: zu,
              colorSpace: Lh,
              depthBuffer: !1
          }
            , n = Tm(e, t, i);
          if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
              null !== this._pingPongRenderTarget && this._dispose(),
              this._pingPongRenderTarget = Tm(e, t, i);
              const {_lodMax: n} = this;
              ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                  const t = []
                    , i = []
                    , n = [];
                  let r = e;
                  const s = e - 4 + 1 + fm.length;
                  for (let a = 0; a < s; a++) {
                      const s = Math.pow(2, r);
                      i.push(s);
                      let o = 1 / s;
                      a > e - 4 ? o = fm[a - e + 4 - 1] : 0 === a && (o = 0),
                      n.push(o);
                      const l = 1 / (s - 2)
                        , c = -l
                        , u = 1 + l
                        , h = [c, c, u, c, u, u, c, c, u, u, c, u]
                        , d = 6
                        , p = 6
                        , f = 3
                        , m = 2
                        , g = 1
                        , v = new Float32Array(f * p * d)
                        , _ = new Float32Array(m * p * d)
                        , y = new Float32Array(g * p * d);
                      for (let e = 0; e < d; e++) {
                          const t = e % 3 * 2 / 3 - 1
                            , i = e > 2 ? 0 : -1
                            , n = [t, i, 0, t + 2 / 3, i, 0, t + 2 / 3, i + 1, 0, t, i, 0, t + 2 / 3, i + 1, 0, t, i + 1, 0];
                          v.set(n, f * p * e),
                          _.set(h, m * p * e);
                          const r = [e, e, e, e, e, e];
                          y.set(r, g * p * e)
                      }
                      const x = new uf;
                      x.setAttribute("position", new Jp(v,f)),
                      x.setAttribute("uv", new Jp(_,m)),
                      x.setAttribute("faceIndex", new Jp(y,g)),
                      t.push(x),
                      r > 4 && r--
                  }
                  return {
                      lodPlanes: t,
                      sizeLods: i,
                      sigmas: n
                  }
              }(n)),
              this._blurMaterial = function(e, t, i) {
                  const n = new Float32Array(20)
                    , r = new wd(0,1,0);
                  return new Ff({
                      name: "SphericalGaussianBlur",
                      defines: {
                          n: 20,
                          CUBEUV_TEXEL_WIDTH: 1 / t,
                          CUBEUV_TEXEL_HEIGHT: 1 / i,
                          CUBEUV_MAX_MIP: `${e}.0`
                      },
                      uniforms: {
                          envMap: {
                              value: null
                          },
                          samples: {
                              value: 1
                          },
                          weights: {
                              value: n
                          },
                          latitudinal: {
                              value: !1
                          },
                          dTheta: {
                              value: 0
                          },
                          mipInt: {
                              value: 0
                          },
                          poleAxis: {
                              value: r
                          }
                      },
                      vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                      fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                      blending: 0,
                      depthTest: !1,
                      depthWrite: !1
                  })
              }(n, e, t)
          }
          return n
      }
      _compileMaterial(e) {
          const t = new Cf(this._lodPlanes[0],e);
          this._renderer.compile(t, mm)
      }
      _sceneToCubeUV(e, t, i, n) {
          const r = new kf(90,1,t,i)
            , s = [1, -1, 1, 1, 1, 1]
            , a = [1, 1, 1, -1, -1, -1]
            , o = this._renderer
            , l = o.autoClear
            , c = o.toneMapping;
          o.getClearColor(gm),
          o.toneMapping = au,
          o.autoClear = !1;
          const u = new Kp({
              name: "PMREM.Background",
              side: 1,
              depthWrite: !1,
              depthTest: !1
          })
            , h = new Cf(new Pf,u);
          let d = !1;
          const p = e.background;
          p ? p.isColor && (u.color.copy(p),
          e.background = null,
          d = !0) : (u.color.copy(gm),
          d = !0);
          for (let t = 0; t < 6; t++) {
              const i = t % 3;
              0 === i ? (r.up.set(0, s[t], 0),
              r.lookAt(a[t], 0, 0)) : 1 === i ? (r.up.set(0, 0, s[t]),
              r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0),
              r.lookAt(0, 0, a[t]));
              const l = this._cubeSize;
              wm(n, i * l, t > 2 ? l : 0, l, l),
              o.setRenderTarget(n),
              d && o.render(h, r),
              o.render(e, r)
          }
          h.geometry.dispose(),
          h.material.dispose(),
          o.toneMapping = c,
          o.autoClear = l,
          e.background = p
      }
      _textureToCubeUV(e, t) {
          const i = this._renderer
            , n = e.mapping === fu || e.mapping === mu;
          n ? (null === this._cubemapMaterial && (this._cubemapMaterial = Cm()),
          this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Dm());
          const r = n ? this._cubemapMaterial : this._equirectMaterial
            , s = new Cf(this._lodPlanes[0],r);
          r.uniforms.envMap.value = e;
          const a = this._cubeSize;
          wm(t, 0, 0, 3 * a, 2 * a),
          i.setRenderTarget(t),
          i.render(s, mm)
      }
      _applyPMREM(e) {
          const t = this._renderer
            , i = t.autoClear;
          t.autoClear = !1;
          const n = this._lodPlanes.length;
          for (let t = 1; t < n; t++) {
              const i = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1])
                , r = Mm[(n - t - 1) % Mm.length];
              this._blur(e, t - 1, t, i, r)
          }
          t.autoClear = i
      }
      _blur(e, t, i, n, r) {
          const s = this._pingPongRenderTarget;
          this._halfBlur(e, s, t, i, n, "latitudinal", r),
          this._halfBlur(s, e, i, i, n, "longitudinal", r)
      }
      _halfBlur(e, t, i, n, r, s, a) {
          const o = this._renderer
            , l = this._blurMaterial;
          "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
          const c = new Cf(this._lodPlanes[n],l)
            , u = l.uniforms
            , h = this._sizeLods[i] - 1
            , d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39
            , p = r / d
            , f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
          f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
          const m = [];
          let g = 0;
          for (let e = 0; e < 20; ++e) {
              const t = e / p
                , i = Math.exp(-t * t / 2);
              m.push(i),
              0 === e ? g += i : e < f && (g += 2 * i)
          }
          for (let e = 0; e < m.length; e++)
              m[e] = m[e] / g;
          u.envMap.value = e.texture,
          u.samples.value = f,
          u.weights.value = m,
          u.latitudinal.value = "latitudinal" === s,
          a && (u.poleAxis.value = a);
          const {_lodMax: v} = this;
          u.dTheta.value = d,
          u.mipInt.value = v - i;
          const _ = this._sizeLods[n];
          wm(t, 3 * _ * (n > v - 4 ? n - v + 4 : 0), 4 * (this._cubeSize - _), 3 * _, 2 * _),
          o.setRenderTarget(t),
          o.render(c, mm)
      }
  }
  function Tm(e, t, i) {
      const n = new Ed(e,t,i);
      return n.texture.mapping = gu,
      n.texture.name = "PMREM.cubeUv",
      n.scissorTest = !0,
      n
  }
  function wm(e, t, i, n, r) {
      e.viewport.set(t, i, n, r),
      e.scissor.set(t, i, n, r)
  }
  function Dm() {
      return new Ff({
          name: "EquirectangularToCubeUV",
          uniforms: {
              envMap: {
                  value: null
              }
          },
          vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1
      })
  }
  function Cm() {
      return new Ff({
          name: "CubemapToCubeUV",
          uniforms: {
              envMap: {
                  value: null
              },
              flipEnvMap: {
                  value: -1
              }
          },
          vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1
      })
  }
  function Am(e) {
      let t = new WeakMap
        , i = null;
      function n(e) {
          const i = e.target;
          i.removeEventListener("dispose", n);
          const r = t.get(i);
          void 0 !== r && (t.delete(i),
          r.dispose())
      }
      return {
          get: function(r) {
              if (r && r.isTexture) {
                  const s = r.mapping
                    , a = 303 === s || 304 === s
                    , o = s === fu || s === mu;
                  if (a || o) {
                      let s = t.get(r);
                      const l = void 0 !== s ? s.texture.pmremVersion : 0;
                      if (r.isRenderTargetTexture && r.pmremVersion !== l)
                          return null === i && (i = new bm(e)),
                          s = a ? i.fromEquirectangular(r, s) : i.fromCubemap(r, s),
                          s.texture.pmremVersion = r.pmremVersion,
                          t.set(r, s),
                          s.texture;
                      if (void 0 !== s)
                          return s.texture;
                      {
                          const l = r.image;
                          return a && l && l.height > 0 || o && l && function(e) {
                              let t = 0;
                              for (let i = 0; i < 6; i++)
                                  void 0 !== e[i] && t++;
                              return 6 === t
                          }(l) ? (null === i && (i = new bm(e)),
                          s = a ? i.fromEquirectangular(r) : i.fromCubemap(r),
                          s.texture.pmremVersion = r.pmremVersion,
                          t.set(r, s),
                          r.addEventListener("dispose", n),
                          s.texture) : null
                      }
                  }
              }
              return r
          },
          dispose: function() {
              t = new WeakMap,
              null !== i && (i.dispose(),
              i = null)
          }
      }
  }
  function Pm(e) {
      const t = {};
      function i(i) {
          if (void 0 !== t[i])
              return t[i];
          let n;
          switch (i) {
          case "WEBGL_depth_texture":
              n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
          case "EXT_texture_filter_anisotropic":
              n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
          case "WEBGL_compressed_texture_s3tc":
              n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
          case "WEBGL_compressed_texture_pvrtc":
              n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
          default:
              n = e.getExtension(i)
          }
          return t[i] = n,
          n
      }
      return {
          has: function(e) {
              return null !== i(e)
          },
          init: function() {
              i("EXT_color_buffer_float"),
              i("WEBGL_clip_cull_distance"),
              i("OES_texture_float_linear"),
              i("EXT_color_buffer_half_float"),
              i("WEBGL_multisampled_render_to_texture"),
              i("WEBGL_render_shared_exponent")
          },
          get: function(e) {
              const t = i(e);
              return null === t && sd("THREE.WebGLRenderer: " + e + " extension not supported."),
              t
          }
      }
  }
  function Rm(e, t, i, n) {
      const r = {}
        , s = new WeakMap;
      function a(e) {
          const o = e.target;
          null !== o.index && t.remove(o.index);
          for (const e in o.attributes)
              t.remove(o.attributes[e]);
          for (const e in o.morphAttributes) {
              const i = o.morphAttributes[e];
              for (let e = 0, n = i.length; e < n; e++)
                  t.remove(i[e])
          }
          o.removeEventListener("dispose", a),
          delete r[o.id];
          const l = s.get(o);
          l && (t.remove(l),
          s.delete(o)),
          n.releaseStatesOfGeometry(o),
          !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
          i.memory.geometries--
      }
      function o(e) {
          const i = []
            , n = e.index
            , r = e.attributes.position;
          let a = 0;
          if (null !== n) {
              const e = n.array;
              a = n.version;
              for (let t = 0, n = e.length; t < n; t += 3) {
                  const n = e[t + 0]
                    , r = e[t + 1]
                    , s = e[t + 2];
                  i.push(n, r, r, s, s, n)
              }
          } else {
              if (void 0 === r)
                  return;
              {
                  const e = r.array;
                  a = r.version;
                  for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
                      const e = t + 0
                        , n = t + 1
                        , r = t + 2;
                      i.push(e, n, n, r, r, e)
                  }
              }
          }
          const o = new (td(i) ? ef : Qp)(i,1);
          o.version = a;
          const l = s.get(e);
          l && t.remove(l),
          s.set(e, o)
      }
      return {
          get: function(e, t) {
              return !0 === r[t.id] || (t.addEventListener("dispose", a),
              r[t.id] = !0,
              i.memory.geometries++),
              t
          },
          update: function(i) {
              const n = i.attributes;
              for (const i in n)
                  t.update(n[i], e.ARRAY_BUFFER);
              const r = i.morphAttributes;
              for (const i in r) {
                  const n = r[i];
                  for (let i = 0, r = n.length; i < r; i++)
                      t.update(n[i], e.ARRAY_BUFFER)
              }
          },
          getWireframeAttribute: function(e) {
              const t = s.get(e);
              if (t) {
                  const i = e.index;
                  null !== i && t.version < i.version && o(e)
              } else
                  o(e);
              return s.get(e)
          }
      }
  }
  function Lm(e, t, i) {
      let n, r, s;
      function a(t, a, o) {
          0 !== o && (e.drawElementsInstanced(n, a, r, t * s, o),
          i.update(a, n, o))
      }
      this.setMode = function(e) {
          n = e
      }
      ,
      this.setIndex = function(e) {
          r = e.type,
          s = e.bytesPerElement
      }
      ,
      this.render = function(t, a) {
          e.drawElements(n, a, r, t * s),
          i.update(a, n, 1)
      }
      ,
      this.renderInstances = a,
      this.renderMultiDraw = function(e, s, a) {
          if (0 === a)
              return;
          t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, s, 0, r, e, 0, a);
          let o = 0;
          for (let e = 0; e < a; e++)
              o += s[e];
          i.update(o, n, 1)
      }
      ,
      this.renderMultiDrawInstances = function(e, o, l, c) {
          if (0 === l)
              return;
          const u = t.get("WEBGL_multi_draw");
          if (null === u)
              for (let t = 0; t < e.length; t++)
                  a(e[t] / s, o[t], c[t]);
          else {
              u.multiDrawElementsInstancedWEBGL(n, o, 0, r, e, 0, c, 0, l);
              let t = 0;
              for (let e = 0; e < l; e++)
                  t += o[e];
              for (let e = 0; e < c.length; e++)
                  i.update(t, n, c[e])
          }
      }
  }
  function Im(e) {
      const t = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
      };
      return {
          memory: {
              geometries: 0,
              textures: 0
          },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function() {
              t.calls = 0,
              t.triangles = 0,
              t.points = 0,
              t.lines = 0
          },
          update: function(i, n, r) {
              switch (t.calls++,
              n) {
              case e.TRIANGLES:
                  t.triangles += r * (i / 3);
                  break;
              case e.LINES:
                  t.lines += r * (i / 2);
                  break;
              case e.LINE_STRIP:
                  t.lines += r * (i - 1);
                  break;
              case e.LINE_LOOP:
                  t.lines += r * i;
                  break;
              case e.POINTS:
                  t.points += r * i;
                  break;
              default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", n)
              }
          }
      }
  }
  function Nm(e, t, i) {
      const n = new WeakMap
        , r = new xd;
      return {
          update: function(s, a, o) {
              const l = s.morphTargetInfluences
                , c = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
                , u = void 0 !== c ? c.length : 0;
              let h = n.get(a);
              if (void 0 === h || h.count !== u) {
                  void 0 !== h && h.texture.dispose();
                  const d = void 0 !== a.morphAttributes.position
                    , p = void 0 !== a.morphAttributes.normal
                    , f = void 0 !== a.morphAttributes.color
                    , m = a.morphAttributes.position || []
                    , g = a.morphAttributes.normal || []
                    , v = a.morphAttributes.color || [];
                  let _ = 0;
                  !0 === d && (_ = 1),
                  !0 === p && (_ = 2),
                  !0 === f && (_ = 3);
                  let y = a.attributes.position.count * _
                    , x = 1;
                  y > t.maxTextureSize && (x = Math.ceil(y / t.maxTextureSize),
                  y = t.maxTextureSize);
                  const S = new Float32Array(y * x * 4 * u)
                    , E = new Md(S,y,x,u);
                  E.type = Ru,
                  E.needsUpdate = !0;
                  const M = 4 * _;
                  for (let T = 0; T < u; T++) {
                      const w = m[T]
                        , D = g[T]
                        , C = v[T]
                        , A = y * x * 4 * T;
                      for (let P = 0; P < w.count; P++) {
                          const R = P * M;
                          !0 === d && (r.fromBufferAttribute(w, P),
                          S[A + R + 0] = r.x,
                          S[A + R + 1] = r.y,
                          S[A + R + 2] = r.z,
                          S[A + R + 3] = 0),
                          !0 === p && (r.fromBufferAttribute(D, P),
                          S[A + R + 4] = r.x,
                          S[A + R + 5] = r.y,
                          S[A + R + 6] = r.z,
                          S[A + R + 7] = 0),
                          !0 === f && (r.fromBufferAttribute(C, P),
                          S[A + R + 8] = r.x,
                          S[A + R + 9] = r.y,
                          S[A + R + 10] = r.z,
                          S[A + R + 11] = 4 === C.itemSize ? r.w : 1)
                      }
                  }
                  function b() {
                      E.dispose(),
                      n.delete(a),
                      a.removeEventListener("dispose", b)
                  }
                  h = {
                      count: u,
                      texture: E,
                      size: new Jh(y,x)
                  },
                  n.set(a, h),
                  a.addEventListener("dispose", b)
              }
              if (!0 === s.isInstancedMesh && null !== s.morphTexture)
                  o.getUniforms().setValue(e, "morphTexture", s.morphTexture, i);
              else {
                  let L = 0;
                  for (let N = 0; N < l.length; N++)
                      L += l[N];
                  const I = a.morphTargetsRelative ? 1 : 1 - L;
                  o.getUniforms().setValue(e, "morphTargetBaseInfluence", I),
                  o.getUniforms().setValue(e, "morphTargetInfluences", l)
              }
              o.getUniforms().setValue(e, "morphTargetsTexture", h.texture, i),
              o.getUniforms().setValue(e, "morphTargetsTextureSize", h.size)
          }
      }
  }
  function Fm(e, t, i, n) {
      let r = new WeakMap;
      function s(e) {
          const t = e.target;
          t.removeEventListener("dispose", s),
          i.remove(t.instanceMatrix),
          null !== t.instanceColor && i.remove(t.instanceColor)
      }
      return {
          update: function(a) {
              const o = n.render.frame
                , l = a.geometry
                , c = t.get(a, l);
              if (r.get(c) !== o && (t.update(c),
              r.set(c, o)),
              a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s),
              r.get(a) !== o && (i.update(a.instanceMatrix, e.ARRAY_BUFFER),
              null !== a.instanceColor && i.update(a.instanceColor, e.ARRAY_BUFFER),
              r.set(a, o))),
              a.isSkinnedMesh) {
                  const e = a.skeleton;
                  r.get(e) !== o && (e.update(),
                  r.set(e, o))
              }
              return c
          },
          dispose: function() {
              r = new WeakMap
          }
      }
  }
  class Om extends yd {
      constructor(e, t, i, n, r, s, a, o, l, c=1026) {
          if (c !== Hu && c !== Gu)
              throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          void 0 === i && c === Hu && (i = Pu),
          void 0 === i && c === Gu && (i = Fu),
          super(null, n, r, s, a, o, c, i, l),
          this.isDepthTexture = !0,
          this.image = {
              width: e,
              height: t
          },
          this.magFilter = void 0 !== a ? a : xu,
          this.minFilter = void 0 !== o ? o : xu,
          this.flipY = !1,
          this.generateMipmaps = !1,
          this.compareFunction = null
      }
      copy(e) {
          return super.copy(e),
          this.compareFunction = e.compareFunction,
          this
      }
      toJSON(e) {
          const t = super.toJSON(e);
          return null !== this.compareFunction && (t.compareFunction = this.compareFunction),
          t
      }
  }
  const Um = new yd
    , Bm = new Om(1,1)
    , zm = new Md
    , km = new bd
    , Vm = new Gf
    , Hm = []
    , Gm = []
    , Wm = new Float32Array(16)
    , Xm = new Float32Array(9)
    , qm = new Float32Array(4);
  function jm(e, t, i) {
      const n = e[0];
      if (n <= 0 || n > 0)
          return e;
      const r = t * i;
      let s = Hm[r];
      if (void 0 === s && (s = new Float32Array(r),
      Hm[r] = s),
      0 !== t) {
          n.toArray(s, 0);
          for (let n = 1, r = 0; n !== t; ++n)
              r += i,
              e[n].toArray(s, r)
      }
      return s
  }
  function Ym(e, t) {
      if (e.length !== t.length)
          return !1;
      for (let i = 0, n = e.length; i < n; i++)
          if (e[i] !== t[i])
              return !1;
      return !0
  }
  function Km(e, t) {
      for (let i = 0, n = t.length; i < n; i++)
          e[i] = t[i]
  }
  function Zm(e, t) {
      let i = Gm[t];
      void 0 === i && (i = new Int32Array(t),
      Gm[t] = i);
      for (let n = 0; n !== t; ++n)
          i[n] = e.allocateTextureUnit();
      return i
  }
  function $m(e, t) {
      const i = this.cache;
      i[0] !== t && (e.uniform1f(this.addr, t),
      i[0] = t)
  }
  function Jm(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
          i[0] = t.x,
          i[1] = t.y);
      else {
          if (Ym(i, t))
              return;
          e.uniform2fv(this.addr, t),
          Km(i, t)
      }
  }
  function Qm(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
          i[0] = t.x,
          i[1] = t.y,
          i[2] = t.z);
      else if (void 0 !== t.r)
          i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
          i[0] = t.r,
          i[1] = t.g,
          i[2] = t.b);
      else {
          if (Ym(i, t))
              return;
          e.uniform3fv(this.addr, t),
          Km(i, t)
      }
  }
  function eg(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
          i[0] = t.x,
          i[1] = t.y,
          i[2] = t.z,
          i[3] = t.w);
      else {
          if (Ym(i, t))
              return;
          e.uniform4fv(this.addr, t),
          Km(i, t)
      }
  }
  function tg(e, t) {
      const i = this.cache
        , n = t.elements;
      if (void 0 === n) {
          if (Ym(i, t))
              return;
          e.uniformMatrix2fv(this.addr, !1, t),
          Km(i, t)
      } else {
          if (Ym(i, n))
              return;
          qm.set(n),
          e.uniformMatrix2fv(this.addr, !1, qm),
          Km(i, n)
      }
  }
  function ig(e, t) {
      const i = this.cache
        , n = t.elements;
      if (void 0 === n) {
          if (Ym(i, t))
              return;
          e.uniformMatrix3fv(this.addr, !1, t),
          Km(i, t)
      } else {
          if (Ym(i, n))
              return;
          Xm.set(n),
          e.uniformMatrix3fv(this.addr, !1, Xm),
          Km(i, n)
      }
  }
  function ng(e, t) {
      const i = this.cache
        , n = t.elements;
      if (void 0 === n) {
          if (Ym(i, t))
              return;
          e.uniformMatrix4fv(this.addr, !1, t),
          Km(i, t)
      } else {
          if (Ym(i, n))
              return;
          Wm.set(n),
          e.uniformMatrix4fv(this.addr, !1, Wm),
          Km(i, n)
      }
  }
  function rg(e, t) {
      const i = this.cache;
      i[0] !== t && (e.uniform1i(this.addr, t),
      i[0] = t)
  }
  function sg(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y || (e.uniform2i(this.addr, t.x, t.y),
          i[0] = t.x,
          i[1] = t.y);
      else {
          if (Ym(i, t))
              return;
          e.uniform2iv(this.addr, t),
          Km(i, t)
      }
  }
  function ag(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z),
          i[0] = t.x,
          i[1] = t.y,
          i[2] = t.z);
      else {
          if (Ym(i, t))
              return;
          e.uniform3iv(this.addr, t),
          Km(i, t)
      }
  }
  function og(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
          i[0] = t.x,
          i[1] = t.y,
          i[2] = t.z,
          i[3] = t.w);
      else {
          if (Ym(i, t))
              return;
          e.uniform4iv(this.addr, t),
          Km(i, t)
      }
  }
  function lg(e, t) {
      const i = this.cache;
      i[0] !== t && (e.uniform1ui(this.addr, t),
      i[0] = t)
  }
  function cg(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y),
          i[0] = t.x,
          i[1] = t.y);
      else {
          if (Ym(i, t))
              return;
          e.uniform2uiv(this.addr, t),
          Km(i, t)
      }
  }
  function ug(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z),
          i[0] = t.x,
          i[1] = t.y,
          i[2] = t.z);
      else {
          if (Ym(i, t))
              return;
          e.uniform3uiv(this.addr, t),
          Km(i, t)
      }
  }
  function hg(e, t) {
      const i = this.cache;
      if (void 0 !== t.x)
          i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
          i[0] = t.x,
          i[1] = t.y,
          i[2] = t.z,
          i[3] = t.w);
      else {
          if (Ym(i, t))
              return;
          e.uniform4uiv(this.addr, t),
          Km(i, t)
      }
  }
  function dg(e, t, i) {
      const n = this.cache
        , r = i.allocateTextureUnit();
      let s;
      n[0] !== r && (e.uniform1i(this.addr, r),
      n[0] = r),
      this.type === e.SAMPLER_2D_SHADOW ? (Bm.compareFunction = 515,
      s = Bm) : s = Um,
      i.setTexture2D(t || s, r)
  }
  function pg(e, t, i) {
      const n = this.cache
        , r = i.allocateTextureUnit();
      n[0] !== r && (e.uniform1i(this.addr, r),
      n[0] = r),
      i.setTexture3D(t || km, r)
  }
  function fg(e, t, i) {
      const n = this.cache
        , r = i.allocateTextureUnit();
      n[0] !== r && (e.uniform1i(this.addr, r),
      n[0] = r),
      i.setTextureCube(t || Vm, r)
  }
  function mg(e, t, i) {
      const n = this.cache
        , r = i.allocateTextureUnit();
      n[0] !== r && (e.uniform1i(this.addr, r),
      n[0] = r),
      i.setTexture2DArray(t || zm, r)
  }
  function gg(e, t) {
      e.uniform1fv(this.addr, t)
  }
  function vg(e, t) {
      const i = jm(t, this.size, 2);
      e.uniform2fv(this.addr, i)
  }
  function _g(e, t) {
      const i = jm(t, this.size, 3);
      e.uniform3fv(this.addr, i)
  }
  function yg(e, t) {
      const i = jm(t, this.size, 4);
      e.uniform4fv(this.addr, i)
  }
  function xg(e, t) {
      const i = jm(t, this.size, 4);
      e.uniformMatrix2fv(this.addr, !1, i)
  }
  function Sg(e, t) {
      const i = jm(t, this.size, 9);
      e.uniformMatrix3fv(this.addr, !1, i)
  }
  function Eg(e, t) {
      const i = jm(t, this.size, 16);
      e.uniformMatrix4fv(this.addr, !1, i)
  }
  function Mg(e, t) {
      e.uniform1iv(this.addr, t)
  }
  function bg(e, t) {
      e.uniform2iv(this.addr, t)
  }
  function Tg(e, t) {
      e.uniform3iv(this.addr, t)
  }
  function wg(e, t) {
      e.uniform4iv(this.addr, t)
  }
  function Dg(e, t) {
      e.uniform1uiv(this.addr, t)
  }
  function Cg(e, t) {
      e.uniform2uiv(this.addr, t)
  }
  function Ag(e, t) {
      e.uniform3uiv(this.addr, t)
  }
  function Pg(e, t) {
      e.uniform4uiv(this.addr, t)
  }
  function Rg(e, t, i) {
      const n = this.cache
        , r = t.length
        , s = Zm(i, r);
      Ym(n, s) || (e.uniform1iv(this.addr, s),
      Km(n, s));
      for (let e = 0; e !== r; ++e)
          i.setTexture2D(t[e] || Um, s[e])
  }
  function Lg(e, t, i) {
      const n = this.cache
        , r = t.length
        , s = Zm(i, r);
      Ym(n, s) || (e.uniform1iv(this.addr, s),
      Km(n, s));
      for (let e = 0; e !== r; ++e)
          i.setTexture3D(t[e] || km, s[e])
  }
  function Ig(e, t, i) {
      const n = this.cache
        , r = t.length
        , s = Zm(i, r);
      Ym(n, s) || (e.uniform1iv(this.addr, s),
      Km(n, s));
      for (let e = 0; e !== r; ++e)
          i.setTextureCube(t[e] || Vm, s[e])
  }
  function Ng(e, t, i) {
      const n = this.cache
        , r = t.length
        , s = Zm(i, r);
      Ym(n, s) || (e.uniform1iv(this.addr, s),
      Km(n, s));
      for (let e = 0; e !== r; ++e)
          i.setTexture2DArray(t[e] || zm, s[e])
  }
  class Fg {
      constructor(e, t, i) {
          this.id = e,
          this.addr = i,
          this.cache = [],
          this.type = t.type,
          this.setValue = function(e) {
              switch (e) {
              case 5126:
                  return $m;
              case 35664:
                  return Jm;
              case 35665:
                  return Qm;
              case 35666:
                  return eg;
              case 35674:
                  return tg;
              case 35675:
                  return ig;
              case 35676:
                  return ng;
              case 5124:
              case 35670:
                  return rg;
              case 35667:
              case 35671:
                  return sg;
              case 35668:
              case 35672:
                  return ag;
              case 35669:
              case 35673:
                  return og;
              case 5125:
                  return lg;
              case 36294:
                  return cg;
              case 36295:
                  return ug;
              case 36296:
                  return hg;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                  return dg;
              case 35679:
              case 36299:
              case 36307:
                  return pg;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                  return fg;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                  return mg
              }
          }(t.type)
      }
  }
  class Og {
      constructor(e, t, i) {
          this.id = e,
          this.addr = i,
          this.cache = [],
          this.type = t.type,
          this.size = t.size,
          this.setValue = function(e) {
              switch (e) {
              case 5126:
                  return gg;
              case 35664:
                  return vg;
              case 35665:
                  return _g;
              case 35666:
                  return yg;
              case 35674:
                  return xg;
              case 35675:
                  return Sg;
              case 35676:
                  return Eg;
              case 5124:
              case 35670:
                  return Mg;
              case 35667:
              case 35671:
                  return bg;
              case 35668:
              case 35672:
                  return Tg;
              case 35669:
              case 35673:
                  return wg;
              case 5125:
                  return Dg;
              case 36294:
                  return Cg;
              case 36295:
                  return Ag;
              case 36296:
                  return Pg;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                  return Rg;
              case 35679:
              case 36299:
              case 36307:
                  return Lg;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                  return Ig;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                  return Ng
              }
          }(t.type)
      }
  }
  class Ug {
      constructor(e) {
          this.id = e,
          this.seq = [],
          this.map = {}
      }
      setValue(e, t, i) {
          const n = this.seq;
          for (let r = 0, s = n.length; r !== s; ++r) {
              const s = n[r];
              s.setValue(e, t[s.id], i)
          }
      }
  }
  const Bg = /(\w+)(\])?(\[|\.)?/g;
  function zg(e, t) {
      e.seq.push(t),
      e.map[t.id] = t
  }
  function kg(e, t, i) {
      const n = e.name
        , r = n.length;
      for (Bg.lastIndex = 0; ; ) {
          const s = Bg.exec(n)
            , a = Bg.lastIndex;
          let o = s[1];
          const l = "]" === s[2]
            , c = s[3];
          if (l && (o |= 0),
          void 0 === c || "[" === c && a + 2 === r) {
              zg(i, void 0 === c ? new Fg(o,e,t) : new Og(o,e,t));
              break
          }
          {
              let e = i.map[o];
              void 0 === e && (e = new Ug(o),
              zg(i, e)),
              i = e
          }
      }
  }
  class Vg {
      constructor(e, t) {
          this.seq = [],
          this.map = {};
          const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
          for (let n = 0; n < i; ++n) {
              const i = e.getActiveUniform(t, n);
              kg(i, e.getUniformLocation(t, i.name), this)
          }
      }
      setValue(e, t, i, n) {
          const r = this.map[t];
          void 0 !== r && r.setValue(e, i, n)
      }
      setOptional(e, t, i) {
          const n = t[i];
          void 0 !== n && this.setValue(e, i, n)
      }
      static upload(e, t, i, n) {
          for (let r = 0, s = t.length; r !== s; ++r) {
              const s = t[r]
                , a = i[s.id];
              !1 !== a.needsUpdate && s.setValue(e, a.value, n)
          }
      }
      static seqWithValue(e, t) {
          const i = [];
          for (let n = 0, r = e.length; n !== r; ++n) {
              const r = e[n];
              r.id in t && i.push(r)
          }
          return i
      }
  }
  function Hg(e, t, i) {
      const n = e.createShader(t);
      return e.shaderSource(n, i),
      e.compileShader(n),
      n
  }
  const Gg = 37297;
  let Wg = 0;
  function Xg(e, t, i) {
      const n = e.getShaderParameter(t, e.COMPILE_STATUS)
        , r = e.getShaderInfoLog(t).trim();
      if (n && "" === r)
          return "";
      const s = /ERROR: 0:(\d+)/.exec(r);
      if (s) {
          const n = parseInt(s[1]);
          return i.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
              const i = e.split("\n")
                , n = []
                , r = Math.max(t - 6, 0)
                , s = Math.min(t + 6, i.length);
              for (let e = r; e < s; e++) {
                  const r = e + 1;
                  n.push(`${r === t ? ">" : " "} ${r}: ${i[e]}`)
              }
              return n.join("\n")
          }(e.getShaderSource(t), n)
      }
      return r
  }
  function qg(e, t) {
      const i = function(e) {
          const t = ud.getPrimaries(ud.workingColorSpace)
            , i = ud.getPrimaries(e);
          let n;
          switch (t === i ? n = "" : t === Bh && i === Uh ? n = "LinearDisplayP3ToLinearSRGB" : t === Uh && i === Bh && (n = "LinearSRGBToLinearDisplayP3"),
          e) {
          case Lh:
          case Nh:
              return [n, "LinearTransferOETF"];
          case Rh:
          case Ih:
              return [n, "sRGBTransferOETF"];
          default:
              return console.warn("THREE.WebGLProgram: Unsupported color space:", e),
              [n, "LinearTransferOETF"]
          }
      }(t);
      return `vec4 ${e}( vec4 value ) { return ${i[0]}( ${i[1]}( value ) ); }`
  }
  function jg(e, t) {
      let i;
      switch (t) {
      case ou:
          i = "Linear";
          break;
      case lu:
          i = "Reinhard";
          break;
      case cu:
          i = "OptimizedCineon";
          break;
      case uu:
          i = "ACESFilmic";
          break;
      case du:
          i = "AgX";
          break;
      case pu:
          i = "Neutral";
          break;
      case hu:
          i = "Custom";
          break;
      default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
          i = "Linear"
      }
      return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
  }
  const Yg = new wd;
  function Kg(e) {
      return "" !== e
  }
  function Zg(e, t) {
      const i = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
      return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
  }
  function $g(e, t) {
      return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
  }
  const Jg = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Qg(e) {
      return e.replace(Jg, tv)
  }
  const ev = new Map;
  function tv(e, t) {
      let i = tm[t];
      if (void 0 === i) {
          const e = ev.get(t);
          if (void 0 === e)
              throw new Error("Can not resolve #include <" + t + ">");
          i = tm[e],
          console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
      }
      return Qg(i)
  }
  const iv = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function nv(e) {
      return e.replace(iv, rv)
  }
  function rv(e, t, i, n) {
      let r = "";
      for (let e = parseInt(t); e < parseInt(i); e++)
          r += n.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
      return r
  }
  function sv(e) {
      let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
      return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
      t
  }
  function av(e, t, i, n) {
      const r = e.getContext()
        , s = i.defines;
      let a = i.vertexShader
        , o = i.fragmentShader;
      const l = function(e) {
          let t = "SHADOWMAP_TYPE_BASIC";
          return e.shadowMapType === Qc ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === eu ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === tu && (t = "SHADOWMAP_TYPE_VSM"),
          t
      }(i)
        , c = function(e) {
          let t = "ENVMAP_TYPE_CUBE";
          if (e.envMap)
              switch (e.envMapMode) {
              case fu:
              case mu:
                  t = "ENVMAP_TYPE_CUBE";
                  break;
              case gu:
                  t = "ENVMAP_TYPE_CUBE_UV"
              }
          return t
      }(i)
        , u = function(e) {
          let t = "ENVMAP_MODE_REFLECTION";
          return e.envMap && e.envMapMode === mu && (t = "ENVMAP_MODE_REFRACTION"),
          t
      }(i)
        , h = function(e) {
          let t = "ENVMAP_BLENDING_NONE";
          if (e.envMap)
              switch (e.combine) {
              case nu:
                  t = "ENVMAP_BLENDING_MULTIPLY";
                  break;
              case ru:
                  t = "ENVMAP_BLENDING_MIX";
                  break;
              case su:
                  t = "ENVMAP_BLENDING_ADD"
              }
          return t
      }(i)
        , d = function(e) {
          const t = e.envMapCubeUVHeight;
          if (null === t)
              return null;
          const i = Math.log2(t) - 2
            , n = 1 / t;
          return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
              texelHeight: n,
              maxMip: i
          }
      }(i)
        , p = function(e) {
          return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Kg).join("\n")
      }(i)
        , f = function(e) {
          const t = [];
          for (const i in e) {
              const n = e[i];
              !1 !== n && t.push("#define " + i + " " + n)
          }
          return t.join("\n")
      }(s)
        , m = r.createProgram();
      let g, v, _ = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
      i.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, f].filter(Kg).join("\n"),
      g.length > 0 && (g += "\n"),
      v = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, f].filter(Kg).join("\n"),
      v.length > 0 && (v += "\n")) : (g = [sv(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, f, i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", i.batching ? "#define USE_BATCHING" : "", i.batchingColor ? "#define USE_BATCHING_COLOR" : "", i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + u : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.mapUv ? "#define MAP_UV " + i.mapUv : "", i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "", i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "", i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "", i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "", i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "", i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "", i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "", i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "", i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "", i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "", i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "", i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "", i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "", i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "", i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "", i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "", i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "", i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "", i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "", i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "", i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "", i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "", i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphColors ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Kg).join("\n"),
      v = [sv(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, f, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + u : "", i.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.dispersion ? "#define USE_DISPERSION" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== au ? "#define TONE_MAPPING" : "", i.toneMapping !== au ? tm.tonemapping_pars_fragment : "", i.toneMapping !== au ? jg("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", tm.colorspace_pars_fragment, qg("linearToOutputTexel", i.outputColorSpace), (ud.getLuminanceCoefficients(Yg),
      ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${Yg.x.toFixed(4)}, ${Yg.y.toFixed(4)}, ${Yg.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Kg).join("\n")),
      a = Qg(a),
      a = Zg(a, i),
      a = $g(a, i),
      o = Qg(o),
      o = Zg(o, i),
      o = $g(o, i),
      a = nv(a),
      o = nv(o),
      !0 !== i.isRawShaderMaterial && (_ = "#version 300 es\n",
      g = [p, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
      v = ["#define varying in", i.glslVersion === kh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === kh ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
      const y = _ + g + a
        , x = _ + v + o
        , S = Hg(r, r.VERTEX_SHADER, y)
        , E = Hg(r, r.FRAGMENT_SHADER, x);
      function M(t) {
          if (e.debug.checkShaderErrors) {
              const i = r.getProgramInfoLog(m).trim()
                , n = r.getShaderInfoLog(S).trim()
                , s = r.getShaderInfoLog(E).trim();
              let a = !0
                , o = !0;
              if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
                  if (a = !1,
                  "function" == typeof e.debug.onShaderError)
                      e.debug.onShaderError(r, m, S, E);
                  else {
                      const e = Xg(r, S, "vertex")
                        , n = Xg(r, E, "fragment");
                      console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + i + "\n" + e + "\n" + n)
                  }
              else
                  "" !== i ? console.warn("THREE.WebGLProgram: Program Info Log:", i) : "" !== n && "" !== s || (o = !1);
              o && (t.diagnostics = {
                  runnable: a,
                  programLog: i,
                  vertexShader: {
                      log: n,
                      prefix: g
                  },
                  fragmentShader: {
                      log: s,
                      prefix: v
                  }
              })
          }
          r.deleteShader(S),
          r.deleteShader(E),
          b = new Vg(r,m),
          T = function(e, t) {
              const i = {}
                , n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
              for (let r = 0; r < n; r++) {
                  const n = e.getActiveAttrib(t, r)
                    , s = n.name;
                  let a = 1;
                  n.type === e.FLOAT_MAT2 && (a = 2),
                  n.type === e.FLOAT_MAT3 && (a = 3),
                  n.type === e.FLOAT_MAT4 && (a = 4),
                  i[s] = {
                      type: n.type,
                      location: e.getAttribLocation(t, s),
                      locationSize: a
                  }
              }
              return i
          }(r, m)
      }
      let b, T;
      r.attachShader(m, S),
      r.attachShader(m, E),
      void 0 !== i.index0AttributeName ? r.bindAttribLocation(m, 0, i.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(m, 0, "position"),
      r.linkProgram(m),
      this.getUniforms = function() {
          return void 0 === b && M(this),
          b
      }
      ,
      this.getAttributes = function() {
          return void 0 === T && M(this),
          T
      }
      ;
      let w = !1 === i.rendererExtensionParallelShaderCompile;
      return this.isReady = function() {
          return !1 === w && (w = r.getProgramParameter(m, Gg)),
          w
      }
      ,
      this.destroy = function() {
          n.releaseStatesOfProgram(this),
          r.deleteProgram(m),
          this.program = void 0
      }
      ,
      this.type = i.shaderType,
      this.name = i.shaderName,
      this.id = Wg++,
      this.cacheKey = t,
      this.usedTimes = 1,
      this.program = m,
      this.vertexShader = S,
      this.fragmentShader = E,
      this
  }
  let ov = 0;
  class lv {
      constructor() {
          this.shaderCache = new Map,
          this.materialCache = new Map
      }
      update(e) {
          const t = e.vertexShader
            , i = e.fragmentShader
            , n = this._getShaderStage(t)
            , r = this._getShaderStage(i)
            , s = this._getShaderCacheForMaterial(e);
          return !1 === s.has(n) && (s.add(n),
          n.usedTimes++),
          !1 === s.has(r) && (s.add(r),
          r.usedTimes++),
          this
      }
      remove(e) {
          const t = this.materialCache.get(e);
          for (const e of t)
              e.usedTimes--,
              0 === e.usedTimes && this.shaderCache.delete(e.code);
          return this.materialCache.delete(e),
          this
      }
      getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id
      }
      getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id
      }
      dispose() {
          this.shaderCache.clear(),
          this.materialCache.clear()
      }
      _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let i = t.get(e);
          return void 0 === i && (i = new Set,
          t.set(e, i)),
          i
      }
      _getShaderStage(e) {
          const t = this.shaderCache;
          let i = t.get(e);
          return void 0 === i && (i = new cv(e),
          t.set(e, i)),
          i
      }
  }
  class cv {
      constructor(e) {
          this.id = ov++,
          this.code = e,
          this.usedTimes = 0
      }
  }
  function uv(e, t, i, n, r, s, a) {
      const o = new pp
        , l = new lv
        , c = new Set
        , u = []
        , h = r.logarithmicDepthBuffer
        , d = r.vertexTextures;
      let p = r.precision;
      const f = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
      };
      function m(e) {
          return c.add(e),
          0 === e ? "uv" : `uv${e}`
      }
      return {
          getParameters: function(s, o, u, g, v) {
              const _ = g.fog
                , y = v.geometry
                , x = s.isMeshStandardMaterial ? g.environment : null
                , S = (s.isMeshStandardMaterial ? i : t).get(s.envMap || x)
                , E = S && S.mapping === gu ? S.image.height : null
                , M = f[s.type];
              null !== s.precision && (p = r.getMaxPrecision(s.precision),
              p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead."));
              const b = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color
                , T = void 0 !== b ? b.length : 0;
              let w, D, C, A, P = 0;
              if (void 0 !== y.morphAttributes.position && (P = 1),
              void 0 !== y.morphAttributes.normal && (P = 2),
              void 0 !== y.morphAttributes.color && (P = 3),
              M) {
                  const e = nm[M];
                  w = e.vertexShader,
                  D = e.fragmentShader
              } else
                  w = s.vertexShader,
                  D = s.fragmentShader,
                  l.update(s),
                  C = l.getVertexShaderID(s),
                  A = l.getFragmentShaderID(s);
              const R = e.getRenderTarget()
                , L = !0 === v.isInstancedMesh
                , I = !0 === v.isBatchedMesh
                , N = !!s.map
                , F = !!s.matcap
                , O = !!S
                , U = !!s.aoMap
                , B = !!s.lightMap
                , z = !!s.bumpMap
                , k = !!s.normalMap
                , V = !!s.displacementMap
                , H = !!s.emissiveMap
                , G = !!s.metalnessMap
                , W = !!s.roughnessMap
                , X = s.anisotropy > 0
                , q = s.clearcoat > 0
                , j = s.dispersion > 0
                , Y = s.iridescence > 0
                , K = s.sheen > 0
                , Z = s.transmission > 0
                , $ = X && !!s.anisotropyMap
                , J = q && !!s.clearcoatMap
                , Q = q && !!s.clearcoatNormalMap
                , ee = q && !!s.clearcoatRoughnessMap
                , te = Y && !!s.iridescenceMap
                , ie = Y && !!s.iridescenceThicknessMap
                , ne = K && !!s.sheenColorMap
                , re = K && !!s.sheenRoughnessMap
                , se = !!s.specularMap
                , ae = !!s.specularColorMap
                , oe = !!s.specularIntensityMap
                , le = Z && !!s.transmissionMap
                , ce = Z && !!s.thicknessMap
                , ue = !!s.gradientMap
                , he = !!s.alphaMap
                , de = s.alphaTest > 0
                , pe = !!s.alphaHash
                , fe = !!s.extensions;
              let me = au;
              s.toneMapped && (null !== R && !0 !== R.isXRRenderTarget || (me = e.toneMapping));
              const ge = {
                  shaderID: M,
                  shaderType: s.type,
                  shaderName: s.name,
                  vertexShader: w,
                  fragmentShader: D,
                  defines: s.defines,
                  customVertexShaderID: C,
                  customFragmentShaderID: A,
                  isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                  glslVersion: s.glslVersion,
                  precision: p,
                  batching: I,
                  batchingColor: I && null !== v._colorsTexture,
                  instancing: L,
                  instancingColor: L && null !== v.instanceColor,
                  instancingMorph: L && null !== v.morphTexture,
                  supportsVertexTextures: d,
                  outputColorSpace: null === R ? e.outputColorSpace : !0 === R.isXRRenderTarget ? R.texture.colorSpace : Lh,
                  alphaToCoverage: !!s.alphaToCoverage,
                  map: N,
                  matcap: F,
                  envMap: O,
                  envMapMode: O && S.mapping,
                  envMapCubeUVHeight: E,
                  aoMap: U,
                  lightMap: B,
                  bumpMap: z,
                  normalMap: k,
                  displacementMap: d && V,
                  emissiveMap: H,
                  normalMapObjectSpace: k && 1 === s.normalMapType,
                  normalMapTangentSpace: k && 0 === s.normalMapType,
                  metalnessMap: G,
                  roughnessMap: W,
                  anisotropy: X,
                  anisotropyMap: $,
                  clearcoat: q,
                  clearcoatMap: J,
                  clearcoatNormalMap: Q,
                  clearcoatRoughnessMap: ee,
                  dispersion: j,
                  iridescence: Y,
                  iridescenceMap: te,
                  iridescenceThicknessMap: ie,
                  sheen: K,
                  sheenColorMap: ne,
                  sheenRoughnessMap: re,
                  specularMap: se,
                  specularColorMap: ae,
                  specularIntensityMap: oe,
                  transmission: Z,
                  transmissionMap: le,
                  thicknessMap: ce,
                  gradientMap: ue,
                  opaque: !1 === s.transparent && 1 === s.blending && !1 === s.alphaToCoverage,
                  alphaMap: he,
                  alphaTest: de,
                  alphaHash: pe,
                  combine: s.combine,
                  mapUv: N && m(s.map.channel),
                  aoMapUv: U && m(s.aoMap.channel),
                  lightMapUv: B && m(s.lightMap.channel),
                  bumpMapUv: z && m(s.bumpMap.channel),
                  normalMapUv: k && m(s.normalMap.channel),
                  displacementMapUv: V && m(s.displacementMap.channel),
                  emissiveMapUv: H && m(s.emissiveMap.channel),
                  metalnessMapUv: G && m(s.metalnessMap.channel),
                  roughnessMapUv: W && m(s.roughnessMap.channel),
                  anisotropyMapUv: $ && m(s.anisotropyMap.channel),
                  clearcoatMapUv: J && m(s.clearcoatMap.channel),
                  clearcoatNormalMapUv: Q && m(s.clearcoatNormalMap.channel),
                  clearcoatRoughnessMapUv: ee && m(s.clearcoatRoughnessMap.channel),
                  iridescenceMapUv: te && m(s.iridescenceMap.channel),
                  iridescenceThicknessMapUv: ie && m(s.iridescenceThicknessMap.channel),
                  sheenColorMapUv: ne && m(s.sheenColorMap.channel),
                  sheenRoughnessMapUv: re && m(s.sheenRoughnessMap.channel),
                  specularMapUv: se && m(s.specularMap.channel),
                  specularColorMapUv: ae && m(s.specularColorMap.channel),
                  specularIntensityMapUv: oe && m(s.specularIntensityMap.channel),
                  transmissionMapUv: le && m(s.transmissionMap.channel),
                  thicknessMapUv: ce && m(s.thicknessMap.channel),
                  alphaMapUv: he && m(s.alphaMap.channel),
                  vertexTangents: !!y.attributes.tangent && (k || X),
                  vertexColors: s.vertexColors,
                  vertexAlphas: !0 === s.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                  pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (N || he),
                  fog: !!_,
                  useFog: !0 === s.fog,
                  fogExp2: !!_ && _.isFogExp2,
                  flatShading: !0 === s.flatShading,
                  sizeAttenuation: !0 === s.sizeAttenuation,
                  logarithmicDepthBuffer: h,
                  skinning: !0 === v.isSkinnedMesh,
                  morphTargets: void 0 !== y.morphAttributes.position,
                  morphNormals: void 0 !== y.morphAttributes.normal,
                  morphColors: void 0 !== y.morphAttributes.color,
                  morphTargetsCount: T,
                  morphTextureStride: P,
                  numDirLights: o.directional.length,
                  numPointLights: o.point.length,
                  numSpotLights: o.spot.length,
                  numSpotLightMaps: o.spotLightMap.length,
                  numRectAreaLights: o.rectArea.length,
                  numHemiLights: o.hemi.length,
                  numDirLightShadows: o.directionalShadowMap.length,
                  numPointLightShadows: o.pointShadowMap.length,
                  numSpotLightShadows: o.spotShadowMap.length,
                  numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                  numLightProbes: o.numLightProbes,
                  numClippingPlanes: a.numPlanes,
                  numClipIntersection: a.numIntersection,
                  dithering: s.dithering,
                  shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                  shadowMapType: e.shadowMap.type,
                  toneMapping: me,
                  decodeVideoTexture: N && !0 === s.map.isVideoTexture && ud.getTransfer(s.map.colorSpace) === Oh,
                  premultipliedAlpha: s.premultipliedAlpha,
                  doubleSided: 2 === s.side,
                  flipSided: 1 === s.side,
                  useDepthPacking: s.depthPacking >= 0,
                  depthPacking: s.depthPacking || 0,
                  index0AttributeName: s.index0AttributeName,
                  extensionClipCullDistance: fe && !0 === s.extensions.clipCullDistance && n.has("WEBGL_clip_cull_distance"),
                  extensionMultiDraw: (fe && !0 === s.extensions.multiDraw || I) && n.has("WEBGL_multi_draw"),
                  rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
                  customProgramCacheKey: s.customProgramCacheKey()
              };
              return ge.vertexUv1s = c.has(1),
              ge.vertexUv2s = c.has(2),
              ge.vertexUv3s = c.has(3),
              c.clear(),
              ge
          },
          getProgramCacheKey: function(t) {
              const i = [];
              if (t.shaderID ? i.push(t.shaderID) : (i.push(t.customVertexShaderID),
              i.push(t.customFragmentShaderID)),
              void 0 !== t.defines)
                  for (const e in t.defines)
                      i.push(e),
                      i.push(t.defines[e]);
              return !1 === t.isRawShaderMaterial && (function(e, t) {
                  e.push(t.precision),
                  e.push(t.outputColorSpace),
                  e.push(t.envMapMode),
                  e.push(t.envMapCubeUVHeight),
                  e.push(t.mapUv),
                  e.push(t.alphaMapUv),
                  e.push(t.lightMapUv),
                  e.push(t.aoMapUv),
                  e.push(t.bumpMapUv),
                  e.push(t.normalMapUv),
                  e.push(t.displacementMapUv),
                  e.push(t.emissiveMapUv),
                  e.push(t.metalnessMapUv),
                  e.push(t.roughnessMapUv),
                  e.push(t.anisotropyMapUv),
                  e.push(t.clearcoatMapUv),
                  e.push(t.clearcoatNormalMapUv),
                  e.push(t.clearcoatRoughnessMapUv),
                  e.push(t.iridescenceMapUv),
                  e.push(t.iridescenceThicknessMapUv),
                  e.push(t.sheenColorMapUv),
                  e.push(t.sheenRoughnessMapUv),
                  e.push(t.specularMapUv),
                  e.push(t.specularColorMapUv),
                  e.push(t.specularIntensityMapUv),
                  e.push(t.transmissionMapUv),
                  e.push(t.thicknessMapUv),
                  e.push(t.combine),
                  e.push(t.fogExp2),
                  e.push(t.sizeAttenuation),
                  e.push(t.morphTargetsCount),
                  e.push(t.morphAttributeCount),
                  e.push(t.numDirLights),
                  e.push(t.numPointLights),
                  e.push(t.numSpotLights),
                  e.push(t.numSpotLightMaps),
                  e.push(t.numHemiLights),
                  e.push(t.numRectAreaLights),
                  e.push(t.numDirLightShadows),
                  e.push(t.numPointLightShadows),
                  e.push(t.numSpotLightShadows),
                  e.push(t.numSpotLightShadowsWithMaps),
                  e.push(t.numLightProbes),
                  e.push(t.shadowMapType),
                  e.push(t.toneMapping),
                  e.push(t.numClippingPlanes),
                  e.push(t.numClipIntersection),
                  e.push(t.depthPacking)
              }(i, t),
              function(e, t) {
                  o.disableAll(),
                  t.supportsVertexTextures && o.enable(0),
                  t.instancing && o.enable(1),
                  t.instancingColor && o.enable(2),
                  t.instancingMorph && o.enable(3),
                  t.matcap && o.enable(4),
                  t.envMap && o.enable(5),
                  t.normalMapObjectSpace && o.enable(6),
                  t.normalMapTangentSpace && o.enable(7),
                  t.clearcoat && o.enable(8),
                  t.iridescence && o.enable(9),
                  t.alphaTest && o.enable(10),
                  t.vertexColors && o.enable(11),
                  t.vertexAlphas && o.enable(12),
                  t.vertexUv1s && o.enable(13),
                  t.vertexUv2s && o.enable(14),
                  t.vertexUv3s && o.enable(15),
                  t.vertexTangents && o.enable(16),
                  t.anisotropy && o.enable(17),
                  t.alphaHash && o.enable(18),
                  t.batching && o.enable(19),
                  t.dispersion && o.enable(20),
                  t.batchingColor && o.enable(21),
                  e.push(o.mask),
                  o.disableAll(),
                  t.fog && o.enable(0),
                  t.useFog && o.enable(1),
                  t.flatShading && o.enable(2),
                  t.logarithmicDepthBuffer && o.enable(3),
                  t.skinning && o.enable(4),
                  t.morphTargets && o.enable(5),
                  t.morphNormals && o.enable(6),
                  t.morphColors && o.enable(7),
                  t.premultipliedAlpha && o.enable(8),
                  t.shadowMapEnabled && o.enable(9),
                  t.doubleSided && o.enable(10),
                  t.flipSided && o.enable(11),
                  t.useDepthPacking && o.enable(12),
                  t.dithering && o.enable(13),
                  t.transmission && o.enable(14),
                  t.sheen && o.enable(15),
                  t.opaque && o.enable(16),
                  t.pointsUvs && o.enable(17),
                  t.decodeVideoTexture && o.enable(18),
                  t.alphaToCoverage && o.enable(19),
                  e.push(o.mask)
              }(i, t),
              i.push(e.outputColorSpace)),
              i.push(t.customProgramCacheKey),
              i.join()
          },
          getUniforms: function(e) {
              const t = f[e.type];
              let i;
              if (t) {
                  const e = nm[t];
                  i = Nf.clone(e.uniforms)
              } else
                  i = e.uniforms;
              return i
          },
          acquireProgram: function(t, i) {
              let n;
              for (let e = 0, t = u.length; e < t; e++) {
                  const t = u[e];
                  if (t.cacheKey === i) {
                      n = t,
                      ++n.usedTimes;
                      break
                  }
              }
              return void 0 === n && (n = new av(e,i,t,s),
              u.push(n)),
              n
          },
          releaseProgram: function(e) {
              if (0 == --e.usedTimes) {
                  const t = u.indexOf(e);
                  u[t] = u[u.length - 1],
                  u.pop(),
                  e.destroy()
              }
          },
          releaseShaderCache: function(e) {
              l.remove(e)
          },
          programs: u,
          dispose: function() {
              l.dispose()
          }
      }
  }
  function hv() {
      let e = new WeakMap;
      return {
          get: function(t) {
              let i = e.get(t);
              return void 0 === i && (i = {},
              e.set(t, i)),
              i
          },
          remove: function(t) {
              e.delete(t)
          },
          update: function(t, i, n) {
              e.get(t)[i] = n
          },
          dispose: function() {
              e = new WeakMap
          }
      }
  }
  function dv(e, t) {
      return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
  }
  function pv(e, t) {
      return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
  }
  function fv() {
      const e = [];
      let t = 0;
      const i = []
        , n = []
        , r = [];
      function s(i, n, r, s, a, o) {
          let l = e[t];
          return void 0 === l ? (l = {
              id: i.id,
              object: i,
              geometry: n,
              material: r,
              groupOrder: s,
              renderOrder: i.renderOrder,
              z: a,
              group: o
          },
          e[t] = l) : (l.id = i.id,
          l.object = i,
          l.geometry = n,
          l.material = r,
          l.groupOrder = s,
          l.renderOrder = i.renderOrder,
          l.z = a,
          l.group = o),
          t++,
          l
      }
      return {
          opaque: i,
          transmissive: n,
          transparent: r,
          init: function() {
              t = 0,
              i.length = 0,
              n.length = 0,
              r.length = 0
          },
          push: function(e, t, a, o, l, c) {
              const u = s(e, t, a, o, l, c);
              a.transmission > 0 ? n.push(u) : !0 === a.transparent ? r.push(u) : i.push(u)
          },
          unshift: function(e, t, a, o, l, c) {
              const u = s(e, t, a, o, l, c);
              a.transmission > 0 ? n.unshift(u) : !0 === a.transparent ? r.unshift(u) : i.unshift(u)
          },
          finish: function() {
              for (let i = t, n = e.length; i < n; i++) {
                  const t = e[i];
                  if (null === t.id)
                      break;
                  t.id = null,
                  t.object = null,
                  t.geometry = null,
                  t.material = null,
                  t.group = null
              }
          },
          sort: function(e, t) {
              i.length > 1 && i.sort(e || dv),
              n.length > 1 && n.sort(t || pv),
              r.length > 1 && r.sort(t || pv)
          }
      }
  }
  function mv() {
      let e = new WeakMap;
      return {
          get: function(t, i) {
              const n = e.get(t);
              let r;
              return void 0 === n ? (r = new fv,
              e.set(t, [r])) : i >= n.length ? (r = new fv,
              n.push(r)) : r = n[i],
              r
          },
          dispose: function() {
              e = new WeakMap
          }
      }
  }
  function gv() {
      const e = {};
      return {
          get: function(t) {
              if (void 0 !== e[t.id])
                  return e[t.id];
              let i;
              switch (t.type) {
              case "DirectionalLight":
                  i = {
                      direction: new wd,
                      color: new Xp
                  };
                  break;
              case "SpotLight":
                  i = {
                      position: new wd,
                      direction: new wd,
                      color: new Xp,
                      distance: 0,
                      coneCos: 0,
                      penumbraCos: 0,
                      decay: 0
                  };
                  break;
              case "PointLight":
                  i = {
                      position: new wd,
                      color: new Xp,
                      distance: 0,
                      decay: 0
                  };
                  break;
              case "HemisphereLight":
                  i = {
                      direction: new wd,
                      skyColor: new Xp,
                      groundColor: new Xp
                  };
                  break;
              case "RectAreaLight":
                  i = {
                      color: new Xp,
                      position: new wd,
                      halfWidth: new wd,
                      halfHeight: new wd
                  }
              }
              return e[t.id] = i,
              i
          }
      }
  }
  let vv = 0;
  function _v(e, t) {
      return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
  }
  function yv(e) {
      const t = new gv
        , i = function() {
          const e = {};
          return {
              get: function(t) {
                  if (void 0 !== e[t.id])
                      return e[t.id];
                  let i;
                  switch (t.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                      i = {
                          shadowIntensity: 1,
                          shadowBias: 0,
                          shadowNormalBias: 0,
                          shadowRadius: 1,
                          shadowMapSize: new Jh
                      };
                      break;
                  case "PointLight":
                      i = {
                          shadowIntensity: 1,
                          shadowBias: 0,
                          shadowNormalBias: 0,
                          shadowRadius: 1,
                          shadowMapSize: new Jh,
                          shadowCameraNear: 1,
                          shadowCameraFar: 1e3
                      }
                  }
                  return e[t.id] = i,
                  i
              }
          }
      }()
        , n = {
          version: 0,
          hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
              numLightProbes: -1
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotLightMap: [],
          spotShadow: [],
          spotShadowMap: [],
          spotLightMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numSpotLightShadowsWithMaps: 0,
          numLightProbes: 0
      };
      for (let e = 0; e < 9; e++)
          n.probe.push(new wd);
      const r = new wd
        , s = new ip
        , a = new ip;
      return {
          setup: function(r) {
              let s = 0
                , a = 0
                , o = 0;
              for (let e = 0; e < 9; e++)
                  n.probe[e].set(0, 0, 0);
              let l = 0
                , c = 0
                , u = 0
                , h = 0
                , d = 0
                , p = 0
                , f = 0
                , m = 0
                , g = 0
                , v = 0
                , _ = 0;
              r.sort(_v);
              for (let e = 0, y = r.length; e < y; e++) {
                  const y = r[e]
                    , x = y.color
                    , S = y.intensity
                    , E = y.distance
                    , M = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                  if (y.isAmbientLight)
                      s += x.r * S,
                      a += x.g * S,
                      o += x.b * S;
                  else if (y.isLightProbe) {
                      for (let e = 0; e < 9; e++)
                          n.probe[e].addScaledVector(y.sh.coefficients[e], S);
                      _++
                  } else if (y.isDirectionalLight) {
                      const e = t.get(y);
                      if (e.color.copy(y.color).multiplyScalar(y.intensity),
                      y.castShadow) {
                          const e = y.shadow
                            , t = i.get(y);
                          t.shadowIntensity = e.intensity,
                          t.shadowBias = e.bias,
                          t.shadowNormalBias = e.normalBias,
                          t.shadowRadius = e.radius,
                          t.shadowMapSize = e.mapSize,
                          n.directionalShadow[l] = t,
                          n.directionalShadowMap[l] = M,
                          n.directionalShadowMatrix[l] = y.shadow.matrix,
                          p++
                      }
                      n.directional[l] = e,
                      l++
                  } else if (y.isSpotLight) {
                      const e = t.get(y);
                      e.position.setFromMatrixPosition(y.matrixWorld),
                      e.color.copy(x).multiplyScalar(S),
                      e.distance = E,
                      e.coneCos = Math.cos(y.angle),
                      e.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)),
                      e.decay = y.decay,
                      n.spot[u] = e;
                      const r = y.shadow;
                      if (y.map && (n.spotLightMap[g] = y.map,
                      g++,
                      r.updateMatrices(y),
                      y.castShadow && v++),
                      n.spotLightMatrix[u] = r.matrix,
                      y.castShadow) {
                          const e = i.get(y);
                          e.shadowIntensity = r.intensity,
                          e.shadowBias = r.bias,
                          e.shadowNormalBias = r.normalBias,
                          e.shadowRadius = r.radius,
                          e.shadowMapSize = r.mapSize,
                          n.spotShadow[u] = e,
                          n.spotShadowMap[u] = M,
                          m++
                      }
                      u++
                  } else if (y.isRectAreaLight) {
                      const e = t.get(y);
                      e.color.copy(x).multiplyScalar(S),
                      e.halfWidth.set(.5 * y.width, 0, 0),
                      e.halfHeight.set(0, .5 * y.height, 0),
                      n.rectArea[h] = e,
                      h++
                  } else if (y.isPointLight) {
                      const e = t.get(y);
                      if (e.color.copy(y.color).multiplyScalar(y.intensity),
                      e.distance = y.distance,
                      e.decay = y.decay,
                      y.castShadow) {
                          const e = y.shadow
                            , t = i.get(y);
                          t.shadowIntensity = e.intensity,
                          t.shadowBias = e.bias,
                          t.shadowNormalBias = e.normalBias,
                          t.shadowRadius = e.radius,
                          t.shadowMapSize = e.mapSize,
                          t.shadowCameraNear = e.camera.near,
                          t.shadowCameraFar = e.camera.far,
                          n.pointShadow[c] = t,
                          n.pointShadowMap[c] = M,
                          n.pointShadowMatrix[c] = y.shadow.matrix,
                          f++
                      }
                      n.point[c] = e,
                      c++
                  } else if (y.isHemisphereLight) {
                      const e = t.get(y);
                      e.skyColor.copy(y.color).multiplyScalar(S),
                      e.groundColor.copy(y.groundColor).multiplyScalar(S),
                      n.hemi[d] = e,
                      d++
                  }
              }
              h > 0 && (!0 === e.has("OES_texture_float_linear") ? (n.rectAreaLTC1 = im.LTC_FLOAT_1,
              n.rectAreaLTC2 = im.LTC_FLOAT_2) : (n.rectAreaLTC1 = im.LTC_HALF_1,
              n.rectAreaLTC2 = im.LTC_HALF_2)),
              n.ambient[0] = s,
              n.ambient[1] = a,
              n.ambient[2] = o;
              const y = n.hash;
              y.directionalLength === l && y.pointLength === c && y.spotLength === u && y.rectAreaLength === h && y.hemiLength === d && y.numDirectionalShadows === p && y.numPointShadows === f && y.numSpotShadows === m && y.numSpotMaps === g && y.numLightProbes === _ || (n.directional.length = l,
              n.spot.length = u,
              n.rectArea.length = h,
              n.point.length = c,
              n.hemi.length = d,
              n.directionalShadow.length = p,
              n.directionalShadowMap.length = p,
              n.pointShadow.length = f,
              n.pointShadowMap.length = f,
              n.spotShadow.length = m,
              n.spotShadowMap.length = m,
              n.directionalShadowMatrix.length = p,
              n.pointShadowMatrix.length = f,
              n.spotLightMatrix.length = m + g - v,
              n.spotLightMap.length = g,
              n.numSpotLightShadowsWithMaps = v,
              n.numLightProbes = _,
              y.directionalLength = l,
              y.pointLength = c,
              y.spotLength = u,
              y.rectAreaLength = h,
              y.hemiLength = d,
              y.numDirectionalShadows = p,
              y.numPointShadows = f,
              y.numSpotShadows = m,
              y.numSpotMaps = g,
              y.numLightProbes = _,
              n.version = vv++)
          },
          setupView: function(e, t) {
              let i = 0
                , o = 0
                , l = 0
                , c = 0
                , u = 0;
              const h = t.matrixWorldInverse;
              for (let t = 0, d = e.length; t < d; t++) {
                  const d = e[t];
                  if (d.isDirectionalLight) {
                      const e = n.directional[i];
                      e.direction.setFromMatrixPosition(d.matrixWorld),
                      r.setFromMatrixPosition(d.target.matrixWorld),
                      e.direction.sub(r),
                      e.direction.transformDirection(h),
                      i++
                  } else if (d.isSpotLight) {
                      const e = n.spot[l];
                      e.position.setFromMatrixPosition(d.matrixWorld),
                      e.position.applyMatrix4(h),
                      e.direction.setFromMatrixPosition(d.matrixWorld),
                      r.setFromMatrixPosition(d.target.matrixWorld),
                      e.direction.sub(r),
                      e.direction.transformDirection(h),
                      l++
                  } else if (d.isRectAreaLight) {
                      const e = n.rectArea[c];
                      e.position.setFromMatrixPosition(d.matrixWorld),
                      e.position.applyMatrix4(h),
                      a.identity(),
                      s.copy(d.matrixWorld),
                      s.premultiply(h),
                      a.extractRotation(s),
                      e.halfWidth.set(.5 * d.width, 0, 0),
                      e.halfHeight.set(0, .5 * d.height, 0),
                      e.halfWidth.applyMatrix4(a),
                      e.halfHeight.applyMatrix4(a),
                      c++
                  } else if (d.isPointLight) {
                      const e = n.point[o];
                      e.position.setFromMatrixPosition(d.matrixWorld),
                      e.position.applyMatrix4(h),
                      o++
                  } else if (d.isHemisphereLight) {
                      const e = n.hemi[u];
                      e.direction.setFromMatrixPosition(d.matrixWorld),
                      e.direction.transformDirection(h),
                      u++
                  }
              }
          },
          state: n
      }
  }
  function xv(e) {
      const t = new yv(e)
        , i = []
        , n = []
        , r = {
          lightsArray: i,
          shadowsArray: n,
          camera: null,
          lights: t,
          transmissionRenderTarget: {}
      };
      return {
          init: function(e) {
              r.camera = e,
              i.length = 0,
              n.length = 0
          },
          state: r,
          setupLights: function() {
              t.setup(i)
          },
          setupLightsView: function(e) {
              t.setupView(i, e)
          },
          pushLight: function(e) {
              i.push(e)
          },
          pushShadow: function(e) {
              n.push(e)
          }
      }
  }
  function Sv(e) {
      let t = new WeakMap;
      return {
          get: function(i, n=0) {
              const r = t.get(i);
              let s;
              return void 0 === r ? (s = new xv(e),
              t.set(i, [s])) : n >= r.length ? (s = new xv(e),
              r.push(s)) : s = r[n],
              s
          },
          dispose: function() {
              t = new WeakMap
          }
      }
  }
  class Ev extends Yp {
      constructor(e) {
          super(),
          this.isMeshDepthMaterial = !0,
          this.type = "MeshDepthMaterial",
          this.depthPacking = 3200,
          this.map = null,
          this.alphaMap = null,
          this.displacementMap = null,
          this.displacementScale = 1,
          this.displacementBias = 0,
          this.wireframe = !1,
          this.wireframeLinewidth = 1,
          this.setValues(e)
      }
      copy(e) {
          return super.copy(e),
          this.depthPacking = e.depthPacking,
          this.map = e.map,
          this.alphaMap = e.alphaMap,
          this.displacementMap = e.displacementMap,
          this.displacementScale = e.displacementScale,
          this.displacementBias = e.displacementBias,
          this.wireframe = e.wireframe,
          this.wireframeLinewidth = e.wireframeLinewidth,
          this
      }
  }
  class Mv extends Yp {
      constructor(e) {
          super(),
          this.isMeshDistanceMaterial = !0,
          this.type = "MeshDistanceMaterial",
          this.map = null,
          this.alphaMap = null,
          this.displacementMap = null,
          this.displacementScale = 1,
          this.displacementBias = 0,
          this.setValues(e)
      }
      copy(e) {
          return super.copy(e),
          this.map = e.map,
          this.alphaMap = e.alphaMap,
          this.displacementMap = e.displacementMap,
          this.displacementScale = e.displacementScale,
          this.displacementBias = e.displacementBias,
          this
      }
  }
  function bv(e, t, i) {
      let n = new $f;
      const r = new Jh
        , s = new Jh
        , a = new xd
        , o = new Ev({
          depthPacking: 3201
      })
        , l = new Mv
        , c = {}
        , u = i.maxTextureSize
        , h = {
          0: 1,
          1: 0,
          2: 2
      }
        , d = new Ff({
          defines: {
              VSM_SAMPLES: 8
          },
          uniforms: {
              shadow_pass: {
                  value: null
              },
              resolution: {
                  value: new Jh
              },
              radius: {
                  value: 4
              }
          },
          vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
          fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
      })
        , p = d.clone();
      p.defines.HORIZONTAL_PASS = 1;
      const f = new uf;
      f.setAttribute("position", new Jp(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
      const m = new Cf(f,d)
        , g = this;
      this.enabled = !1,
      this.autoUpdate = !0,
      this.needsUpdate = !1,
      this.type = Qc;
      let v = this.type;
      function _(i, n) {
          const s = t.update(m);
          d.defines.VSM_SAMPLES !== i.blurSamples && (d.defines.VSM_SAMPLES = i.blurSamples,
          p.defines.VSM_SAMPLES = i.blurSamples,
          d.needsUpdate = !0,
          p.needsUpdate = !0),
          null === i.mapPass && (i.mapPass = new Ed(r.x,r.y)),
          d.uniforms.shadow_pass.value = i.map.texture,
          d.uniforms.resolution.value = i.mapSize,
          d.uniforms.radius.value = i.radius,
          e.setRenderTarget(i.mapPass),
          e.clear(),
          e.renderBufferDirect(n, null, s, d, m, null),
          p.uniforms.shadow_pass.value = i.mapPass.texture,
          p.uniforms.resolution.value = i.mapSize,
          p.uniforms.radius.value = i.radius,
          e.setRenderTarget(i.map),
          e.clear(),
          e.renderBufferDirect(n, null, s, p, m, null)
      }
      function y(t, i, n, r) {
          let s = null;
          const a = !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
          if (void 0 !== a)
              s = a;
          else if (s = !0 === n.isPointLight ? l : o,
          e.localClippingEnabled && !0 === i.clipShadows && Array.isArray(i.clippingPlanes) && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0 || i.map && i.alphaTest > 0) {
              const e = s.uuid
                , t = i.uuid;
              let n = c[e];
              void 0 === n && (n = {},
              c[e] = n);
              let r = n[t];
              void 0 === r && (r = s.clone(),
              n[t] = r,
              i.addEventListener("dispose", S)),
              s = r
          }
          return s.visible = i.visible,
          s.wireframe = i.wireframe,
          s.side = r === tu ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : h[i.side],
          s.alphaMap = i.alphaMap,
          s.alphaTest = i.alphaTest,
          s.map = i.map,
          s.clipShadows = i.clipShadows,
          s.clippingPlanes = i.clippingPlanes,
          s.clipIntersection = i.clipIntersection,
          s.displacementMap = i.displacementMap,
          s.displacementScale = i.displacementScale,
          s.displacementBias = i.displacementBias,
          s.wireframeLinewidth = i.wireframeLinewidth,
          s.linewidth = i.linewidth,
          !0 === n.isPointLight && !0 === s.isMeshDistanceMaterial && (e.properties.get(s).light = n),
          s
      }
      function x(i, r, s, a, o) {
          if (!1 === i.visible)
              return;
          if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && o === tu) && (!i.frustumCulled || n.intersectsObject(i))) {
              i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
              const n = t.update(i)
                , l = i.material;
              if (Array.isArray(l)) {
                  const t = n.groups;
                  for (let c = 0, u = t.length; c < u; c++) {
                      const u = t[c]
                        , h = l[u.materialIndex];
                      if (h && h.visible) {
                          const t = y(i, h, a, o);
                          i.onBeforeShadow(e, i, r, s, n, t, u),
                          e.renderBufferDirect(s, null, n, t, i, u),
                          i.onAfterShadow(e, i, r, s, n, t, u)
                      }
                  }
              } else if (l.visible) {
                  const t = y(i, l, a, o);
                  i.onBeforeShadow(e, i, r, s, n, t, null),
                  e.renderBufferDirect(s, null, n, t, i, null),
                  i.onAfterShadow(e, i, r, s, n, t, null)
              }
          }
          const l = i.children;
          for (let e = 0, t = l.length; e < t; e++)
              x(l[e], r, s, a, o)
      }
      function S(e) {
          e.target.removeEventListener("dispose", S);
          for (const t in c) {
              const i = c[t]
                , n = e.target.uuid;
              n in i && (i[n].dispose(),
              delete i[n])
          }
      }
      this.render = function(t, i, o) {
          if (!1 === g.enabled)
              return;
          if (!1 === g.autoUpdate && !1 === g.needsUpdate)
              return;
          if (0 === t.length)
              return;
          const l = e.getRenderTarget()
            , c = e.getActiveCubeFace()
            , h = e.getActiveMipmapLevel()
            , d = e.state;
          d.setBlending(0),
          d.buffers.color.setClear(1, 1, 1, 1),
          d.buffers.depth.setTest(!0),
          d.setScissorTest(!1);
          const p = v !== tu && this.type === tu
            , f = v === tu && this.type !== tu;
          for (let l = 0, c = t.length; l < c; l++) {
              const c = t[l]
                , h = c.shadow;
              if (void 0 === h) {
                  console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                  continue
              }
              if (!1 === h.autoUpdate && !1 === h.needsUpdate)
                  continue;
              r.copy(h.mapSize);
              const m = h.getFrameExtents();
              if (r.multiply(m),
              s.copy(h.mapSize),
              (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / m.x),
              r.x = s.x * m.x,
              h.mapSize.x = s.x),
              r.y > u && (s.y = Math.floor(u / m.y),
              r.y = s.y * m.y,
              h.mapSize.y = s.y)),
              null === h.map || !0 === p || !0 === f) {
                  const e = this.type !== tu ? {
                      minFilter: xu,
                      magFilter: xu
                  } : {};
                  null !== h.map && h.map.dispose(),
                  h.map = new Ed(r.x,r.y,e),
                  h.map.texture.name = c.name + ".shadowMap",
                  h.camera.updateProjectionMatrix()
              }
              e.setRenderTarget(h.map),
              e.clear();
              const g = h.getViewportCount();
              for (let e = 0; e < g; e++) {
                  const t = h.getViewport(e);
                  a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
                  d.viewport(a),
                  h.updateMatrices(c, e),
                  n = h.getFrustum(),
                  x(i, o, h.camera, c, this.type)
              }
              !0 !== h.isPointLightShadow && this.type === tu && _(h, o),
              h.needsUpdate = !1
          }
          v = this.type,
          g.needsUpdate = !1,
          e.setRenderTarget(l, c, h)
      }
  }
  function Tv(e) {
      const t = new function() {
          let t = !1;
          const i = new xd;
          let n = null;
          const r = new xd(0,0,0,0);
          return {
              setMask: function(i) {
                  n === i || t || (e.colorMask(i, i, i, i),
                  n = i)
              },
              setLocked: function(e) {
                  t = e
              },
              setClear: function(t, n, s, a, o) {
                  !0 === o && (t *= a,
                  n *= a,
                  s *= a),
                  i.set(t, n, s, a),
                  !1 === r.equals(i) && (e.clearColor(t, n, s, a),
                  r.copy(i))
              },
              reset: function() {
                  t = !1,
                  n = null,
                  r.set(-1, 0, 0, 0)
              }
          }
      }
        , i = new function() {
          let t = !1
            , i = null
            , n = null
            , r = null;
          return {
              setTest: function(t) {
                  t ? z(e.DEPTH_TEST) : k(e.DEPTH_TEST)
              },
              setMask: function(n) {
                  i === n || t || (e.depthMask(n),
                  i = n)
              },
              setFunc: function(t) {
                  if (n !== t) {
                      switch (t) {
                      case 0:
                          e.depthFunc(e.NEVER);
                          break;
                      case 1:
                          e.depthFunc(e.ALWAYS);
                          break;
                      case 2:
                          e.depthFunc(e.LESS);
                          break;
                      case 3:
                      default:
                          e.depthFunc(e.LEQUAL);
                          break;
                      case 4:
                          e.depthFunc(e.EQUAL);
                          break;
                      case 5:
                          e.depthFunc(e.GEQUAL);
                          break;
                      case 6:
                          e.depthFunc(e.GREATER);
                          break;
                      case 7:
                          e.depthFunc(e.NOTEQUAL)
                      }
                      n = t
                  }
              },
              setLocked: function(e) {
                  t = e
              },
              setClear: function(t) {
                  r !== t && (e.clearDepth(t),
                  r = t)
              },
              reset: function() {
                  t = !1,
                  i = null,
                  n = null,
                  r = null
              }
          }
      }
        , n = new function() {
          let t = !1
            , i = null
            , n = null
            , r = null
            , s = null
            , a = null
            , o = null
            , l = null
            , c = null;
          return {
              setTest: function(i) {
                  t || (i ? z(e.STENCIL_TEST) : k(e.STENCIL_TEST))
              },
              setMask: function(n) {
                  i === n || t || (e.stencilMask(n),
                  i = n)
              },
              setFunc: function(t, i, a) {
                  n === t && r === i && s === a || (e.stencilFunc(t, i, a),
                  n = t,
                  r = i,
                  s = a)
              },
              setOp: function(t, i, n) {
                  a === t && o === i && l === n || (e.stencilOp(t, i, n),
                  a = t,
                  o = i,
                  l = n)
              },
              setLocked: function(e) {
                  t = e
              },
              setClear: function(t) {
                  c !== t && (e.clearStencil(t),
                  c = t)
              },
              reset: function() {
                  t = !1,
                  i = null,
                  n = null,
                  r = null,
                  s = null,
                  a = null,
                  o = null,
                  l = null,
                  c = null
              }
          }
      }
        , r = new WeakMap
        , s = new WeakMap;
      let a = {}
        , o = {}
        , l = new WeakMap
        , c = []
        , u = null
        , h = !1
        , d = null
        , p = null
        , f = null
        , m = null
        , g = null
        , v = null
        , _ = null
        , y = new Xp(0,0,0)
        , x = 0
        , S = !1
        , E = null
        , M = null
        , b = null
        , T = null
        , w = null;
      const D = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      let C = !1
        , A = 0;
      const P = e.getParameter(e.VERSION);
      -1 !== P.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(P)[1]),
      C = A >= 1) : -1 !== P.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),
      C = A >= 2);
      let R = null
        , L = {};
      const I = e.getParameter(e.SCISSOR_BOX)
        , N = e.getParameter(e.VIEWPORT)
        , F = (new xd).fromArray(I)
        , O = (new xd).fromArray(N);
      function U(t, i, n, r) {
          const s = new Uint8Array(4)
            , a = e.createTexture();
          e.bindTexture(t, a),
          e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
          e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
          for (let a = 0; a < n; a++)
              t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(i, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, s) : e.texImage2D(i + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s);
          return a
      }
      const B = {};
      function z(t) {
          !0 !== a[t] && (e.enable(t),
          a[t] = !0)
      }
      function k(t) {
          !1 !== a[t] && (e.disable(t),
          a[t] = !1)
      }
      B[e.TEXTURE_2D] = U(e.TEXTURE_2D, e.TEXTURE_2D, 1),
      B[e.TEXTURE_CUBE_MAP] = U(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
      B[e.TEXTURE_2D_ARRAY] = U(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
      B[e.TEXTURE_3D] = U(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
      t.setClear(0, 0, 0, 1),
      i.setClear(1),
      n.setClear(0),
      z(e.DEPTH_TEST),
      i.setFunc(3),
      W(!1),
      X(1),
      z(e.CULL_FACE),
      G(0);
      const V = {
          [iu]: e.FUNC_ADD,
          101: e.FUNC_SUBTRACT,
          102: e.FUNC_REVERSE_SUBTRACT
      };
      V[103] = e.MIN,
      V[104] = e.MAX;
      const H = {
          200: e.ZERO,
          201: e.ONE,
          202: e.SRC_COLOR,
          204: e.SRC_ALPHA,
          210: e.SRC_ALPHA_SATURATE,
          208: e.DST_COLOR,
          206: e.DST_ALPHA,
          203: e.ONE_MINUS_SRC_COLOR,
          205: e.ONE_MINUS_SRC_ALPHA,
          209: e.ONE_MINUS_DST_COLOR,
          207: e.ONE_MINUS_DST_ALPHA,
          211: e.CONSTANT_COLOR,
          212: e.ONE_MINUS_CONSTANT_COLOR,
          213: e.CONSTANT_ALPHA,
          214: e.ONE_MINUS_CONSTANT_ALPHA
      };
      function G(t, i, n, r, s, a, o, l, c, u) {
          if (0 !== t) {
              if (!1 === h && (z(e.BLEND),
              h = !0),
              5 === t)
                  s = s || i,
                  a = a || n,
                  o = o || r,
                  i === p && s === g || (e.blendEquationSeparate(V[i], V[s]),
                  p = i,
                  g = s),
                  n === f && r === m && a === v && o === _ || (e.blendFuncSeparate(H[n], H[r], H[a], H[o]),
                  f = n,
                  m = r,
                  v = a,
                  _ = o),
                  !1 !== l.equals(y) && c === x || (e.blendColor(l.r, l.g, l.b, c),
                  y.copy(l),
                  x = c),
                  d = t,
                  S = !1;
              else if (t !== d || u !== S) {
                  if (p === iu && g === iu || (e.blendEquation(e.FUNC_ADD),
                  p = iu,
                  g = iu),
                  u)
                      switch (t) {
                      case 1:
                          e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                          break;
                      case 2:
                          e.blendFunc(e.ONE, e.ONE);
                          break;
                      case 3:
                          e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                          break;
                      case 4:
                          e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                          break;
                      default:
                          console.error("THREE.WebGLState: Invalid blending: ", t)
                      }
                  else
                      switch (t) {
                      case 1:
                          e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                          break;
                      case 2:
                          e.blendFunc(e.SRC_ALPHA, e.ONE);
                          break;
                      case 3:
                          e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                          break;
                      case 4:
                          e.blendFunc(e.ZERO, e.SRC_COLOR);
                          break;
                      default:
                          console.error("THREE.WebGLState: Invalid blending: ", t)
                      }
                  f = null,
                  m = null,
                  v = null,
                  _ = null,
                  y.set(0, 0, 0),
                  x = 0,
                  d = t,
                  S = u
              }
          } else
              !0 === h && (k(e.BLEND),
              h = !1)
      }
      function W(t) {
          E !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW),
          E = t)
      }
      function X(t) {
          0 !== t ? (z(e.CULL_FACE),
          t !== M && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : k(e.CULL_FACE),
          M = t
      }
      function q(t, i, n) {
          t ? (z(e.POLYGON_OFFSET_FILL),
          T === i && w === n || (e.polygonOffset(i, n),
          T = i,
          w = n)) : k(e.POLYGON_OFFSET_FILL)
      }
      return {
          buffers: {
              color: t,
              depth: i,
              stencil: n
          },
          enable: z,
          disable: k,
          bindFramebuffer: function(t, i) {
              return o[t] !== i && (e.bindFramebuffer(t, i),
              o[t] = i,
              t === e.DRAW_FRAMEBUFFER && (o[e.FRAMEBUFFER] = i),
              t === e.FRAMEBUFFER && (o[e.DRAW_FRAMEBUFFER] = i),
              !0)
          },
          drawBuffers: function(t, i) {
              let n = c
                , r = !1;
              if (t) {
                  n = l.get(i),
                  void 0 === n && (n = [],
                  l.set(i, n));
                  const s = t.textures;
                  if (n.length !== s.length || n[0] !== e.COLOR_ATTACHMENT0) {
                      for (let t = 0, i = s.length; t < i; t++)
                          n[t] = e.COLOR_ATTACHMENT0 + t;
                      n.length = s.length,
                      r = !0
                  }
              } else
                  n[0] !== e.BACK && (n[0] = e.BACK,
                  r = !0);
              r && e.drawBuffers(n)
          },
          useProgram: function(t) {
              return u !== t && (e.useProgram(t),
              u = t,
              !0)
          },
          setBlending: G,
          setMaterial: function(r, s) {
              2 === r.side ? k(e.CULL_FACE) : z(e.CULL_FACE);
              let a = 1 === r.side;
              s && (a = !a),
              W(a),
              1 === r.blending && !1 === r.transparent ? G(0) : G(r.blending, r.blendEquation, r.blendSrc, r.blendDst, r.blendEquationAlpha, r.blendSrcAlpha, r.blendDstAlpha, r.blendColor, r.blendAlpha, r.premultipliedAlpha),
              i.setFunc(r.depthFunc),
              i.setTest(r.depthTest),
              i.setMask(r.depthWrite),
              t.setMask(r.colorWrite);
              const o = r.stencilWrite;
              n.setTest(o),
              o && (n.setMask(r.stencilWriteMask),
              n.setFunc(r.stencilFunc, r.stencilRef, r.stencilFuncMask),
              n.setOp(r.stencilFail, r.stencilZFail, r.stencilZPass)),
              q(r.polygonOffset, r.polygonOffsetFactor, r.polygonOffsetUnits),
              !0 === r.alphaToCoverage ? z(e.SAMPLE_ALPHA_TO_COVERAGE) : k(e.SAMPLE_ALPHA_TO_COVERAGE)
          },
          setFlipSided: W,
          setCullFace: X,
          setLineWidth: function(t) {
              t !== b && (C && e.lineWidth(t),
              b = t)
          },
          setPolygonOffset: q,
          setScissorTest: function(t) {
              t ? z(e.SCISSOR_TEST) : k(e.SCISSOR_TEST)
          },
          activeTexture: function(t) {
              void 0 === t && (t = e.TEXTURE0 + D - 1),
              R !== t && (e.activeTexture(t),
              R = t)
          },
          bindTexture: function(t, i, n) {
              void 0 === n && (n = null === R ? e.TEXTURE0 + D - 1 : R);
              let r = L[n];
              void 0 === r && (r = {
                  type: void 0,
                  texture: void 0
              },
              L[n] = r),
              r.type === t && r.texture === i || (R !== n && (e.activeTexture(n),
              R = n),
              e.bindTexture(t, i || B[t]),
              r.type = t,
              r.texture = i)
          },
          unbindTexture: function() {
              const t = L[R];
              void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
              t.type = void 0,
              t.texture = void 0)
          },
          compressedTexImage2D: function() {
              try {
                  e.compressedTexImage2D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          compressedTexImage3D: function() {
              try {
                  e.compressedTexImage3D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          texImage2D: function() {
              try {
                  e.texImage2D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          texImage3D: function() {
              try {
                  e.texImage3D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          updateUBOMapping: function(t, i) {
              let n = s.get(i);
              void 0 === n && (n = new WeakMap,
              s.set(i, n));
              let r = n.get(t);
              void 0 === r && (r = e.getUniformBlockIndex(i, t.name),
              n.set(t, r))
          },
          uniformBlockBinding: function(t, i) {
              const n = s.get(i).get(t);
              r.get(i) !== n && (e.uniformBlockBinding(i, n, t.__bindingPointIndex),
              r.set(i, n))
          },
          texStorage2D: function() {
              try {
                  e.texStorage2D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          texStorage3D: function() {
              try {
                  e.texStorage3D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          texSubImage2D: function() {
              try {
                  e.texSubImage2D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          texSubImage3D: function() {
              try {
                  e.texSubImage3D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          compressedTexSubImage2D: function() {
              try {
                  e.compressedTexSubImage2D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          compressedTexSubImage3D: function() {
              try {
                  e.compressedTexSubImage3D.apply(e, arguments)
              } catch (e) {
                  console.error("THREE.WebGLState:", e)
              }
          },
          scissor: function(t) {
              !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
              F.copy(t))
          },
          viewport: function(t) {
              !1 === O.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
              O.copy(t))
          },
          reset: function() {
              e.disable(e.BLEND),
              e.disable(e.CULL_FACE),
              e.disable(e.DEPTH_TEST),
              e.disable(e.POLYGON_OFFSET_FILL),
              e.disable(e.SCISSOR_TEST),
              e.disable(e.STENCIL_TEST),
              e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
              e.blendEquation(e.FUNC_ADD),
              e.blendFunc(e.ONE, e.ZERO),
              e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
              e.blendColor(0, 0, 0, 0),
              e.colorMask(!0, !0, !0, !0),
              e.clearColor(0, 0, 0, 0),
              e.depthMask(!0),
              e.depthFunc(e.LESS),
              e.clearDepth(1),
              e.stencilMask(4294967295),
              e.stencilFunc(e.ALWAYS, 0, 4294967295),
              e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
              e.clearStencil(0),
              e.cullFace(e.BACK),
              e.frontFace(e.CCW),
              e.polygonOffset(0, 0),
              e.activeTexture(e.TEXTURE0),
              e.bindFramebuffer(e.FRAMEBUFFER, null),
              e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
              e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
              e.useProgram(null),
              e.lineWidth(1),
              e.scissor(0, 0, e.canvas.width, e.canvas.height),
              e.viewport(0, 0, e.canvas.width, e.canvas.height),
              a = {},
              R = null,
              L = {},
              o = {},
              l = new WeakMap,
              c = [],
              u = null,
              h = !1,
              d = null,
              p = null,
              f = null,
              m = null,
              g = null,
              v = null,
              _ = null,
              y = new Xp(0,0,0),
              x = 0,
              S = !1,
              E = null,
              M = null,
              b = null,
              T = null,
              w = null,
              F.set(0, 0, e.canvas.width, e.canvas.height),
              O.set(0, 0, e.canvas.width, e.canvas.height),
              t.reset(),
              i.reset(),
              n.reset()
          }
      }
  }
  function wv(e, t, i, n) {
      const r = function(e) {
          switch (e) {
          case Tu:
          case wu:
              return {
                  byteLength: 1,
                  components: 1
              };
          case Cu:
          case Du:
          case Lu:
              return {
                  byteLength: 2,
                  components: 1
              };
          case Iu:
          case Nu:
              return {
                  byteLength: 2,
                  components: 4
              };
          case Pu:
          case Au:
          case Ru:
              return {
                  byteLength: 4,
                  components: 1
              };
          case Ou:
              return {
                  byteLength: 4,
                  components: 3
              }
          }
          throw new Error(`Unknown texture type ${e}.`)
      }(n);
      switch (i) {
      case Uu:
      case ku:
          return e * t;
      case Vu:
          return e * t * 2;
      case Wu:
      case Xu:
          return e * t / r.components * r.byteLength;
      case qu:
      case ju:
          return e * t * 2 / r.components * r.byteLength;
      case Bu:
          return e * t * 3 / r.components * r.byteLength;
      case zu:
      case Yu:
          return e * t * 4 / r.components * r.byteLength;
      case Ku:
      case Zu:
          return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
      case $u:
      case Ju:
          return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
      case eh:
      case ih:
          return Math.max(e, 16) * Math.max(t, 8) / 4;
      case Qu:
      case th:
          return Math.max(e, 8) * Math.max(t, 8) / 2;
      case nh:
      case rh:
          return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
      case sh:
      case ah:
          return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
      case oh:
          return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
      case lh:
          return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
      case ch:
          return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
      case uh:
          return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
      case hh:
          return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
      case dh:
          return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
      case ph:
          return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
      case fh:
          return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
      case mh:
          return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
      case gh:
          return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
      case vh:
          return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
      case _h:
          return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
      case yh:
          return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
      case xh:
      case Sh:
      case Eh:
          return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
      case Mh:
      case bh:
          return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
      case Th:
      case wh:
          return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
      }
      throw new Error(`Unable to determine texture byte length for ${i} format.`)
  }
  function Dv(e, t, i, n, r, s, a) {
      const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
        , l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
        , c = new Jh
        , u = new WeakMap;
      let h;
      const d = new WeakMap;
      let p = !1;
      try {
          p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
      } catch (e) {}
      function f(e, t) {
          return p ? new OffscreenCanvas(e,t) : id("canvas")
      }
      function m(e, t, i) {
          let n = 1;
          const r = k(e);
          if ((r.width > i || r.height > i) && (n = i / Math.max(r.width, r.height)),
          n < 1) {
              if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                  const i = Math.floor(n * r.width)
                    , s = Math.floor(n * r.height);
                  void 0 === h && (h = f(i, s));
                  const a = t ? f(i, s) : h;
                  return a.width = i,
                  a.height = s,
                  a.getContext("2d").drawImage(e, 0, 0, i, s),
                  console.warn("THREE.WebGLRenderer: Texture has been resized from (" + r.width + "x" + r.height + ") to (" + i + "x" + s + ")."),
                  a
              }
              return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + r.width + "x" + r.height + ")."),
              e
          }
          return e
      }
      function g(e) {
          return e.generateMipmaps && e.minFilter !== xu && e.minFilter !== Eu
      }
      function v(t) {
          e.generateMipmap(t)
      }
      function _(i, n, r, s, a=!1) {
          if (null !== i) {
              if (void 0 !== e[i])
                  return e[i];
              console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
          }
          let o = n;
          if (n === e.RED && (r === e.FLOAT && (o = e.R32F),
          r === e.HALF_FLOAT && (o = e.R16F),
          r === e.UNSIGNED_BYTE && (o = e.R8)),
          n === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.R8UI),
          r === e.UNSIGNED_SHORT && (o = e.R16UI),
          r === e.UNSIGNED_INT && (o = e.R32UI),
          r === e.BYTE && (o = e.R8I),
          r === e.SHORT && (o = e.R16I),
          r === e.INT && (o = e.R32I)),
          n === e.RG && (r === e.FLOAT && (o = e.RG32F),
          r === e.HALF_FLOAT && (o = e.RG16F),
          r === e.UNSIGNED_BYTE && (o = e.RG8)),
          n === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RG8UI),
          r === e.UNSIGNED_SHORT && (o = e.RG16UI),
          r === e.UNSIGNED_INT && (o = e.RG32UI),
          r === e.BYTE && (o = e.RG8I),
          r === e.SHORT && (o = e.RG16I),
          r === e.INT && (o = e.RG32I)),
          n === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5),
          n === e.RGBA) {
              const t = a ? Fh : ud.getTransfer(s);
              r === e.FLOAT && (o = e.RGBA32F),
              r === e.HALF_FLOAT && (o = e.RGBA16F),
              r === e.UNSIGNED_BYTE && (o = t === Oh ? e.SRGB8_ALPHA8 : e.RGBA8),
              r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4),
              r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1)
          }
          return o !== e.R16F && o !== e.R32F && o !== e.RG16F && o !== e.RG32F && o !== e.RGBA16F && o !== e.RGBA32F || t.get("EXT_color_buffer_float"),
          o
      }
      function y(t, i) {
          let n;
          return t ? null === i || i === Pu || i === Fu ? n = e.DEPTH24_STENCIL8 : i === Ru ? n = e.DEPTH32F_STENCIL8 : i === Cu && (n = e.DEPTH24_STENCIL8,
          console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === i || i === Pu || i === Fu ? n = e.DEPTH_COMPONENT24 : i === Ru ? n = e.DEPTH_COMPONENT32F : i === Cu && (n = e.DEPTH_COMPONENT16),
          n
      }
      function x(e, t) {
          return !0 === g(e) || e.isFramebufferTexture && e.minFilter !== xu && e.minFilter !== Eu ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
      }
      function S(e) {
          const t = e.target;
          t.removeEventListener("dispose", S),
          function(e) {
              const t = n.get(e);
              if (void 0 === t.__webglInit)
                  return;
              const i = e.source
                , r = d.get(i);
              if (r) {
                  const n = r[t.__cacheKey];
                  n.usedTimes--,
                  0 === n.usedTimes && M(e),
                  0 === Object.keys(r).length && d.delete(i)
              }
              n.remove(e)
          }(t),
          t.isVideoTexture && u.delete(t)
      }
      function E(t) {
          const i = t.target;
          i.removeEventListener("dispose", E),
          function(t) {
              const i = n.get(t);
              if (t.depthTexture && t.depthTexture.dispose(),
              t.isWebGLCubeRenderTarget)
                  for (let t = 0; t < 6; t++) {
                      if (Array.isArray(i.__webglFramebuffer[t]))
                          for (let n = 0; n < i.__webglFramebuffer[t].length; n++)
                              e.deleteFramebuffer(i.__webglFramebuffer[t][n]);
                      else
                          e.deleteFramebuffer(i.__webglFramebuffer[t]);
                      i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[t])
                  }
              else {
                  if (Array.isArray(i.__webglFramebuffer))
                      for (let t = 0; t < i.__webglFramebuffer.length; t++)
                          e.deleteFramebuffer(i.__webglFramebuffer[t]);
                  else
                      e.deleteFramebuffer(i.__webglFramebuffer);
                  if (i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer),
                  i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                  i.__webglColorRenderbuffer)
                      for (let t = 0; t < i.__webglColorRenderbuffer.length; t++)
                          i.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);
                  i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer)
              }
              const r = t.textures;
              for (let t = 0, i = r.length; t < i; t++) {
                  const i = n.get(r[t]);
                  i.__webglTexture && (e.deleteTexture(i.__webglTexture),
                  a.memory.textures--),
                  n.remove(r[t])
              }
              n.remove(t)
          }(i)
      }
      function M(t) {
          const i = n.get(t);
          e.deleteTexture(i.__webglTexture);
          const r = t.source;
          delete d.get(r)[i.__cacheKey],
          a.memory.textures--
      }
      let b = 0;
      function T(t, r) {
          const s = n.get(t);
          if (t.isVideoTexture && function(e) {
              const t = a.render.frame;
              u.get(e) !== t && (u.set(e, t),
              e.update())
          }(t),
          !1 === t.isRenderTargetTexture && t.version > 0 && s.__version !== t.version) {
              const e = t.image;
              if (null === e)
                  console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
              else {
                  if (!1 !== e.complete)
                      return void R(s, t, r);
                  console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
              }
          }
          i.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + r)
      }
      const w = {
          [vu]: e.REPEAT,
          [_u]: e.CLAMP_TO_EDGE,
          [yu]: e.MIRRORED_REPEAT
      }
        , D = {
          [xu]: e.NEAREST,
          1004: e.NEAREST_MIPMAP_NEAREST,
          [Su]: e.NEAREST_MIPMAP_LINEAR,
          [Eu]: e.LINEAR,
          [Mu]: e.LINEAR_MIPMAP_NEAREST,
          [bu]: e.LINEAR_MIPMAP_LINEAR
      }
        , C = {
          512: e.NEVER,
          519: e.ALWAYS,
          513: e.LESS,
          515: e.LEQUAL,
          514: e.EQUAL,
          518: e.GEQUAL,
          516: e.GREATER,
          517: e.NOTEQUAL
      };
      function A(i, s) {
          if (s.type !== Ru || !1 !== t.has("OES_texture_float_linear") || s.magFilter !== Eu && s.magFilter !== Mu && s.magFilter !== Su && s.magFilter !== bu && s.minFilter !== Eu && s.minFilter !== Mu && s.minFilter !== Su && s.minFilter !== bu || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
          e.texParameteri(i, e.TEXTURE_WRAP_S, w[s.wrapS]),
          e.texParameteri(i, e.TEXTURE_WRAP_T, w[s.wrapT]),
          i !== e.TEXTURE_3D && i !== e.TEXTURE_2D_ARRAY || e.texParameteri(i, e.TEXTURE_WRAP_R, w[s.wrapR]),
          e.texParameteri(i, e.TEXTURE_MAG_FILTER, D[s.magFilter]),
          e.texParameteri(i, e.TEXTURE_MIN_FILTER, D[s.minFilter]),
          s.compareFunction && (e.texParameteri(i, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
          e.texParameteri(i, e.TEXTURE_COMPARE_FUNC, C[s.compareFunction])),
          !0 === t.has("EXT_texture_filter_anisotropic")) {
              if (s.magFilter === xu)
                  return;
              if (s.minFilter !== Su && s.minFilter !== bu)
                  return;
              if (s.type === Ru && !1 === t.has("OES_texture_float_linear"))
                  return;
              if (s.anisotropy > 1 || n.get(s).__currentAnisotropy) {
                  const a = t.get("EXT_texture_filter_anisotropic");
                  e.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                  n.get(s).__currentAnisotropy = s.anisotropy
              }
          }
      }
      function P(t, i) {
          let n = !1;
          void 0 === t.__webglInit && (t.__webglInit = !0,
          i.addEventListener("dispose", S));
          const r = i.source;
          let s = d.get(r);
          void 0 === s && (s = {},
          d.set(r, s));
          const o = function(e) {
              const t = [];
              return t.push(e.wrapS),
              t.push(e.wrapT),
              t.push(e.wrapR || 0),
              t.push(e.magFilter),
              t.push(e.minFilter),
              t.push(e.anisotropy),
              t.push(e.internalFormat),
              t.push(e.format),
              t.push(e.type),
              t.push(e.generateMipmaps),
              t.push(e.premultiplyAlpha),
              t.push(e.flipY),
              t.push(e.unpackAlignment),
              t.push(e.colorSpace),
              t.join()
          }(i);
          if (o !== t.__cacheKey) {
              void 0 === s[o] && (s[o] = {
                  texture: e.createTexture(),
                  usedTimes: 0
              },
              a.memory.textures++,
              n = !0),
              s[o].usedTimes++;
              const r = s[t.__cacheKey];
              void 0 !== r && (s[t.__cacheKey].usedTimes--,
              0 === r.usedTimes && M(i)),
              t.__cacheKey = o,
              t.__webglTexture = s[o].texture
          }
          return n
      }
      function R(t, a, o) {
          let l = e.TEXTURE_2D;
          (a.isDataArrayTexture || a.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY),
          a.isData3DTexture && (l = e.TEXTURE_3D);
          const c = P(t, a)
            , u = a.source;
          i.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o);
          const h = n.get(u);
          if (u.version !== h.__version || !0 === c) {
              i.activeTexture(e.TEXTURE0 + o);
              const t = ud.getPrimaries(ud.workingColorSpace)
                , n = a.colorSpace === Ph ? null : ud.getPrimaries(a.colorSpace)
                , d = a.colorSpace === Ph || t === n ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
              e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
              e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
              e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
              e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
              let p = m(a.image, !1, r.maxTextureSize);
              p = z(a, p);
              const f = s.convert(a.format, a.colorSpace)
                , S = s.convert(a.type);
              let E, M = _(a.internalFormat, f, S, a.colorSpace, a.isVideoTexture);
              A(l, a);
              const b = a.mipmaps
                , T = !0 !== a.isVideoTexture
                , w = void 0 === h.__version || !0 === c
                , D = u.dataReady
                , C = x(a, p);
              if (a.isDepthTexture)
                  M = y(a.format === Gu, a.type),
                  w && (T ? i.texStorage2D(e.TEXTURE_2D, 1, M, p.width, p.height) : i.texImage2D(e.TEXTURE_2D, 0, M, p.width, p.height, 0, f, S, null));
              else if (a.isDataTexture)
                  if (b.length > 0) {
                      T && w && i.texStorage2D(e.TEXTURE_2D, C, M, b[0].width, b[0].height);
                      for (let t = 0, n = b.length; t < n; t++)
                          E = b[t],
                          T ? D && i.texSubImage2D(e.TEXTURE_2D, t, 0, 0, E.width, E.height, f, S, E.data) : i.texImage2D(e.TEXTURE_2D, t, M, E.width, E.height, 0, f, S, E.data);
                      a.generateMipmaps = !1
                  } else
                      T ? (w && i.texStorage2D(e.TEXTURE_2D, C, M, p.width, p.height),
                      D && i.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p.width, p.height, f, S, p.data)) : i.texImage2D(e.TEXTURE_2D, 0, M, p.width, p.height, 0, f, S, p.data);
              else if (a.isCompressedTexture)
                  if (a.isCompressedArrayTexture) {
                      T && w && i.texStorage3D(e.TEXTURE_2D_ARRAY, C, M, b[0].width, b[0].height, p.depth);
                      for (let t = 0, n = b.length; t < n; t++)
                          if (E = b[t],
                          a.format !== zu)
                              if (null !== f)
                                  if (T) {
                                      if (D)
                                          if (a.layerUpdates.size > 0) {
                                              const n = wv(E.width, E.height, a.format, a.type);
                                              for (const r of a.layerUpdates) {
                                                  const s = E.data.subarray(r * n / E.data.BYTES_PER_ELEMENT, (r + 1) * n / E.data.BYTES_PER_ELEMENT);
                                                  i.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, r, E.width, E.height, 1, f, s, 0, 0)
                                              }
                                              a.clearLayerUpdates()
                                          } else
                                              i.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, E.width, E.height, p.depth, f, E.data, 0, 0)
                                  } else
                                      i.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, M, E.width, E.height, p.depth, 0, E.data, 0, 0);
                              else
                                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                          else
                              T ? D && i.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, E.width, E.height, p.depth, f, S, E.data) : i.texImage3D(e.TEXTURE_2D_ARRAY, t, M, E.width, E.height, p.depth, 0, f, S, E.data)
                  } else {
                      T && w && i.texStorage2D(e.TEXTURE_2D, C, M, b[0].width, b[0].height);
                      for (let t = 0, n = b.length; t < n; t++)
                          E = b[t],
                          a.format !== zu ? null !== f ? T ? D && i.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, E.width, E.height, f, E.data) : i.compressedTexImage2D(e.TEXTURE_2D, t, M, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : T ? D && i.texSubImage2D(e.TEXTURE_2D, t, 0, 0, E.width, E.height, f, S, E.data) : i.texImage2D(e.TEXTURE_2D, t, M, E.width, E.height, 0, f, S, E.data)
                  }
              else if (a.isDataArrayTexture)
                  if (T) {
                      if (w && i.texStorage3D(e.TEXTURE_2D_ARRAY, C, M, p.width, p.height, p.depth),
                      D)
                          if (a.layerUpdates.size > 0) {
                              const t = wv(p.width, p.height, a.format, a.type);
                              for (const n of a.layerUpdates) {
                                  const r = p.data.subarray(n * t / p.data.BYTES_PER_ELEMENT, (n + 1) * t / p.data.BYTES_PER_ELEMENT);
                                  i.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, n, p.width, p.height, 1, f, S, r)
                              }
                              a.clearLayerUpdates()
                          } else
                              i.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, f, S, p.data)
                  } else
                      i.texImage3D(e.TEXTURE_2D_ARRAY, 0, M, p.width, p.height, p.depth, 0, f, S, p.data);
              else if (a.isData3DTexture)
                  T ? (w && i.texStorage3D(e.TEXTURE_3D, C, M, p.width, p.height, p.depth),
                  D && i.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, f, S, p.data)) : i.texImage3D(e.TEXTURE_3D, 0, M, p.width, p.height, p.depth, 0, f, S, p.data);
              else if (a.isFramebufferTexture) {
                  if (w)
                      if (T)
                          i.texStorage2D(e.TEXTURE_2D, C, M, p.width, p.height);
                      else {
                          let t = p.width
                            , n = p.height;
                          for (let r = 0; r < C; r++)
                              i.texImage2D(e.TEXTURE_2D, r, M, t, n, 0, f, S, null),
                              t >>= 1,
                              n >>= 1
                      }
              } else if (b.length > 0) {
                  if (T && w) {
                      const t = k(b[0]);
                      i.texStorage2D(e.TEXTURE_2D, C, M, t.width, t.height)
                  }
                  for (let t = 0, n = b.length; t < n; t++)
                      E = b[t],
                      T ? D && i.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f, S, E) : i.texImage2D(e.TEXTURE_2D, t, M, f, S, E);
                  a.generateMipmaps = !1
              } else if (T) {
                  if (w) {
                      const t = k(p);
                      i.texStorage2D(e.TEXTURE_2D, C, M, t.width, t.height)
                  }
                  D && i.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f, S, p)
              } else
                  i.texImage2D(e.TEXTURE_2D, 0, M, f, S, p);
              g(a) && v(l),
              h.__version = u.version,
              a.onUpdate && a.onUpdate(a)
          }
          t.__version = a.version
      }
      function L(t, r, a, l, c, u) {
          const h = s.convert(a.format, a.colorSpace)
            , d = s.convert(a.type)
            , p = _(a.internalFormat, h, d, a.colorSpace);
          if (!n.get(r).__hasExternalTextures) {
              const t = Math.max(1, r.width >> u)
                , n = Math.max(1, r.height >> u);
              c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? i.texImage3D(c, u, p, t, n, r.depth, 0, h, d, null) : i.texImage2D(c, u, p, t, n, 0, h, d, null)
          }
          i.bindFramebuffer(e.FRAMEBUFFER, t),
          B(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, n.get(a).__webglTexture, 0, U(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, n.get(a).__webglTexture, u),
          i.bindFramebuffer(e.FRAMEBUFFER, null)
      }
      function I(t, i, n) {
          if (e.bindRenderbuffer(e.RENDERBUFFER, t),
          i.depthBuffer) {
              const r = i.depthTexture
                , s = r && r.isDepthTexture ? r.type : null
                , a = y(i.stencilBuffer, s)
                , l = i.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                , c = U(i);
              B(i) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, a, i.width, i.height) : n ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, a, i.width, i.height) : e.renderbufferStorage(e.RENDERBUFFER, a, i.width, i.height),
              e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t)
          } else {
              const t = i.textures;
              for (let r = 0; r < t.length; r++) {
                  const a = t[r]
                    , l = s.convert(a.format, a.colorSpace)
                    , c = s.convert(a.type)
                    , u = _(a.internalFormat, l, c, a.colorSpace)
                    , h = U(i);
                  n && !1 === B(i) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, h, u, i.width, i.height) : B(i) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, h, u, i.width, i.height) : e.renderbufferStorage(e.RENDERBUFFER, u, i.width, i.height)
              }
          }
          e.bindRenderbuffer(e.RENDERBUFFER, null)
      }
      function N(t) {
          const r = n.get(t)
            , s = !0 === t.isWebGLCubeRenderTarget;
          if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
              if (s)
                  throw new Error("target.depthTexture not supported in Cube render targets");
              !function(t, r) {
                  if (r && r.isWebGLCubeRenderTarget)
                      throw new Error("Depth Texture with cube render targets is not supported");
                  if (i.bindFramebuffer(e.FRAMEBUFFER, t),
                  !r.depthTexture || !r.depthTexture.isDepthTexture)
                      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                  n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                  r.depthTexture.image.height = r.height,
                  r.depthTexture.needsUpdate = !0),
                  T(r.depthTexture, 0);
                  const s = n.get(r.depthTexture).__webglTexture
                    , a = U(r);
                  if (r.depthTexture.format === Hu)
                      B(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, s, 0);
                  else {
                      if (r.depthTexture.format !== Gu)
                          throw new Error("Unknown depthTexture format");
                      B(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, s, 0)
                  }
              }(r.__webglFramebuffer, t)
          } else if (s) {
              r.__webglDepthbuffer = [];
              for (let n = 0; n < 6; n++)
                  i.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[n]),
                  r.__webglDepthbuffer[n] = e.createRenderbuffer(),
                  I(r.__webglDepthbuffer[n], t, !1)
          } else
              i.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
              r.__webglDepthbuffer = e.createRenderbuffer(),
              I(r.__webglDepthbuffer, t, !1);
          i.bindFramebuffer(e.FRAMEBUFFER, null)
      }
      const F = []
        , O = [];
      function U(e) {
          return Math.min(r.maxSamples, e.samples)
      }
      function B(e) {
          const i = n.get(e);
          return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== i.__useRenderToTexture
      }
      function z(e, t) {
          const i = e.colorSpace
            , n = e.format
            , r = e.type;
          return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || i !== Lh && i !== Ph && (ud.getTransfer(i) === Oh ? n === zu && r === Tu || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)),
          t
      }
      function k(e) {
          return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width,
          c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth,
          c.height = e.displayHeight) : (c.width = e.width,
          c.height = e.height),
          c
      }
      this.allocateTextureUnit = function() {
          const e = b;
          return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures),
          b += 1,
          e
      }
      ,
      this.resetTextureUnits = function() {
          b = 0
      }
      ,
      this.setTexture2D = T,
      this.setTexture2DArray = function(t, r) {
          const s = n.get(t);
          t.version > 0 && s.__version !== t.version ? R(s, t, r) : i.bindTexture(e.TEXTURE_2D_ARRAY, s.__webglTexture, e.TEXTURE0 + r)
      }
      ,
      this.setTexture3D = function(t, r) {
          const s = n.get(t);
          t.version > 0 && s.__version !== t.version ? R(s, t, r) : i.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + r)
      }
      ,
      this.setTextureCube = function(t, a) {
          const o = n.get(t);
          t.version > 0 && o.__version !== t.version ? function(t, a, o) {
              if (6 !== a.image.length)
                  return;
              const l = P(t, a)
                , c = a.source;
              i.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o);
              const u = n.get(c);
              if (c.version !== u.__version || !0 === l) {
                  i.activeTexture(e.TEXTURE0 + o);
                  const t = ud.getPrimaries(ud.workingColorSpace)
                    , n = a.colorSpace === Ph ? null : ud.getPrimaries(a.colorSpace)
                    , h = a.colorSpace === Ph || t === n ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                  e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
                  e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
                  e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
                  e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                  const d = a.isCompressedTexture || a.image[0].isCompressedTexture
                    , p = a.image[0] && a.image[0].isDataTexture
                    , f = [];
                  for (let e = 0; e < 6; e++)
                      f[e] = d || p ? p ? a.image[e].image : a.image[e] : m(a.image[e], !0, r.maxCubemapSize),
                      f[e] = z(a, f[e]);
                  const y = f[0]
                    , S = s.convert(a.format, a.colorSpace)
                    , E = s.convert(a.type)
                    , M = _(a.internalFormat, S, E, a.colorSpace)
                    , b = !0 !== a.isVideoTexture
                    , T = void 0 === u.__version || !0 === l
                    , w = c.dataReady;
                  let D, C = x(a, y);
                  if (A(e.TEXTURE_CUBE_MAP, a),
                  d) {
                      b && T && i.texStorage2D(e.TEXTURE_CUBE_MAP, C, M, y.width, y.height);
                      for (let t = 0; t < 6; t++) {
                          D = f[t].mipmaps;
                          for (let n = 0; n < D.length; n++) {
                              const r = D[n];
                              a.format !== zu ? null !== S ? b ? w && i.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n, 0, 0, r.width, r.height, S, r.data) : i.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n, M, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : b ? w && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n, 0, 0, r.width, r.height, S, E, r.data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n, M, r.width, r.height, 0, S, E, r.data)
                          }
                      }
                  } else {
                      if (D = a.mipmaps,
                      b && T) {
                          D.length > 0 && C++;
                          const t = k(f[0]);
                          i.texStorage2D(e.TEXTURE_CUBE_MAP, C, M, t.width, t.height)
                      }
                      for (let t = 0; t < 6; t++)
                          if (p) {
                              b ? w && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, f[t].width, f[t].height, S, E, f[t].data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, M, f[t].width, f[t].height, 0, S, E, f[t].data);
                              for (let n = 0; n < D.length; n++) {
                                  const r = D[n].image[t].image;
                                  b ? w && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n + 1, 0, 0, r.width, r.height, S, E, r.data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n + 1, M, r.width, r.height, 0, S, E, r.data)
                              }
                          } else {
                              b ? w && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, S, E, f[t]) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, M, S, E, f[t]);
                              for (let n = 0; n < D.length; n++) {
                                  const r = D[n];
                                  b ? w && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n + 1, 0, 0, S, E, r.image[t]) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, n + 1, M, S, E, r.image[t])
                              }
                          }
                  }
                  g(a) && v(e.TEXTURE_CUBE_MAP),
                  u.__version = c.version,
                  a.onUpdate && a.onUpdate(a)
              }
              t.__version = a.version
          }(o, t, a) : i.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + a)
      }
      ,
      this.rebindTextures = function(t, i, r) {
          const s = n.get(t);
          void 0 !== i && L(s.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
          void 0 !== r && N(t)
      }
      ,
      this.setupRenderTarget = function(t) {
          const r = t.texture
            , o = n.get(t)
            , l = n.get(r);
          t.addEventListener("dispose", E);
          const c = t.textures
            , u = !0 === t.isWebGLCubeRenderTarget
            , h = c.length > 1;
          if (h || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()),
          l.__version = r.version,
          a.memory.textures++),
          u) {
              o.__webglFramebuffer = [];
              for (let t = 0; t < 6; t++)
                  if (r.mipmaps && r.mipmaps.length > 0) {
                      o.__webglFramebuffer[t] = [];
                      for (let i = 0; i < r.mipmaps.length; i++)
                          o.__webglFramebuffer[t][i] = e.createFramebuffer()
                  } else
                      o.__webglFramebuffer[t] = e.createFramebuffer()
          } else {
              if (r.mipmaps && r.mipmaps.length > 0) {
                  o.__webglFramebuffer = [];
                  for (let t = 0; t < r.mipmaps.length; t++)
                      o.__webglFramebuffer[t] = e.createFramebuffer()
              } else
                  o.__webglFramebuffer = e.createFramebuffer();
              if (h)
                  for (let t = 0, i = c.length; t < i; t++) {
                      const i = n.get(c[t]);
                      void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(),
                      a.memory.textures++)
                  }
              if (t.samples > 0 && !1 === B(t)) {
                  o.__webglMultisampledFramebuffer = e.createFramebuffer(),
                  o.__webglColorRenderbuffer = [],
                  i.bindFramebuffer(e.FRAMEBUFFER, o.__webglMultisampledFramebuffer);
                  for (let i = 0; i < c.length; i++) {
                      const n = c[i];
                      o.__webglColorRenderbuffer[i] = e.createRenderbuffer(),
                      e.bindRenderbuffer(e.RENDERBUFFER, o.__webglColorRenderbuffer[i]);
                      const r = s.convert(n.format, n.colorSpace)
                        , a = s.convert(n.type)
                        , l = _(n.internalFormat, r, a, n.colorSpace, !0 === t.isXRRenderTarget)
                        , u = U(t);
                      e.renderbufferStorageMultisample(e.RENDERBUFFER, u, l, t.width, t.height),
                      e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + i, e.RENDERBUFFER, o.__webglColorRenderbuffer[i])
                  }
                  e.bindRenderbuffer(e.RENDERBUFFER, null),
                  t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(),
                  I(o.__webglDepthRenderbuffer, t, !0)),
                  i.bindFramebuffer(e.FRAMEBUFFER, null)
              }
          }
          if (u) {
              i.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture),
              A(e.TEXTURE_CUBE_MAP, r);
              for (let i = 0; i < 6; i++)
                  if (r.mipmaps && r.mipmaps.length > 0)
                      for (let n = 0; n < r.mipmaps.length; n++)
                          L(o.__webglFramebuffer[i][n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + i, n);
                  else
                      L(o.__webglFramebuffer[i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
              g(r) && v(e.TEXTURE_CUBE_MAP),
              i.unbindTexture()
          } else if (h) {
              for (let r = 0, s = c.length; r < s; r++) {
                  const s = c[r]
                    , a = n.get(s);
                  i.bindTexture(e.TEXTURE_2D, a.__webglTexture),
                  A(e.TEXTURE_2D, s),
                  L(o.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0),
                  g(s) && v(e.TEXTURE_2D)
              }
              i.unbindTexture()
          } else {
              let n = e.TEXTURE_2D;
              if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (n = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
              i.bindTexture(n, l.__webglTexture),
              A(n, r),
              r.mipmaps && r.mipmaps.length > 0)
                  for (let i = 0; i < r.mipmaps.length; i++)
                      L(o.__webglFramebuffer[i], t, r, e.COLOR_ATTACHMENT0, n, i);
              else
                  L(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, n, 0);
              g(r) && v(n),
              i.unbindTexture()
          }
          t.depthBuffer && N(t)
      }
      ,
      this.updateRenderTargetMipmap = function(t) {
          const r = t.textures;
          for (let s = 0, a = r.length; s < a; s++) {
              const a = r[s];
              if (g(a)) {
                  const r = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D
                    , s = n.get(a).__webglTexture;
                  i.bindTexture(r, s),
                  v(r),
                  i.unbindTexture()
              }
          }
      }
      ,
      this.updateMultisampleRenderTarget = function(t) {
          if (t.samples > 0)
              if (!1 === B(t)) {
                  const r = t.textures
                    , s = t.width
                    , a = t.height;
                  let o = e.COLOR_BUFFER_BIT;
                  const c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                    , u = n.get(t)
                    , h = r.length > 1;
                  if (h)
                      for (let t = 0; t < r.length; t++)
                          i.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                          e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                          i.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                          e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                  i.bindFramebuffer(e.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                  i.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                  for (let i = 0; i < r.length; i++) {
                      if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                      t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)),
                      h) {
                          e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, u.__webglColorRenderbuffer[i]);
                          const t = n.get(r[i]).__webglTexture;
                          e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                      }
                      e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, e.NEAREST),
                      !0 === l && (F.length = 0,
                      O.length = 0,
                      F.push(e.COLOR_ATTACHMENT0 + i),
                      t.depthBuffer && !1 === t.resolveDepthBuffer && (F.push(c),
                      O.push(c),
                      e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, O)),
                      e.invalidateFramebuffer(e.READ_FRAMEBUFFER, F))
                  }
                  if (i.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                  i.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                  h)
                      for (let t = 0; t < r.length; t++) {
                          i.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                          e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, u.__webglColorRenderbuffer[t]);
                          const s = n.get(r[t]).__webglTexture;
                          i.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                          e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, s, 0)
                      }
                  i.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer)
              } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) {
                  const i = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                  e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [i])
              }
      }
      ,
      this.setupDepthRenderbuffer = N,
      this.setupFrameBufferTexture = L,
      this.useMultisampledRTT = B
  }
  function Cv(e, t) {
      return {
          convert: function(i, n="") {
              let r;
              const s = ud.getTransfer(n);
              if (i === Tu)
                  return e.UNSIGNED_BYTE;
              if (i === Iu)
                  return e.UNSIGNED_SHORT_4_4_4_4;
              if (i === Nu)
                  return e.UNSIGNED_SHORT_5_5_5_1;
              if (i === Ou)
                  return e.UNSIGNED_INT_5_9_9_9_REV;
              if (i === wu)
                  return e.BYTE;
              if (i === Du)
                  return e.SHORT;
              if (i === Cu)
                  return e.UNSIGNED_SHORT;
              if (i === Au)
                  return e.INT;
              if (i === Pu)
                  return e.UNSIGNED_INT;
              if (i === Ru)
                  return e.FLOAT;
              if (i === Lu)
                  return e.HALF_FLOAT;
              if (i === Uu)
                  return e.ALPHA;
              if (i === Bu)
                  return e.RGB;
              if (i === zu)
                  return e.RGBA;
              if (i === ku)
                  return e.LUMINANCE;
              if (i === Vu)
                  return e.LUMINANCE_ALPHA;
              if (i === Hu)
                  return e.DEPTH_COMPONENT;
              if (i === Gu)
                  return e.DEPTH_STENCIL;
              if (i === Wu)
                  return e.RED;
              if (i === Xu)
                  return e.RED_INTEGER;
              if (i === qu)
                  return e.RG;
              if (i === ju)
                  return e.RG_INTEGER;
              if (i === Yu)
                  return e.RGBA_INTEGER;
              if (i === Ku || i === Zu || i === $u || i === Ju)
                  if (s === Oh) {
                      if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                      null === r)
                          return null;
                      if (i === Ku)
                          return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                      if (i === Zu)
                          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                      if (i === $u)
                          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                      if (i === Ju)
                          return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                  } else {
                      if (r = t.get("WEBGL_compressed_texture_s3tc"),
                      null === r)
                          return null;
                      if (i === Ku)
                          return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                      if (i === Zu)
                          return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                      if (i === $u)
                          return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                      if (i === Ju)
                          return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                  }
              if (i === Qu || i === eh || i === th || i === ih) {
                  if (r = t.get("WEBGL_compressed_texture_pvrtc"),
                  null === r)
                      return null;
                  if (i === Qu)
                      return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                  if (i === eh)
                      return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                  if (i === th)
                      return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                  if (i === ih)
                      return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
              }
              if (i === nh || i === rh || i === sh) {
                  if (r = t.get("WEBGL_compressed_texture_etc"),
                  null === r)
                      return null;
                  if (i === nh || i === rh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                  if (i === sh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
              }
              if (i === ah || i === oh || i === lh || i === ch || i === uh || i === hh || i === dh || i === ph || i === fh || i === mh || i === gh || i === vh || i === _h || i === yh) {
                  if (r = t.get("WEBGL_compressed_texture_astc"),
                  null === r)
                      return null;
                  if (i === ah)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                  if (i === oh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                  if (i === lh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                  if (i === ch)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                  if (i === uh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                  if (i === hh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                  if (i === dh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                  if (i === ph)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                  if (i === fh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                  if (i === mh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                  if (i === gh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                  if (i === vh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                  if (i === _h)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                  if (i === yh)
                      return s === Oh ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
              }
              if (i === xh || i === Sh || i === Eh) {
                  if (r = t.get("EXT_texture_compression_bptc"),
                  null === r)
                      return null;
                  if (i === xh)
                      return s === Oh ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                  if (i === Sh)
                      return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                  if (i === Eh)
                      return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
              }
              if (i === Mh || i === bh || i === Th || i === wh) {
                  if (r = t.get("EXT_texture_compression_rgtc"),
                  null === r)
                      return null;
                  if (i === xh)
                      return r.COMPRESSED_RED_RGTC1_EXT;
                  if (i === bh)
                      return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                  if (i === Th)
                      return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                  if (i === wh)
                      return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
              }
              return i === Fu ? e.UNSIGNED_INT_24_8 : void 0 !== e[i] ? e[i] : null
          }
      }
  }
  class Av extends kf {
      constructor(e=[]) {
          super(),
          this.isArrayCamera = !0,
          this.cameras = e
      }
  }
  class Pv extends Ap {
      constructor() {
          super(),
          this.isGroup = !0,
          this.type = "Group"
      }
  }
  const Rv = {
      type: "move"
  };
  class Lv {
      constructor() {
          this._targetRay = null,
          this._grip = null,
          this._hand = null
      }
      getHandSpace() {
          return null === this._hand && (this._hand = new Pv,
          this._hand.matrixAutoUpdate = !1,
          this._hand.visible = !1,
          this._hand.joints = {},
          this._hand.inputState = {
              pinching: !1
          }),
          this._hand
      }
      getTargetRaySpace() {
          return null === this._targetRay && (this._targetRay = new Pv,
          this._targetRay.matrixAutoUpdate = !1,
          this._targetRay.visible = !1,
          this._targetRay.hasLinearVelocity = !1,
          this._targetRay.linearVelocity = new wd,
          this._targetRay.hasAngularVelocity = !1,
          this._targetRay.angularVelocity = new wd),
          this._targetRay
      }
      getGripSpace() {
          return null === this._grip && (this._grip = new Pv,
          this._grip.matrixAutoUpdate = !1,
          this._grip.visible = !1,
          this._grip.hasLinearVelocity = !1,
          this._grip.linearVelocity = new wd,
          this._grip.hasAngularVelocity = !1,
          this._grip.angularVelocity = new wd),
          this._grip
      }
      dispatchEvent(e) {
          return null !== this._targetRay && this._targetRay.dispatchEvent(e),
          null !== this._grip && this._grip.dispatchEvent(e),
          null !== this._hand && this._hand.dispatchEvent(e),
          this
      }
      connect(e) {
          if (e && e.hand) {
              const t = this._hand;
              if (t)
                  for (const i of e.hand.values())
                      this._getHandJoint(t, i)
          }
          return this.dispatchEvent({
              type: "connected",
              data: e
          }),
          this
      }
      disconnect(e) {
          return this.dispatchEvent({
              type: "disconnected",
              data: e
          }),
          null !== this._targetRay && (this._targetRay.visible = !1),
          null !== this._grip && (this._grip.visible = !1),
          null !== this._hand && (this._hand.visible = !1),
          this
      }
      update(e, t, i) {
          let n = null
            , r = null
            , s = null;
          const a = this._targetRay
            , o = this._grip
            , l = this._hand;
          if (e && "visible-blurred" !== t.session.visibilityState) {
              if (l && e.hand) {
                  s = !0;
                  for (const n of e.hand.values()) {
                      const e = t.getJointPose(n, i)
                        , r = this._getHandJoint(l, n);
                      null !== e && (r.matrix.fromArray(e.transform.matrix),
                      r.matrix.decompose(r.position, r.rotation, r.scale),
                      r.matrixWorldNeedsUpdate = !0,
                      r.jointRadius = e.radius),
                      r.visible = null !== e
                  }
                  const n = l.joints["index-finger-tip"]
                    , r = l.joints["thumb-tip"]
                    , a = n.position.distanceTo(r.position)
                    , o = .02
                    , c = .005;
                  l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1,
                  this.dispatchEvent({
                      type: "pinchend",
                      handedness: e.handedness,
                      target: this
                  })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0,
                  this.dispatchEvent({
                      type: "pinchstart",
                      handedness: e.handedness,
                      target: this
                  }))
              } else
                  null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, i),
                  null !== r && (o.matrix.fromArray(r.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  o.matrixWorldNeedsUpdate = !0,
                  r.linearVelocity ? (o.hasLinearVelocity = !0,
                  o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                  r.angularVelocity ? (o.hasAngularVelocity = !0,
                  o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
              null !== a && (n = t.getPose(e.targetRaySpace, i),
              null === n && null !== r && (n = r),
              null !== n && (a.matrix.fromArray(n.transform.matrix),
              a.matrix.decompose(a.position, a.rotation, a.scale),
              a.matrixWorldNeedsUpdate = !0,
              n.linearVelocity ? (a.hasLinearVelocity = !0,
              a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1,
              n.angularVelocity ? (a.hasAngularVelocity = !0,
              a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1,
              this.dispatchEvent(Rv)))
          }
          return null !== a && (a.visible = null !== n),
          null !== o && (o.visible = null !== r),
          null !== l && (l.visible = null !== s),
          this
      }
      _getHandJoint(e, t) {
          if (void 0 === e.joints[t.jointName]) {
              const i = new Pv;
              i.matrixAutoUpdate = !1,
              i.visible = !1,
              e.joints[t.jointName] = i,
              e.add(i)
          }
          return e.joints[t.jointName]
      }
  }
  class Iv {
      constructor() {
          this.texture = null,
          this.mesh = null,
          this.depthNear = 0,
          this.depthFar = 0
      }
      init(e, t, i) {
          if (null === this.texture) {
              const n = new yd;
              e.properties.get(n).__webglTexture = t.texture,
              t.depthNear == i.depthNear && t.depthFar == i.depthFar || (this.depthNear = t.depthNear,
              this.depthFar = t.depthFar),
              this.texture = n
          }
      }
      getMesh(e) {
          if (null !== this.texture && null === this.mesh) {
              const t = e.cameras[0].viewport
                , i = new Ff({
                  vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                  fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                  uniforms: {
                      depthColor: {
                          value: this.texture
                      },
                      depthWidth: {
                          value: t.z
                      },
                      depthHeight: {
                          value: t.w
                      }
                  }
              });
              this.mesh = new Cf(new em(20,20),i)
          }
          return this.mesh
      }
      reset() {
          this.texture = null,
          this.mesh = null
      }
      getDepthTexture() {
          return this.texture
      }
  }
  class Nv extends Gh {
      constructor(e, t) {
          super();
          const i = this;
          let n = null
            , r = 1
            , s = null
            , a = "local-floor"
            , o = 1
            , l = null
            , c = null
            , u = null
            , h = null
            , d = null
            , p = null;
          const f = new Iv
            , m = t.getContextAttributes();
          let g = null
            , v = null;
          const _ = []
            , y = []
            , x = new Jh;
          let S = null;
          const E = new kf;
          E.layers.enable(1),
          E.viewport = new xd;
          const M = new kf;
          M.layers.enable(2),
          M.viewport = new xd;
          const b = [E, M]
            , T = new Av;
          T.layers.enable(1),
          T.layers.enable(2);
          let w = null
            , D = null;
          function C(e) {
              const t = y.indexOf(e.inputSource);
              if (-1 === t)
                  return;
              const i = _[t];
              void 0 !== i && (i.update(e.inputSource, e.frame, l || s),
              i.dispatchEvent({
                  type: e.type,
                  data: e.inputSource
              }))
          }
          function A() {
              n.removeEventListener("select", C),
              n.removeEventListener("selectstart", C),
              n.removeEventListener("selectend", C),
              n.removeEventListener("squeeze", C),
              n.removeEventListener("squeezestart", C),
              n.removeEventListener("squeezeend", C),
              n.removeEventListener("end", A),
              n.removeEventListener("inputsourceschange", P);
              for (let e = 0; e < _.length; e++) {
                  const t = y[e];
                  null !== t && (y[e] = null,
                  _[e].disconnect(t))
              }
              w = null,
              D = null,
              f.reset(),
              e.setRenderTarget(g),
              d = null,
              h = null,
              u = null,
              n = null,
              v = null,
              F.stop(),
              i.isPresenting = !1,
              e.setPixelRatio(S),
              e.setSize(x.width, x.height, !1),
              i.dispatchEvent({
                  type: "sessionend"
              })
          }
          function P(e) {
              for (let t = 0; t < e.removed.length; t++) {
                  const i = e.removed[t]
                    , n = y.indexOf(i);
                  n >= 0 && (y[n] = null,
                  _[n].disconnect(i))
              }
              for (let t = 0; t < e.added.length; t++) {
                  const i = e.added[t];
                  let n = y.indexOf(i);
                  if (-1 === n) {
                      for (let e = 0; e < _.length; e++) {
                          if (e >= y.length) {
                              y.push(i),
                              n = e;
                              break
                          }
                          if (null === y[e]) {
                              y[e] = i,
                              n = e;
                              break
                          }
                      }
                      if (-1 === n)
                          break
                  }
                  const r = _[n];
                  r && r.connect(i)
              }
          }
          this.cameraAutoUpdate = !0,
          this.enabled = !1,
          this.isPresenting = !1,
          this.getController = function(e) {
              let t = _[e];
              return void 0 === t && (t = new Lv,
              _[e] = t),
              t.getTargetRaySpace()
          }
          ,
          this.getControllerGrip = function(e) {
              let t = _[e];
              return void 0 === t && (t = new Lv,
              _[e] = t),
              t.getGripSpace()
          }
          ,
          this.getHand = function(e) {
              let t = _[e];
              return void 0 === t && (t = new Lv,
              _[e] = t),
              t.getHandSpace()
          }
          ,
          this.setFramebufferScaleFactor = function(e) {
              r = e,
              !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
          }
          ,
          this.setReferenceSpaceType = function(e) {
              a = e,
              !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
          }
          ,
          this.getReferenceSpace = function() {
              return l || s
          }
          ,
          this.setReferenceSpace = function(e) {
              l = e
          }
          ,
          this.getBaseLayer = function() {
              return null !== h ? h : d
          }
          ,
          this.getBinding = function() {
              return u
          }
          ,
          this.getFrame = function() {
              return p
          }
          ,
          this.getSession = function() {
              return n
          }
          ,
          this.setSession = async function(c) {
              if (n = c,
              null !== n) {
                  if (g = e.getRenderTarget(),
                  n.addEventListener("select", C),
                  n.addEventListener("selectstart", C),
                  n.addEventListener("selectend", C),
                  n.addEventListener("squeeze", C),
                  n.addEventListener("squeezestart", C),
                  n.addEventListener("squeezeend", C),
                  n.addEventListener("end", A),
                  n.addEventListener("inputsourceschange", P),
                  !0 !== m.xrCompatible && await t.makeXRCompatible(),
                  S = e.getPixelRatio(),
                  e.getSize(x),
                  void 0 === n.renderState.layers) {
                      const i = {
                          antialias: m.antialias,
                          alpha: !0,
                          depth: m.depth,
                          stencil: m.stencil,
                          framebufferScaleFactor: r
                      };
                      d = new XRWebGLLayer(n,t,i),
                      n.updateRenderState({
                          baseLayer: d
                      }),
                      e.setPixelRatio(1),
                      e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                      v = new Ed(d.framebufferWidth,d.framebufferHeight,{
                          format: zu,
                          type: Tu,
                          colorSpace: e.outputColorSpace,
                          stencilBuffer: m.stencil
                      })
                  } else {
                      let i = null
                        , s = null
                        , a = null;
                      m.depth && (a = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                      i = m.stencil ? Gu : Hu,
                      s = m.stencil ? Fu : Pu);
                      const o = {
                          colorFormat: t.RGBA8,
                          depthFormat: a,
                          scaleFactor: r
                      };
                      u = new XRWebGLBinding(n,t),
                      h = u.createProjectionLayer(o),
                      n.updateRenderState({
                          layers: [h]
                      }),
                      e.setPixelRatio(1),
                      e.setSize(h.textureWidth, h.textureHeight, !1),
                      v = new Ed(h.textureWidth,h.textureHeight,{
                          format: zu,
                          type: Tu,
                          depthTexture: new Om(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,i),
                          stencilBuffer: m.stencil,
                          colorSpace: e.outputColorSpace,
                          samples: m.antialias ? 4 : 0,
                          resolveDepthBuffer: !1 === h.ignoreDepthValues
                      })
                  }
                  v.isXRRenderTarget = !0,
                  this.setFoveation(o),
                  l = null,
                  s = await n.requestReferenceSpace(a),
                  F.setContext(n),
                  F.start(),
                  i.isPresenting = !0,
                  i.dispatchEvent({
                      type: "sessionstart"
                  })
              }
          }
          ,
          this.getEnvironmentBlendMode = function() {
              if (null !== n)
                  return n.environmentBlendMode
          }
          ,
          this.getDepthTexture = function() {
              return f.getDepthTexture()
          }
          ;
          const R = new wd
            , L = new wd;
          function I(e, t) {
              null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
              e.matrixWorldInverse.copy(e.matrixWorld).invert()
          }
          this.updateCamera = function(e) {
              if (null === n)
                  return;
              null !== f.texture && (e.near = f.depthNear,
              e.far = f.depthFar),
              T.near = M.near = E.near = e.near,
              T.far = M.far = E.far = e.far,
              w === T.near && D === T.far || (n.updateRenderState({
                  depthNear: T.near,
                  depthFar: T.far
              }),
              w = T.near,
              D = T.far,
              E.near = w,
              E.far = D,
              M.near = w,
              M.far = D,
              E.updateProjectionMatrix(),
              M.updateProjectionMatrix(),
              e.updateProjectionMatrix());
              const t = e.parent
                , i = T.cameras;
              I(T, t);
              for (let e = 0; e < i.length; e++)
                  I(i[e], t);
              2 === i.length ? function(e, t, i) {
                  R.setFromMatrixPosition(t.matrixWorld),
                  L.setFromMatrixPosition(i.matrixWorld);
                  const n = R.distanceTo(L)
                    , r = t.projectionMatrix.elements
                    , s = i.projectionMatrix.elements
                    , a = r[14] / (r[10] - 1)
                    , o = r[14] / (r[10] + 1)
                    , l = (r[9] + 1) / r[5]
                    , c = (r[9] - 1) / r[5]
                    , u = (r[8] - 1) / r[0]
                    , h = (s[8] + 1) / s[0]
                    , d = a * u
                    , p = a * h
                    , f = n / (-u + h)
                    , m = f * -u;
                  t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                  e.translateX(m),
                  e.translateZ(f),
                  e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                  e.matrixWorldInverse.copy(e.matrixWorld).invert();
                  const g = a + f
                    , v = o + f
                    , _ = d - m
                    , y = p + (n - m)
                    , x = l * o / v * g
                    , S = c * o / v * g;
                  e.projectionMatrix.makePerspective(_, y, x, S, g, v),
                  e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
              }(T, E, M) : T.projectionMatrix.copy(E.projectionMatrix),
              function(e, t, i) {
                  null === i ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(i.matrixWorld),
                  e.matrix.invert(),
                  e.matrix.multiply(t.matrixWorld)),
                  e.matrix.decompose(e.position, e.quaternion, e.scale),
                  e.updateMatrixWorld(!0),
                  e.projectionMatrix.copy(t.projectionMatrix),
                  e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                  e.isPerspectiveCamera && (e.fov = 2 * qh * Math.atan(1 / e.projectionMatrix.elements[5]),
                  e.zoom = 1)
              }(e, T, t)
          }
          ,
          this.getCamera = function() {
              return T
          }
          ,
          this.getFoveation = function() {
              if (null !== h || null !== d)
                  return o
          }
          ,
          this.setFoveation = function(e) {
              o = e,
              null !== h && (h.fixedFoveation = e),
              null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e)
          }
          ,
          this.hasDepthSensing = function() {
              return null !== f.texture
          }
          ,
          this.getDepthSensingMesh = function() {
              return f.getMesh(T)
          }
          ;
          let N = null;
          const F = new Jf;
          F.setAnimationLoop((function(t, r) {
              if (c = r.getViewerPose(l || s),
              p = r,
              null !== c) {
                  const t = c.views;
                  null !== d && (e.setRenderTargetFramebuffer(v, d.framebuffer),
                  e.setRenderTarget(v));
                  let i = !1;
                  t.length !== T.cameras.length && (T.cameras.length = 0,
                  i = !0);
                  for (let n = 0; n < t.length; n++) {
                      const r = t[n];
                      let s = null;
                      if (null !== d)
                          s = d.getViewport(r);
                      else {
                          const t = u.getViewSubImage(h, r);
                          s = t.viewport,
                          0 === n && (e.setRenderTargetTextures(v, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                          e.setRenderTarget(v))
                      }
                      let a = b[n];
                      void 0 === a && (a = new kf,
                      a.layers.enable(n),
                      a.viewport = new xd,
                      b[n] = a),
                      a.matrix.fromArray(r.transform.matrix),
                      a.matrix.decompose(a.position, a.quaternion, a.scale),
                      a.projectionMatrix.fromArray(r.projectionMatrix),
                      a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
                      a.viewport.set(s.x, s.y, s.width, s.height),
                      0 === n && (T.matrix.copy(a.matrix),
                      T.matrix.decompose(T.position, T.quaternion, T.scale)),
                      !0 === i && T.cameras.push(a)
                  }
                  const r = n.enabledFeatures;
                  if (r && r.includes("depth-sensing")) {
                      const i = u.getDepthInformation(t[0]);
                      i && i.isValid && i.texture && f.init(e, i, n.renderState)
                  }
              }
              for (let e = 0; e < _.length; e++) {
                  const t = y[e]
                    , i = _[e];
                  null !== t && void 0 !== i && i.update(t, r, l || s)
              }
              N && N(t, r),
              r.detectedPlanes && i.dispatchEvent({
                  type: "planesdetected",
                  data: r
              }),
              p = null
          }
          )),
          this.setAnimationLoop = function(e) {
              N = e
          }
          ,
          this.dispose = function() {}
      }
  }
  const Fv = new dp
    , Ov = new ip;
  function Uv(e, t) {
      function i(e, t) {
          !0 === e.matrixAutoUpdate && e.updateMatrix(),
          t.value.copy(e.matrix)
      }
      function n(e, n) {
          e.opacity.value = n.opacity,
          n.color && e.diffuse.value.copy(n.color),
          n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
          n.map && (e.map.value = n.map,
          i(n.map, e.mapTransform)),
          n.alphaMap && (e.alphaMap.value = n.alphaMap,
          i(n.alphaMap, e.alphaMapTransform)),
          n.bumpMap && (e.bumpMap.value = n.bumpMap,
          i(n.bumpMap, e.bumpMapTransform),
          e.bumpScale.value = n.bumpScale,
          1 === n.side && (e.bumpScale.value *= -1)),
          n.normalMap && (e.normalMap.value = n.normalMap,
          i(n.normalMap, e.normalMapTransform),
          e.normalScale.value.copy(n.normalScale),
          1 === n.side && e.normalScale.value.negate()),
          n.displacementMap && (e.displacementMap.value = n.displacementMap,
          i(n.displacementMap, e.displacementMapTransform),
          e.displacementScale.value = n.displacementScale,
          e.displacementBias.value = n.displacementBias),
          n.emissiveMap && (e.emissiveMap.value = n.emissiveMap,
          i(n.emissiveMap, e.emissiveMapTransform)),
          n.specularMap && (e.specularMap.value = n.specularMap,
          i(n.specularMap, e.specularMapTransform)),
          n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
          const r = t.get(n)
            , s = r.envMap
            , a = r.envMapRotation;
          s && (e.envMap.value = s,
          Fv.copy(a),
          Fv.x *= -1,
          Fv.y *= -1,
          Fv.z *= -1,
          s.isCubeTexture && !1 === s.isRenderTargetTexture && (Fv.y *= -1,
          Fv.z *= -1),
          e.envMapRotation.value.setFromMatrix4(Ov.makeRotationFromEuler(Fv)),
          e.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1,
          e.reflectivity.value = n.reflectivity,
          e.ior.value = n.ior,
          e.refractionRatio.value = n.refractionRatio),
          n.lightMap && (e.lightMap.value = n.lightMap,
          e.lightMapIntensity.value = n.lightMapIntensity,
          i(n.lightMap, e.lightMapTransform)),
          n.aoMap && (e.aoMap.value = n.aoMap,
          e.aoMapIntensity.value = n.aoMapIntensity,
          i(n.aoMap, e.aoMapTransform))
      }
      return {
          refreshFogUniforms: function(t, i) {
              i.color.getRGB(t.fogColor.value, If(e)),
              i.isFog ? (t.fogNear.value = i.near,
              t.fogFar.value = i.far) : i.isFogExp2 && (t.fogDensity.value = i.density)
          },
          refreshMaterialUniforms: function(e, r, s, a, o) {
              r.isMeshBasicMaterial || r.isMeshLambertMaterial ? n(e, r) : r.isMeshToonMaterial ? (n(e, r),
              function(e, t) {
                  t.gradientMap && (e.gradientMap.value = t.gradientMap)
              }(e, r)) : r.isMeshPhongMaterial ? (n(e, r),
              function(e, t) {
                  e.specular.value.copy(t.specular),
                  e.shininess.value = Math.max(t.shininess, 1e-4)
              }(e, r)) : r.isMeshStandardMaterial ? (n(e, r),
              function(e, t) {
                  e.metalness.value = t.metalness,
                  t.metalnessMap && (e.metalnessMap.value = t.metalnessMap,
                  i(t.metalnessMap, e.metalnessMapTransform)),
                  e.roughness.value = t.roughness,
                  t.roughnessMap && (e.roughnessMap.value = t.roughnessMap,
                  i(t.roughnessMap, e.roughnessMapTransform)),
                  t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
              }(e, r),
              r.isMeshPhysicalMaterial && function(e, t, n) {
                  e.ior.value = t.ior,
                  t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                  e.sheenRoughness.value = t.sheenRoughness,
                  t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap,
                  i(t.sheenColorMap, e.sheenColorMapTransform)),
                  t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap,
                  i(t.sheenRoughnessMap, e.sheenRoughnessMapTransform))),
                  t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                  e.clearcoatRoughness.value = t.clearcoatRoughness,
                  t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap,
                  i(t.clearcoatMap, e.clearcoatMapTransform)),
                  t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap,
                  i(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                  t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                  i(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                  e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                  1 === t.side && e.clearcoatNormalScale.value.negate())),
                  t.dispersion > 0 && (e.dispersion.value = t.dispersion),
                  t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                  e.iridescenceIOR.value = t.iridescenceIOR,
                  e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                  e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                  t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap,
                  i(t.iridescenceMap, e.iridescenceMapTransform)),
                  t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap,
                  i(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))),
                  t.transmission > 0 && (e.transmission.value = t.transmission,
                  e.transmissionSamplerMap.value = n.texture,
                  e.transmissionSamplerSize.value.set(n.width, n.height),
                  t.transmissionMap && (e.transmissionMap.value = t.transmissionMap,
                  i(t.transmissionMap, e.transmissionMapTransform)),
                  e.thickness.value = t.thickness,
                  t.thicknessMap && (e.thicknessMap.value = t.thicknessMap,
                  i(t.thicknessMap, e.thicknessMapTransform)),
                  e.attenuationDistance.value = t.attenuationDistance,
                  e.attenuationColor.value.copy(t.attenuationColor)),
                  t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)),
                  t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap,
                  i(t.anisotropyMap, e.anisotropyMapTransform))),
                  e.specularIntensity.value = t.specularIntensity,
                  e.specularColor.value.copy(t.specularColor),
                  t.specularColorMap && (e.specularColorMap.value = t.specularColorMap,
                  i(t.specularColorMap, e.specularColorMapTransform)),
                  t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap,
                  i(t.specularIntensityMap, e.specularIntensityMapTransform))
              }(e, r, o)) : r.isMeshMatcapMaterial ? (n(e, r),
              function(e, t) {
                  t.matcap && (e.matcap.value = t.matcap)
              }(e, r)) : r.isMeshDepthMaterial ? n(e, r) : r.isMeshDistanceMaterial ? (n(e, r),
              function(e, i) {
                  const n = t.get(i).light;
                  e.referencePosition.value.setFromMatrixPosition(n.matrixWorld),
                  e.nearDistance.value = n.shadow.camera.near,
                  e.farDistance.value = n.shadow.camera.far
              }(e, r)) : r.isMeshNormalMaterial ? n(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                  e.diffuse.value.copy(t.color),
                  e.opacity.value = t.opacity,
                  t.map && (e.map.value = t.map,
                  i(t.map, e.mapTransform))
              }(e, r),
              r.isLineDashedMaterial && function(e, t) {
                  e.dashSize.value = t.dashSize,
                  e.totalSize.value = t.dashSize + t.gapSize,
                  e.scale.value = t.scale
              }(e, r)) : r.isPointsMaterial ? function(e, t, n, r) {
                  e.diffuse.value.copy(t.color),
                  e.opacity.value = t.opacity,
                  e.size.value = t.size * n,
                  e.scale.value = .5 * r,
                  t.map && (e.map.value = t.map,
                  i(t.map, e.uvTransform)),
                  t.alphaMap && (e.alphaMap.value = t.alphaMap,
                  i(t.alphaMap, e.alphaMapTransform)),
                  t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
              }(e, r, s, a) : r.isSpriteMaterial ? function(e, t) {
                  e.diffuse.value.copy(t.color),
                  e.opacity.value = t.opacity,
                  e.rotation.value = t.rotation,
                  t.map && (e.map.value = t.map,
                  i(t.map, e.mapTransform)),
                  t.alphaMap && (e.alphaMap.value = t.alphaMap,
                  i(t.alphaMap, e.alphaMapTransform)),
                  t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
              }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color),
              e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
          }
      }
  }
  function Bv(e, t, i, n) {
      let r = {}
        , s = {}
        , a = [];
      const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
      function l(e, t, i, n) {
          const r = e.value
            , s = t + "_" + i;
          if (void 0 === n[s])
              return n[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(),
              !0;
          {
              const e = n[s];
              if ("number" == typeof r || "boolean" == typeof r) {
                  if (e !== r)
                      return n[s] = r,
                      !0
              } else if (!1 === e.equals(r))
                  return e.copy(r),
                  !0
          }
          return !1
      }
      function c(e) {
          const t = {
              boundary: 0,
              storage: 0
          };
          return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4,
          t.storage = 4) : e.isVector2 ? (t.boundary = 8,
          t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16,
          t.storage = 12) : e.isVector4 ? (t.boundary = 16,
          t.storage = 16) : e.isMatrix3 ? (t.boundary = 48,
          t.storage = 48) : e.isMatrix4 ? (t.boundary = 64,
          t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e),
          t
      }
      function u(t) {
          const i = t.target;
          i.removeEventListener("dispose", u);
          const n = a.indexOf(i.__bindingPointIndex);
          a.splice(n, 1),
          e.deleteBuffer(r[i.id]),
          delete r[i.id],
          delete s[i.id]
      }
      return {
          bind: function(e, t) {
              const i = t.program;
              n.uniformBlockBinding(e, i)
          },
          update: function(i, h) {
              let d = r[i.id];
              void 0 === d && (function(e) {
                  const t = e.uniforms;
                  let i = 0;
                  for (let e = 0, n = t.length; e < n; e++) {
                      const n = Array.isArray(t[e]) ? t[e] : [t[e]];
                      for (let e = 0, t = n.length; e < t; e++) {
                          const t = n[e]
                            , r = Array.isArray(t.value) ? t.value : [t.value];
                          for (let e = 0, n = r.length; e < n; e++) {
                              const n = c(r[e])
                                , s = i % 16
                                , a = s % n.boundary
                                , o = s + a;
                              i += a,
                              0 !== o && 16 - o < n.storage && (i += 16 - o),
                              t.__data = new Float32Array(n.storage / Float32Array.BYTES_PER_ELEMENT),
                              t.__offset = i,
                              i += n.storage
                          }
                      }
                  }
                  const n = i % 16;
                  n > 0 && (i += 16 - n),
                  e.__size = i,
                  e.__cache = {}
              }(i),
              d = function(t) {
                  const i = function() {
                      for (let e = 0; e < o; e++)
                          if (-1 === a.indexOf(e))
                              return a.push(e),
                              e;
                      return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                      0
                  }();
                  t.__bindingPointIndex = i;
                  const n = e.createBuffer()
                    , r = t.__size
                    , s = t.usage;
                  return e.bindBuffer(e.UNIFORM_BUFFER, n),
                  e.bufferData(e.UNIFORM_BUFFER, r, s),
                  e.bindBuffer(e.UNIFORM_BUFFER, null),
                  e.bindBufferBase(e.UNIFORM_BUFFER, i, n),
                  n
              }(i),
              r[i.id] = d,
              i.addEventListener("dispose", u));
              const p = h.program;
              n.updateUBOMapping(i, p);
              const f = t.render.frame;
              s[i.id] !== f && (function(t) {
                  const i = r[t.id]
                    , n = t.uniforms
                    , s = t.__cache;
                  e.bindBuffer(e.UNIFORM_BUFFER, i);
                  for (let t = 0, i = n.length; t < i; t++) {
                      const i = Array.isArray(n[t]) ? n[t] : [n[t]];
                      for (let n = 0, r = i.length; n < r; n++) {
                          const r = i[n];
                          if (!0 === l(r, t, n, s)) {
                              const t = r.__offset
                                , i = Array.isArray(r.value) ? r.value : [r.value];
                              let n = 0;
                              for (let s = 0; s < i.length; s++) {
                                  const a = i[s]
                                    , o = c(a);
                                  "number" == typeof a || "boolean" == typeof a ? (r.__data[0] = a,
                                  e.bufferSubData(e.UNIFORM_BUFFER, t + n, r.__data)) : a.isMatrix3 ? (r.__data[0] = a.elements[0],
                                  r.__data[1] = a.elements[1],
                                  r.__data[2] = a.elements[2],
                                  r.__data[3] = 0,
                                  r.__data[4] = a.elements[3],
                                  r.__data[5] = a.elements[4],
                                  r.__data[6] = a.elements[5],
                                  r.__data[7] = 0,
                                  r.__data[8] = a.elements[6],
                                  r.__data[9] = a.elements[7],
                                  r.__data[10] = a.elements[8],
                                  r.__data[11] = 0) : (a.toArray(r.__data, n),
                                  n += o.storage / Float32Array.BYTES_PER_ELEMENT)
                              }
                              e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                          }
                      }
                  }
                  e.bindBuffer(e.UNIFORM_BUFFER, null)
              }(i),
              s[i.id] = f)
          },
          dispose: function() {
              for (const t in r)
                  e.deleteBuffer(r[t]);
              a = [],
              r = {},
              s = {}
          }
      }
  }
  class zv {
      constructor(e={}) {
          const {canvas: t=nd(), context: i=null, depth: n=!0, stencil: r=!1, alpha: s=!1, antialias: a=!1, premultipliedAlpha: o=!0, preserveDrawingBuffer: l=!1, powerPreference: c="default", failIfMajorPerformanceCaveat: u=!1} = e;
          let h;
          if (this.isWebGLRenderer = !0,
          null !== i) {
              if ("undefined" != typeof WebGLRenderingContext && i instanceof WebGLRenderingContext)
                  throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
              h = i.getContextAttributes().alpha
          } else
              h = s;
          const d = new Uint32Array(4)
            , p = new Int32Array(4);
          let f = null
            , m = null;
          const g = []
            , v = [];
          this.domElement = t,
          this.debug = {
              checkShaderErrors: !0,
              onShaderError: null
          },
          this.autoClear = !0,
          this.autoClearColor = !0,
          this.autoClearDepth = !0,
          this.autoClearStencil = !0,
          this.sortObjects = !0,
          this.clippingPlanes = [],
          this.localClippingEnabled = !1,
          this._outputColorSpace = Rh,
          this.toneMapping = au,
          this.toneMappingExposure = 1;
          const _ = this;
          let y = !1
            , x = 0
            , S = 0
            , E = null
            , M = -1
            , b = null;
          const T = new xd
            , w = new xd;
          let D = null;
          const C = new Xp(0);
          let A = 0
            , P = t.width
            , R = t.height
            , L = 1
            , I = null
            , N = null;
          const F = new xd(0,0,P,R)
            , O = new xd(0,0,P,R);
          let U = !1;
          const B = new $f;
          let z = !1
            , k = !1;
          const V = new ip
            , H = new wd
            , G = new xd
            , W = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0
          };
          let X = !1;
          function q() {
              return null === E ? L : 1
          }
          let j, Y, K, Z, $, J, Q, ee, te, ie, ne, re, se, ae, oe, le, ce, ue, he, de, pe, fe, me, ge, ve = i;
          function _e(e, i) {
              return t.getContext(e, i)
          }
          try {
              const e = {
                  alpha: !0,
                  depth: n,
                  stencil: r,
                  antialias: a,
                  premultipliedAlpha: o,
                  preserveDrawingBuffer: l,
                  powerPreference: c,
                  failIfMajorPerformanceCaveat: u
              };
              if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${Jc}`),
              t.addEventListener("webglcontextlost", Se, !1),
              t.addEventListener("webglcontextrestored", Ee, !1),
              t.addEventListener("webglcontextcreationerror", Me, !1),
              null === ve) {
                  const t = "webgl2";
                  if (ve = _e(t, e),
                  null === ve)
                      throw _e(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
              }
          } catch (e) {
              throw console.error("THREE.WebGLRenderer: " + e.message),
              e
          }
          function ye() {
              j = new Pm(ve),
              j.init(),
              fe = new Cv(ve,j),
              Y = new um(ve,j,e,fe),
              K = new Tv(ve),
              Z = new Im(ve),
              $ = new hv,
              J = new Dv(ve,j,K,$,Y,fe,Z),
              Q = new dm(_),
              ee = new Am(_),
              te = new Qf(ve),
              me = new lm(ve,te),
              ie = new Rm(ve,te,Z,me),
              ne = new Fm(ve,ie,te,Z),
              he = new Nm(ve,Y,J),
              le = new hm($),
              re = new uv(_,Q,ee,j,Y,me,le),
              se = new Uv(_,$),
              ae = new mv,
              oe = new Sv(j),
              ue = new om(_,Q,ee,K,ne,h,o),
              ce = new bv(_,ne,Y),
              ge = new Bv(ve,Z,Y,K),
              de = new cm(ve,j,Z),
              pe = new Lm(ve,j,Z),
              Z.programs = re.programs,
              _.capabilities = Y,
              _.extensions = j,
              _.properties = $,
              _.renderLists = ae,
              _.shadowMap = ce,
              _.state = K,
              _.info = Z
          }
          ye();
          const xe = new Nv(_,ve);
          function Se(e) {
              e.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              y = !0
          }
          function Ee() {
              console.log("THREE.WebGLRenderer: Context Restored."),
              y = !1;
              const e = Z.autoReset
                , t = ce.enabled
                , i = ce.autoUpdate
                , n = ce.needsUpdate
                , r = ce.type;
              ye(),
              Z.autoReset = e,
              ce.enabled = t,
              ce.autoUpdate = i,
              ce.needsUpdate = n,
              ce.type = r
          }
          function Me(e) {
              console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
          }
          function be(e) {
              const t = e.target;
              t.removeEventListener("dispose", be),
              function(e) {
                  (function(e) {
                      const t = $.get(e).programs;
                      void 0 !== t && (t.forEach((function(e) {
                          re.releaseProgram(e)
                      }
                      )),
                      e.isShaderMaterial && re.releaseShaderCache(e))
                  }
                  )(e),
                  $.remove(e)
              }(t)
          }
          function Te(e, t, i) {
              !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1,
              e.needsUpdate = !0,
              Fe(e, t, i),
              e.side = 0,
              e.needsUpdate = !0,
              Fe(e, t, i),
              e.side = 2) : Fe(e, t, i)
          }
          this.xr = xe,
          this.getContext = function() {
              return ve
          }
          ,
          this.getContextAttributes = function() {
              return ve.getContextAttributes()
          }
          ,
          this.forceContextLoss = function() {
              const e = j.get("WEBGL_lose_context");
              e && e.loseContext()
          }
          ,
          this.forceContextRestore = function() {
              const e = j.get("WEBGL_lose_context");
              e && e.restoreContext()
          }
          ,
          this.getPixelRatio = function() {
              return L
          }
          ,
          this.setPixelRatio = function(e) {
              void 0 !== e && (L = e,
              this.setSize(P, R, !1))
          }
          ,
          this.getSize = function(e) {
              return e.set(P, R)
          }
          ,
          this.setSize = function(e, i, n=!0) {
              xe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (P = e,
              R = i,
              t.width = Math.floor(e * L),
              t.height = Math.floor(i * L),
              !0 === n && (t.style.width = e + "px",
              t.style.height = i + "px"),
              this.setViewport(0, 0, e, i))
          }
          ,
          this.getDrawingBufferSize = function(e) {
              return e.set(P * L, R * L).floor()
          }
          ,
          this.setDrawingBufferSize = function(e, i, n) {
              P = e,
              R = i,
              L = n,
              t.width = Math.floor(e * n),
              t.height = Math.floor(i * n),
              this.setViewport(0, 0, e, i)
          }
          ,
          this.getCurrentViewport = function(e) {
              return e.copy(T)
          }
          ,
          this.getViewport = function(e) {
              return e.copy(F)
          }
          ,
          this.setViewport = function(e, t, i, n) {
              e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, i, n),
              K.viewport(T.copy(F).multiplyScalar(L).round())
          }
          ,
          this.getScissor = function(e) {
              return e.copy(O)
          }
          ,
          this.setScissor = function(e, t, i, n) {
              e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, i, n),
              K.scissor(w.copy(O).multiplyScalar(L).round())
          }
          ,
          this.getScissorTest = function() {
              return U
          }
          ,
          this.setScissorTest = function(e) {
              K.setScissorTest(U = e)
          }
          ,
          this.setOpaqueSort = function(e) {
              I = e
          }
          ,
          this.setTransparentSort = function(e) {
              N = e
          }
          ,
          this.getClearColor = function(e) {
              return e.copy(ue.getClearColor())
          }
          ,
          this.setClearColor = function() {
              ue.setClearColor.apply(ue, arguments)
          }
          ,
          this.getClearAlpha = function() {
              return ue.getClearAlpha()
          }
          ,
          this.setClearAlpha = function() {
              ue.setClearAlpha.apply(ue, arguments)
          }
          ,
          this.clear = function(e=!0, t=!0, i=!0) {
              let n = 0;
              if (e) {
                  let e = !1;
                  if (null !== E) {
                      const t = E.texture.format;
                      e = t === Yu || t === ju || t === Xu
                  }
                  if (e) {
                      const e = E.texture.type
                        , t = e === Tu || e === Pu || e === Cu || e === Fu || e === Iu || e === Nu
                        , i = ue.getClearColor()
                        , n = ue.getClearAlpha()
                        , r = i.r
                        , s = i.g
                        , a = i.b;
                      t ? (d[0] = r,
                      d[1] = s,
                      d[2] = a,
                      d[3] = n,
                      ve.clearBufferuiv(ve.COLOR, 0, d)) : (p[0] = r,
                      p[1] = s,
                      p[2] = a,
                      p[3] = n,
                      ve.clearBufferiv(ve.COLOR, 0, p))
                  } else
                      n |= ve.COLOR_BUFFER_BIT
              }
              t && (n |= ve.DEPTH_BUFFER_BIT),
              i && (n |= ve.STENCIL_BUFFER_BIT,
              this.state.buffers.stencil.setMask(4294967295)),
              ve.clear(n)
          }
          ,
          this.clearColor = function() {
              this.clear(!0, !1, !1)
          }
          ,
          this.clearDepth = function() {
              this.clear(!1, !0, !1)
          }
          ,
          this.clearStencil = function() {
              this.clear(!1, !1, !0)
          }
          ,
          this.dispose = function() {
              t.removeEventListener("webglcontextlost", Se, !1),
              t.removeEventListener("webglcontextrestored", Ee, !1),
              t.removeEventListener("webglcontextcreationerror", Me, !1),
              ae.dispose(),
              oe.dispose(),
              $.dispose(),
              Q.dispose(),
              ee.dispose(),
              ne.dispose(),
              me.dispose(),
              ge.dispose(),
              re.dispose(),
              xe.dispose(),
              xe.removeEventListener("sessionstart", De),
              xe.removeEventListener("sessionend", Ce),
              Ae.stop()
          }
          ,
          this.renderBufferDirect = function(e, t, i, n, r, s) {
              null === t && (t = W);
              const a = r.isMesh && r.matrixWorld.determinant() < 0
                , o = function(e, t, i, n, r) {
                  !0 !== t.isScene && (t = W),
                  J.resetTextureUnits();
                  const s = t.fog
                    , a = n.isMeshStandardMaterial ? t.environment : null
                    , o = null === E ? _.outputColorSpace : !0 === E.isXRRenderTarget ? E.texture.colorSpace : Lh
                    , l = (n.isMeshStandardMaterial ? ee : Q).get(n.envMap || a)
                    , c = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize
                    , u = !!i.attributes.tangent && (!!n.normalMap || n.anisotropy > 0)
                    , h = !!i.morphAttributes.position
                    , d = !!i.morphAttributes.normal
                    , p = !!i.morphAttributes.color;
                  let f = au;
                  n.toneMapped && (null !== E && !0 !== E.isXRRenderTarget || (f = _.toneMapping));
                  const g = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color
                    , v = void 0 !== g ? g.length : 0
                    , y = $.get(n)
                    , x = m.state.lights;
                  if (!0 === z && (!0 === k || e !== b)) {
                      const t = e === b && n.id === M;
                      le.setState(n, e, t)
                  }
                  let S = !1;
                  n.version === y.__version ? y.needsLights && y.lightsStateVersion !== x.state.version || y.outputColorSpace !== o || r.isBatchedMesh && !1 === y.batching ? S = !0 : r.isBatchedMesh || !0 !== y.batching ? r.isBatchedMesh && !0 === y.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === y.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === y.instancing ? S = !0 : r.isInstancedMesh || !0 !== y.instancing ? r.isSkinnedMesh && !1 === y.skinning ? S = !0 : r.isSkinnedMesh || !0 !== y.skinning ? r.isInstancedMesh && !0 === y.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === y.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === y.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === y.instancingMorph && null !== r.morphTexture || y.envMap !== l || !0 === n.fog && y.fog !== s ? S = !0 : void 0 === y.numClippingPlanes || y.numClippingPlanes === le.numPlanes && y.numIntersection === le.numIntersection ? (y.vertexAlphas !== c || y.vertexTangents !== u || y.morphTargets !== h || y.morphNormals !== d || y.morphColors !== p || y.toneMapping !== f || y.morphTargetsCount !== v) && (S = !0) : S = !0 : S = !0 : S = !0 : S = !0 : (S = !0,
                  y.__version = n.version);
                  let T = y.currentProgram;
                  !0 === S && (T = Fe(n, t, r));
                  let w = !1
                    , D = !1
                    , C = !1;
                  const A = T.getUniforms()
                    , P = y.uniforms;
                  if (K.useProgram(T.program) && (w = !0,
                  D = !0,
                  C = !0),
                  n.id !== M && (M = n.id,
                  D = !0),
                  w || b !== e) {
                      A.setValue(ve, "projectionMatrix", e.projectionMatrix),
                      A.setValue(ve, "viewMatrix", e.matrixWorldInverse);
                      const t = A.map.cameraPosition;
                      void 0 !== t && t.setValue(ve, H.setFromMatrixPosition(e.matrixWorld)),
                      Y.logarithmicDepthBuffer && A.setValue(ve, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                      (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && A.setValue(ve, "isOrthographic", !0 === e.isOrthographicCamera),
                      b !== e && (b = e,
                      D = !0,
                      C = !0)
                  }
                  if (r.isSkinnedMesh) {
                      A.setOptional(ve, r, "bindMatrix"),
                      A.setOptional(ve, r, "bindMatrixInverse");
                      const e = r.skeleton;
                      e && (null === e.boneTexture && e.computeBoneTexture(),
                      A.setValue(ve, "boneTexture", e.boneTexture, J))
                  }
                  r.isBatchedMesh && (A.setOptional(ve, r, "batchingTexture"),
                  A.setValue(ve, "batchingTexture", r._matricesTexture, J),
                  A.setOptional(ve, r, "batchingIdTexture"),
                  A.setValue(ve, "batchingIdTexture", r._indirectTexture, J),
                  A.setOptional(ve, r, "batchingColorTexture"),
                  null !== r._colorsTexture && A.setValue(ve, "batchingColorTexture", r._colorsTexture, J));
                  const I = i.morphAttributes;
                  var N, F;
                  if (void 0 === I.position && void 0 === I.normal && void 0 === I.color || he.update(r, i, T),
                  (D || y.receiveShadow !== r.receiveShadow) && (y.receiveShadow = r.receiveShadow,
                  A.setValue(ve, "receiveShadow", r.receiveShadow)),
                  n.isMeshGouraudMaterial && null !== n.envMap && (P.envMap.value = l,
                  P.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1),
                  n.isMeshStandardMaterial && null === n.envMap && null !== t.environment && (P.envMapIntensity.value = t.environmentIntensity),
                  D && (A.setValue(ve, "toneMappingExposure", _.toneMappingExposure),
                  y.needsLights && (F = C,
                  (N = P).ambientLightColor.needsUpdate = F,
                  N.lightProbe.needsUpdate = F,
                  N.directionalLights.needsUpdate = F,
                  N.directionalLightShadows.needsUpdate = F,
                  N.pointLights.needsUpdate = F,
                  N.pointLightShadows.needsUpdate = F,
                  N.spotLights.needsUpdate = F,
                  N.spotLightShadows.needsUpdate = F,
                  N.rectAreaLights.needsUpdate = F,
                  N.hemisphereLights.needsUpdate = F),
                  s && !0 === n.fog && se.refreshFogUniforms(P, s),
                  se.refreshMaterialUniforms(P, n, L, R, m.state.transmissionRenderTarget[e.id]),
                  Vg.upload(ve, Oe(y), P, J)),
                  n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Vg.upload(ve, Oe(y), P, J),
                  n.uniformsNeedUpdate = !1),
                  n.isSpriteMaterial && A.setValue(ve, "center", r.center),
                  A.setValue(ve, "modelViewMatrix", r.modelViewMatrix),
                  A.setValue(ve, "normalMatrix", r.normalMatrix),
                  A.setValue(ve, "modelMatrix", r.matrixWorld),
                  n.isShaderMaterial || n.isRawShaderMaterial) {
                      const e = n.uniformsGroups;
                      for (let t = 0, i = e.length; t < i; t++) {
                          const i = e[t];
                          ge.update(i, T),
                          ge.bind(i, T)
                      }
                  }
                  return T
              }(e, t, i, n, r);
              K.setMaterial(n, a);
              let l = i.index
                , c = 1;
              if (!0 === n.wireframe) {
                  if (l = ie.getWireframeAttribute(i),
                  void 0 === l)
                      return;
                  c = 2
              }
              const u = i.drawRange
                , h = i.attributes.position;
              let d = u.start * c
                , p = (u.start + u.count) * c;
              null !== s && (d = Math.max(d, s.start * c),
              p = Math.min(p, (s.start + s.count) * c)),
              null !== l ? (d = Math.max(d, 0),
              p = Math.min(p, l.count)) : null != h && (d = Math.max(d, 0),
              p = Math.min(p, h.count));
              const f = p - d;
              if (f < 0 || f === 1 / 0)
                  return;
              let g;
              me.setup(r, n, o, i, l);
              let v = de;
              if (null !== l && (g = te.get(l),
              v = pe,
              v.setIndex(g)),
              r.isMesh)
                  !0 === n.wireframe ? (K.setLineWidth(n.wireframeLinewidth * q()),
                  v.setMode(ve.LINES)) : v.setMode(ve.TRIANGLES);
              else if (r.isLine) {
                  let e = n.linewidth;
                  void 0 === e && (e = 1),
                  K.setLineWidth(e * q()),
                  r.isLineSegments ? v.setMode(ve.LINES) : r.isLineLoop ? v.setMode(ve.LINE_LOOP) : v.setMode(ve.LINE_STRIP)
              } else
                  r.isPoints ? v.setMode(ve.POINTS) : r.isSprite && v.setMode(ve.TRIANGLES);
              if (r.isBatchedMesh)
                  if (null !== r._multiDrawInstances)
                      v.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances);
                  else if (j.get("WEBGL_multi_draw"))
                      v.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                  else {
                      const e = r._multiDrawStarts
                        , t = r._multiDrawCounts
                        , i = r._multiDrawCount
                        , s = l ? te.get(l).bytesPerElement : 1
                        , a = $.get(n).currentProgram.getUniforms();
                      for (let n = 0; n < i; n++)
                          a.setValue(ve, "_gl_DrawID", n),
                          v.render(e[n] / s, t[n])
                  }
              else if (r.isInstancedMesh)
                  v.renderInstances(d, f, r.count);
              else if (i.isInstancedBufferGeometry) {
                  const e = void 0 !== i._maxInstanceCount ? i._maxInstanceCount : 1 / 0
                    , t = Math.min(i.instanceCount, e);
                  v.renderInstances(d, f, t)
              } else
                  v.render(d, f)
          }
          ,
          this.compile = function(e, t, i=null) {
              null === i && (i = e),
              m = oe.get(i),
              m.init(t),
              v.push(m),
              i.traverseVisible((function(e) {
                  e.isLight && e.layers.test(t.layers) && (m.pushLight(e),
                  e.castShadow && m.pushShadow(e))
              }
              )),
              e !== i && e.traverseVisible((function(e) {
                  e.isLight && e.layers.test(t.layers) && (m.pushLight(e),
                  e.castShadow && m.pushShadow(e))
              }
              )),
              m.setupLights();
              const n = new Set;
              return e.traverse((function(e) {
                  const t = e.material;
                  if (t)
                      if (Array.isArray(t))
                          for (let r = 0; r < t.length; r++) {
                              const s = t[r];
                              Te(s, i, e),
                              n.add(s)
                          }
                      else
                          Te(t, i, e),
                          n.add(t)
              }
              )),
              v.pop(),
              m = null,
              n
          }
          ,
          this.compileAsync = function(e, t, i=null) {
              const n = this.compile(e, t, i);
              return new Promise((t => {
                  function i() {
                      n.forEach((function(e) {
                          $.get(e).currentProgram.isReady() && n.delete(e)
                      }
                      )),
                      0 !== n.size ? setTimeout(i, 10) : t(e)
                  }
                  null !== j.get("KHR_parallel_shader_compile") ? i() : setTimeout(i, 10)
              }
              ))
          }
          ;
          let we = null;
          function De() {
              Ae.stop()
          }
          function Ce() {
              Ae.start()
          }
          const Ae = new Jf;
          function Pe(e, t, i, n) {
              if (!1 === e.visible)
                  return;
              if (e.layers.test(t.layers))
                  if (e.isGroup)
                      i = e.renderOrder;
                  else if (e.isLOD)
                      !0 === e.autoUpdate && e.update(t);
                  else if (e.isLight)
                      m.pushLight(e),
                      e.castShadow && m.pushShadow(e);
                  else if (e.isSprite) {
                      if (!e.frustumCulled || B.intersectsSprite(e)) {
                          n && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                          const t = ne.update(e)
                            , r = e.material;
                          r.visible && f.push(e, t, r, i, G.z, null)
                      }
                  } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || B.intersectsObject(e))) {
                      const t = ne.update(e)
                        , r = e.material;
                      if (n && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(),
                      G.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(),
                      G.copy(t.boundingSphere.center)),
                      G.applyMatrix4(e.matrixWorld).applyMatrix4(V)),
                      Array.isArray(r)) {
                          const n = t.groups;
                          for (let s = 0, a = n.length; s < a; s++) {
                              const a = n[s]
                                , o = r[a.materialIndex];
                              o && o.visible && f.push(e, t, o, i, G.z, a)
                          }
                      } else
                          r.visible && f.push(e, t, r, i, G.z, null)
                  }
              const r = e.children;
              for (let e = 0, s = r.length; e < s; e++)
                  Pe(r[e], t, i, n)
          }
          function Re(e, t, i, n) {
              const r = e.opaque
                , s = e.transmissive
                , a = e.transparent;
              m.setupLightsView(i),
              !0 === z && le.setGlobalState(_.clippingPlanes, i),
              n && K.viewport(T.copy(n)),
              r.length > 0 && Ie(r, t, i),
              s.length > 0 && Ie(s, t, i),
              a.length > 0 && Ie(a, t, i),
              K.buffers.depth.setTest(!0),
              K.buffers.depth.setMask(!0),
              K.buffers.color.setMask(!0),
              K.setPolygonOffset(!1)
          }
          function Le(e, t, i, n) {
              if (null !== (!0 === i.isScene ? i.overrideMaterial : null))
                  return;
              void 0 === m.state.transmissionRenderTarget[n.id] && (m.state.transmissionRenderTarget[n.id] = new Ed(1,1,{
                  generateMipmaps: !0,
                  type: j.has("EXT_color_buffer_half_float") || j.has("EXT_color_buffer_float") ? Lu : Tu,
                  minFilter: bu,
                  samples: 4,
                  stencilBuffer: r,
                  resolveDepthBuffer: !1,
                  resolveStencilBuffer: !1,
                  colorSpace: ud.workingColorSpace
              }));
              const s = m.state.transmissionRenderTarget[n.id]
                , a = n.viewport || T;
              s.setSize(a.z, a.w);
              const o = _.getRenderTarget();
              _.setRenderTarget(s),
              _.getClearColor(C),
              A = _.getClearAlpha(),
              A < 1 && _.setClearColor(16777215, .5),
              _.clear(),
              X && ue.render(i);
              const l = _.toneMapping;
              _.toneMapping = au;
              const c = n.viewport;
              if (void 0 !== n.viewport && (n.viewport = void 0),
              m.setupLightsView(n),
              !0 === z && le.setGlobalState(_.clippingPlanes, n),
              Ie(e, i, n),
              J.updateMultisampleRenderTarget(s),
              J.updateRenderTargetMipmap(s),
              !1 === j.has("WEBGL_multisampled_render_to_texture")) {
                  let e = !1;
                  for (let r = 0, s = t.length; r < s; r++) {
                      const s = t[r]
                        , a = s.object
                        , o = s.geometry
                        , l = s.material
                        , c = s.group;
                      if (2 === l.side && a.layers.test(n.layers)) {
                          const t = l.side;
                          l.side = 1,
                          l.needsUpdate = !0,
                          Ne(a, i, n, o, l, c),
                          l.side = t,
                          l.needsUpdate = !0,
                          e = !0
                      }
                  }
                  !0 === e && (J.updateMultisampleRenderTarget(s),
                  J.updateRenderTargetMipmap(s))
              }
              _.setRenderTarget(o),
              _.setClearColor(C, A),
              void 0 !== c && (n.viewport = c),
              _.toneMapping = l
          }
          function Ie(e, t, i) {
              const n = !0 === t.isScene ? t.overrideMaterial : null;
              for (let r = 0, s = e.length; r < s; r++) {
                  const s = e[r]
                    , a = s.object
                    , o = s.geometry
                    , l = null === n ? s.material : n
                    , c = s.group;
                  a.layers.test(i.layers) && Ne(a, t, i, o, l, c)
              }
          }
          function Ne(e, t, i, n, r, s) {
              e.onBeforeRender(_, t, i, n, r, s),
              e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld),
              e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
              !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1,
              r.needsUpdate = !0,
              _.renderBufferDirect(i, t, n, r, e, s),
              r.side = 0,
              r.needsUpdate = !0,
              _.renderBufferDirect(i, t, n, r, e, s),
              r.side = 2) : _.renderBufferDirect(i, t, n, r, e, s),
              e.onAfterRender(_, t, i, n, r, s)
          }
          function Fe(e, t, i) {
              !0 !== t.isScene && (t = W);
              const n = $.get(e)
                , r = m.state.lights
                , s = m.state.shadowsArray
                , a = r.state.version
                , o = re.getParameters(e, r.state, s, t, i)
                , l = re.getProgramCacheKey(o);
              let c = n.programs;
              n.environment = e.isMeshStandardMaterial ? t.environment : null,
              n.fog = t.fog,
              n.envMap = (e.isMeshStandardMaterial ? ee : Q).get(e.envMap || n.environment),
              n.envMapRotation = null !== n.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation,
              void 0 === c && (e.addEventListener("dispose", be),
              c = new Map,
              n.programs = c);
              let u = c.get(l);
              if (void 0 !== u) {
                  if (n.currentProgram === u && n.lightsStateVersion === a)
                      return Ue(e, o),
                      u
              } else
                  o.uniforms = re.getUniforms(e),
                  e.onBeforeCompile(o, _),
                  u = re.acquireProgram(o, l),
                  c.set(l, u),
                  n.uniforms = o.uniforms;
              const h = n.uniforms;
              return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = le.uniform),
              Ue(e, o),
              n.needsLights = function(e) {
                  return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
              }(e),
              n.lightsStateVersion = a,
              n.needsLights && (h.ambientLightColor.value = r.state.ambient,
              h.lightProbe.value = r.state.probe,
              h.directionalLights.value = r.state.directional,
              h.directionalLightShadows.value = r.state.directionalShadow,
              h.spotLights.value = r.state.spot,
              h.spotLightShadows.value = r.state.spotShadow,
              h.rectAreaLights.value = r.state.rectArea,
              h.ltc_1.value = r.state.rectAreaLTC1,
              h.ltc_2.value = r.state.rectAreaLTC2,
              h.pointLights.value = r.state.point,
              h.pointLightShadows.value = r.state.pointShadow,
              h.hemisphereLights.value = r.state.hemi,
              h.directionalShadowMap.value = r.state.directionalShadowMap,
              h.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
              h.spotShadowMap.value = r.state.spotShadowMap,
              h.spotLightMatrix.value = r.state.spotLightMatrix,
              h.spotLightMap.value = r.state.spotLightMap,
              h.pointShadowMap.value = r.state.pointShadowMap,
              h.pointShadowMatrix.value = r.state.pointShadowMatrix),
              n.currentProgram = u,
              n.uniformsList = null,
              u
          }
          function Oe(e) {
              if (null === e.uniformsList) {
                  const t = e.currentProgram.getUniforms();
                  e.uniformsList = Vg.seqWithValue(t.seq, e.uniforms)
              }
              return e.uniformsList
          }
          function Ue(e, t) {
              const i = $.get(e);
              i.outputColorSpace = t.outputColorSpace,
              i.batching = t.batching,
              i.batchingColor = t.batchingColor,
              i.instancing = t.instancing,
              i.instancingColor = t.instancingColor,
              i.instancingMorph = t.instancingMorph,
              i.skinning = t.skinning,
              i.morphTargets = t.morphTargets,
              i.morphNormals = t.morphNormals,
              i.morphColors = t.morphColors,
              i.morphTargetsCount = t.morphTargetsCount,
              i.numClippingPlanes = t.numClippingPlanes,
              i.numIntersection = t.numClipIntersection,
              i.vertexAlphas = t.vertexAlphas,
              i.vertexTangents = t.vertexTangents,
              i.toneMapping = t.toneMapping
          }
          Ae.setAnimationLoop((function(e) {
              we && we(e)
          }
          )),
          "undefined" != typeof self && Ae.setContext(self),
          this.setAnimationLoop = function(e) {
              we = e,
              xe.setAnimationLoop(e),
              null === e ? Ae.stop() : Ae.start()
          }
          ,
          xe.addEventListener("sessionstart", De),
          xe.addEventListener("sessionend", Ce),
          this.render = function(e, t) {
              if (void 0 !== t && !0 !== t.isCamera)
                  return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
              if (!0 === y)
                  return;
              if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
              null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
              !0 === xe.enabled && !0 === xe.isPresenting && (!0 === xe.cameraAutoUpdate && xe.updateCamera(t),
              t = xe.getCamera()),
              !0 === e.isScene && e.onBeforeRender(_, e, t, E),
              m = oe.get(e, v.length),
              m.init(t),
              v.push(m),
              V.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
              B.setFromProjectionMatrix(V),
              k = this.localClippingEnabled,
              z = le.init(this.clippingPlanes, k),
              f = ae.get(e, g.length),
              f.init(),
              g.push(f),
              !0 === xe.enabled && !0 === xe.isPresenting) {
                  const e = _.xr.getDepthSensingMesh();
                  null !== e && Pe(e, t, -1 / 0, _.sortObjects)
              }
              Pe(e, t, 0, _.sortObjects),
              f.finish(),
              !0 === _.sortObjects && f.sort(I, N),
              X = !1 === xe.enabled || !1 === xe.isPresenting || !1 === xe.hasDepthSensing(),
              X && ue.addToRenderList(f, e),
              this.info.render.frame++,
              !0 === z && le.beginShadows();
              const i = m.state.shadowsArray;
              ce.render(i, e, t),
              !0 === z && le.endShadows(),
              !0 === this.info.autoReset && this.info.reset();
              const n = f.opaque
                , r = f.transmissive;
              if (m.setupLights(),
              t.isArrayCamera) {
                  const i = t.cameras;
                  if (r.length > 0)
                      for (let t = 0, s = i.length; t < s; t++)
                          Le(n, r, e, i[t]);
                  X && ue.render(e);
                  for (let t = 0, n = i.length; t < n; t++) {
                      const n = i[t];
                      Re(f, e, n, n.viewport)
                  }
              } else
                  r.length > 0 && Le(n, r, e, t),
                  X && ue.render(e),
                  Re(f, e, t);
              null !== E && (J.updateMultisampleRenderTarget(E),
              J.updateRenderTargetMipmap(E)),
              !0 === e.isScene && e.onAfterRender(_, e, t),
              me.resetDefaultState(),
              M = -1,
              b = null,
              v.pop(),
              v.length > 0 ? (m = v[v.length - 1],
              !0 === z && le.setGlobalState(_.clippingPlanes, m.state.camera)) : m = null,
              g.pop(),
              f = g.length > 0 ? g[g.length - 1] : null
          }
          ,
          this.getActiveCubeFace = function() {
              return x
          }
          ,
          this.getActiveMipmapLevel = function() {
              return S
          }
          ,
          this.getRenderTarget = function() {
              return E
          }
          ,
          this.setRenderTargetTextures = function(e, t, i) {
              $.get(e.texture).__webglTexture = t,
              $.get(e.depthTexture).__webglTexture = i;
              const n = $.get(e);
              n.__hasExternalTextures = !0,
              n.__autoAllocateDepthBuffer = void 0 === i,
              n.__autoAllocateDepthBuffer || !0 === j.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
              n.__useRenderToTexture = !1)
          }
          ,
          this.setRenderTargetFramebuffer = function(e, t) {
              const i = $.get(e);
              i.__webglFramebuffer = t,
              i.__useDefaultFramebuffer = void 0 === t
          }
          ,
          this.setRenderTarget = function(e, t=0, i=0) {
              E = e,
              x = t,
              S = i;
              let n = !0
                , r = null
                , s = !1
                , a = !1;
              if (e) {
                  const o = $.get(e);
                  void 0 !== o.__useDefaultFramebuffer ? (K.bindFramebuffer(ve.FRAMEBUFFER, null),
                  n = !1) : void 0 === o.__webglFramebuffer ? J.setupRenderTarget(e) : o.__hasExternalTextures && J.rebindTextures(e, $.get(e.texture).__webglTexture, $.get(e.depthTexture).__webglTexture);
                  const l = e.texture;
                  (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0);
                  const c = $.get(e).__webglFramebuffer;
                  e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][i] : c[t],
                  s = !0) : r = e.samples > 0 && !1 === J.useMultisampledRTT(e) ? $.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[i] : c,
                  T.copy(e.viewport),
                  w.copy(e.scissor),
                  D = e.scissorTest
              } else
                  T.copy(F).multiplyScalar(L).floor(),
                  w.copy(O).multiplyScalar(L).floor(),
                  D = U;
              if (K.bindFramebuffer(ve.FRAMEBUFFER, r) && n && K.drawBuffers(e, r),
              K.viewport(T),
              K.scissor(w),
              K.setScissorTest(D),
              s) {
                  const n = $.get(e.texture);
                  ve.framebufferTexture2D(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, ve.TEXTURE_CUBE_MAP_POSITIVE_X + t, n.__webglTexture, i)
              } else if (a) {
                  const n = $.get(e.texture)
                    , r = t || 0;
                  ve.framebufferTextureLayer(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, n.__webglTexture, i || 0, r)
              }
              M = -1
          }
          ,
          this.readRenderTargetPixels = function(e, t, i, n, r, s, a) {
              if (!e || !e.isWebGLRenderTarget)
                  return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              let o = $.get(e).__webglFramebuffer;
              if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
              o) {
                  K.bindFramebuffer(ve.FRAMEBUFFER, o);
                  try {
                      const a = e.texture
                        , o = a.format
                        , l = a.type;
                      if (!Y.textureFormatReadable(o))
                          return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                      if (!Y.textureTypeReadable(l))
                          return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                      t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r && ve.readPixels(t, i, n, r, fe.convert(o), fe.convert(l), s)
                  } finally {
                      const e = null !== E ? $.get(E).__webglFramebuffer : null;
                      K.bindFramebuffer(ve.FRAMEBUFFER, e)
                  }
              }
          }
          ,
          this.readRenderTargetPixelsAsync = async function(e, t, i, n, r, s, a) {
              if (!e || !e.isWebGLRenderTarget)
                  throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              let o = $.get(e).__webglFramebuffer;
              if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
              o) {
                  K.bindFramebuffer(ve.FRAMEBUFFER, o);
                  try {
                      const a = e.texture
                        , o = a.format
                        , l = a.type;
                      if (!Y.textureFormatReadable(o))
                          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                      if (!Y.textureTypeReadable(l))
                          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                      if (t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r) {
                          const e = ve.createBuffer();
                          ve.bindBuffer(ve.PIXEL_PACK_BUFFER, e),
                          ve.bufferData(ve.PIXEL_PACK_BUFFER, s.byteLength, ve.STREAM_READ),
                          ve.readPixels(t, i, n, r, fe.convert(o), fe.convert(l), 0),
                          ve.flush();
                          const a = ve.fenceSync(ve.SYNC_GPU_COMMANDS_COMPLETE, 0);
                          await function(e, t, i) {
                              return new Promise((function(i, n) {
                                  setTimeout((function r() {
                                      switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                      case e.WAIT_FAILED:
                                          n();
                                          break;
                                      case e.TIMEOUT_EXPIRED:
                                          setTimeout(r, 4);
                                          break;
                                      default:
                                          i()
                                      }
                                  }
                                  ), 4)
                              }
                              ))
                          }(ve, a);
                          try {
                              ve.bindBuffer(ve.PIXEL_PACK_BUFFER, e),
                              ve.getBufferSubData(ve.PIXEL_PACK_BUFFER, 0, s)
                          } finally {
                              ve.deleteBuffer(e),
                              ve.deleteSync(a)
                          }
                          return s
                      }
                  } finally {
                      const e = null !== E ? $.get(E).__webglFramebuffer : null;
                      K.bindFramebuffer(ve.FRAMEBUFFER, e)
                  }
              }
          }
          ,
          this.copyFramebufferToTexture = function(e, t=null, i=0) {
              !0 !== e.isTexture && (sd("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
              t = arguments[0] || null,
              e = arguments[1]);
              const n = Math.pow(2, -i)
                , r = Math.floor(e.image.width * n)
                , s = Math.floor(e.image.height * n)
                , a = null !== t ? t.x : 0
                , o = null !== t ? t.y : 0;
              J.setTexture2D(e, 0),
              ve.copyTexSubImage2D(ve.TEXTURE_2D, i, 0, 0, a, o, r, s),
              K.unbindTexture()
          }
          ,
          this.copyTextureToTexture = function(e, t, i=null, n=null, r=0) {
              let s, a, o, l, c, u;
              !0 !== e.isTexture && (sd("WebGLRenderer: copyTextureToTexture function signature has changed."),
              n = arguments[0] || null,
              e = arguments[1],
              t = arguments[2],
              r = arguments[3] || 0,
              i = null),
              null !== i ? (s = i.max.x - i.min.x,
              a = i.max.y - i.min.y,
              o = i.min.x,
              l = i.min.y) : (s = e.image.width,
              a = e.image.height,
              o = 0,
              l = 0),
              null !== n ? (c = n.x,
              u = n.y) : (c = 0,
              u = 0);
              const h = fe.convert(t.format)
                , d = fe.convert(t.type);
              J.setTexture2D(t, 0),
              ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, t.flipY),
              ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
              ve.pixelStorei(ve.UNPACK_ALIGNMENT, t.unpackAlignment);
              const p = ve.getParameter(ve.UNPACK_ROW_LENGTH)
                , f = ve.getParameter(ve.UNPACK_IMAGE_HEIGHT)
                , m = ve.getParameter(ve.UNPACK_SKIP_PIXELS)
                , g = ve.getParameter(ve.UNPACK_SKIP_ROWS)
                , v = ve.getParameter(ve.UNPACK_SKIP_IMAGES)
                , _ = e.isCompressedTexture ? e.mipmaps[r] : e.image;
              ve.pixelStorei(ve.UNPACK_ROW_LENGTH, _.width),
              ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, _.height),
              ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, o),
              ve.pixelStorei(ve.UNPACK_SKIP_ROWS, l),
              e.isDataTexture ? ve.texSubImage2D(ve.TEXTURE_2D, r, c, u, s, a, h, d, _.data) : e.isCompressedTexture ? ve.compressedTexSubImage2D(ve.TEXTURE_2D, r, c, u, _.width, _.height, h, _.data) : ve.texSubImage2D(ve.TEXTURE_2D, r, c, u, s, a, h, d, _),
              ve.pixelStorei(ve.UNPACK_ROW_LENGTH, p),
              ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, f),
              ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, m),
              ve.pixelStorei(ve.UNPACK_SKIP_ROWS, g),
              ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, v),
              0 === r && t.generateMipmaps && ve.generateMipmap(ve.TEXTURE_2D),
              K.unbindTexture()
          }
          ,
          this.copyTextureToTexture3D = function(e, t, i=null, n=null, r=0) {
              let s, a, o, l, c, u, h, d, p;
              !0 !== e.isTexture && (sd("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
              i = arguments[0] || null,
              n = arguments[1] || null,
              e = arguments[2],
              t = arguments[3],
              r = arguments[4] || 0);
              const f = e.isCompressedTexture ? e.mipmaps[r] : e.image;
              null !== i ? (s = i.max.x - i.min.x,
              a = i.max.y - i.min.y,
              o = i.max.z - i.min.z,
              l = i.min.x,
              c = i.min.y,
              u = i.min.z) : (s = f.width,
              a = f.height,
              o = f.depth,
              l = 0,
              c = 0,
              u = 0),
              null !== n ? (h = n.x,
              d = n.y,
              p = n.z) : (h = 0,
              d = 0,
              p = 0);
              const m = fe.convert(t.format)
                , g = fe.convert(t.type);
              let v;
              if (t.isData3DTexture)
                  J.setTexture3D(t, 0),
                  v = ve.TEXTURE_3D;
              else {
                  if (!t.isDataArrayTexture && !t.isCompressedArrayTexture)
                      return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                  J.setTexture2DArray(t, 0),
                  v = ve.TEXTURE_2D_ARRAY
              }
              ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, t.flipY),
              ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
              ve.pixelStorei(ve.UNPACK_ALIGNMENT, t.unpackAlignment);
              const _ = ve.getParameter(ve.UNPACK_ROW_LENGTH)
                , y = ve.getParameter(ve.UNPACK_IMAGE_HEIGHT)
                , x = ve.getParameter(ve.UNPACK_SKIP_PIXELS)
                , S = ve.getParameter(ve.UNPACK_SKIP_ROWS)
                , E = ve.getParameter(ve.UNPACK_SKIP_IMAGES);
              ve.pixelStorei(ve.UNPACK_ROW_LENGTH, f.width),
              ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, f.height),
              ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, l),
              ve.pixelStorei(ve.UNPACK_SKIP_ROWS, c),
              ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, u),
              e.isDataTexture || e.isData3DTexture ? ve.texSubImage3D(v, r, h, d, p, s, a, o, m, g, f.data) : t.isCompressedArrayTexture ? ve.compressedTexSubImage3D(v, r, h, d, p, s, a, o, m, f.data) : ve.texSubImage3D(v, r, h, d, p, s, a, o, m, g, f),
              ve.pixelStorei(ve.UNPACK_ROW_LENGTH, _),
              ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, y),
              ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, x),
              ve.pixelStorei(ve.UNPACK_SKIP_ROWS, S),
              ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, E),
              0 === r && t.generateMipmaps && ve.generateMipmap(v),
              K.unbindTexture()
          }
          ,
          this.initRenderTarget = function(e) {
              void 0 === $.get(e).__webglFramebuffer && J.setupRenderTarget(e)
          }
          ,
          this.initTexture = function(e) {
              e.isCubeTexture ? J.setTextureCube(e, 0) : e.isData3DTexture ? J.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? J.setTexture2DArray(e, 0) : J.setTexture2D(e, 0),
              K.unbindTexture()
          }
          ,
          this.resetState = function() {
              x = 0,
              S = 0,
              E = null,
              K.reset(),
              me.reset()
          }
          ,
          "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
              detail: this
          }))
      }
      get coordinateSystem() {
          return Vh
      }
      get outputColorSpace() {
          return this._outputColorSpace
      }
      set outputColorSpace(e) {
          this._outputColorSpace = e;
          const t = this.getContext();
          t.drawingBufferColorSpace = e === Ih ? "display-p3" : "srgb",
          t.unpackColorSpace = ud.workingColorSpace === Nh ? "display-p3" : "srgb"
      }
  }
  class kv extends Ap {
      constructor() {
          super(),
          this.isScene = !0,
          this.type = "Scene",
          this.background = null,
          this.environment = null,
          this.fog = null,
          this.backgroundBlurriness = 0,
          this.backgroundIntensity = 1,
          this.backgroundRotation = new dp,
          this.environmentIntensity = 1,
          this.environmentRotation = new dp,
          this.overrideMaterial = null,
          "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
              detail: this
          }))
      }
      copy(e, t) {
          return super.copy(e, t),
          null !== e.background && (this.background = e.background.clone()),
          null !== e.environment && (this.environment = e.environment.clone()),
          null !== e.fog && (this.fog = e.fog.clone()),
          this.backgroundBlurriness = e.backgroundBlurriness,
          this.backgroundIntensity = e.backgroundIntensity,
          this.backgroundRotation.copy(e.backgroundRotation),
          this.environmentIntensity = e.environmentIntensity,
          this.environmentRotation.copy(e.environmentRotation),
          null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
          this.matrixAutoUpdate = e.matrixAutoUpdate,
          this
      }
      toJSON(e) {
          const t = super.toJSON(e);
          return null !== this.fog && (t.object.fog = this.fog.toJSON()),
          this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
          1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity),
          t.object.backgroundRotation = this.backgroundRotation.toArray(),
          1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity),
          t.object.environmentRotation = this.environmentRotation.toArray(),
          t
      }
  }
  class Vv extends yd {
      constructor(e, t, i, n, r, s, a, o, l) {
          super(e, t, i, n, r, s, a, o, l),
          this.isVideoTexture = !0,
          this.minFilter = void 0 !== s ? s : Eu,
          this.magFilter = void 0 !== r ? r : Eu,
          this.generateMipmaps = !1;
          const c = this;
          "requestVideoFrameCallback"in e && e.requestVideoFrameCallback((function t() {
              c.needsUpdate = !0,
              e.requestVideoFrameCallback(t)
          }
          ))
      }
      clone() {
          return new this.constructor(this.image).copy(this)
      }
      update() {
          const e = this.image;
          !1 == "requestVideoFrameCallback"in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
      }
  }
  function Hv(e, t, i) {
      return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
  }
  class Gv {
      constructor(e, t, i, n) {
          this.parameterPositions = e,
          this._cachedIndex = 0,
          this.resultBuffer = void 0 !== n ? n : new t.constructor(i),
          this.sampleValues = t,
          this.valueSize = i,
          this.settings = null,
          this.DefaultSettings_ = {}
      }
      evaluate(e) {
          const t = this.parameterPositions;
          let i = this._cachedIndex
            , n = t[i]
            , r = t[i - 1];
          e: {
              t: {
                  let s;
                  i: {
                      n: if (!(e < n)) {
                          for (let s = i + 2; ; ) {
                              if (void 0 === n) {
                                  if (e < r)
                                      break n;
                                  return i = t.length,
                                  this._cachedIndex = i,
                                  this.copySampleValue_(i - 1)
                              }
                              if (i === s)
                                  break;
                              if (r = n,
                              n = t[++i],
                              e < n)
                                  break t
                          }
                          s = t.length;
                          break i
                      }
                      if (e >= r)
                          break e;
                      {
                          const a = t[1];
                          e < a && (i = 2,
                          r = a);
                          for (let s = i - 2; ; ) {
                              if (void 0 === r)
                                  return this._cachedIndex = 0,
                                  this.copySampleValue_(0);
                              if (i === s)
                                  break;
                              if (n = r,
                              r = t[--i - 1],
                              e >= r)
                                  break t
                          }
                          s = i,
                          i = 0
                      }
                  }
                  for (; i < s; ) {
                      const n = i + s >>> 1;
                      e < t[n] ? s = n : i = n + 1
                  }
                  if (n = t[i],
                  r = t[i - 1],
                  void 0 === r)
                      return this._cachedIndex = 0,
                      this.copySampleValue_(0);
                  if (void 0 === n)
                      return i = t.length,
                      this._cachedIndex = i,
                      this.copySampleValue_(i - 1)
              }
              this._cachedIndex = i,
              this.intervalChanged_(i, r, n)
          }
          return this.interpolate_(i, r, e, n)
      }
      getSettings_() {
          return this.settings || this.DefaultSettings_
      }
      copySampleValue_(e) {
          const t = this.resultBuffer
            , i = this.sampleValues
            , n = this.valueSize
            , r = e * n;
          for (let e = 0; e !== n; ++e)
              t[e] = i[r + e];
          return t
      }
      interpolate_() {
          throw new Error("call to abstract method")
      }
      intervalChanged_() {}
  }
  class Wv extends Gv {
      constructor(e, t, i, n) {
          super(e, t, i, n),
          this._weightPrev = -0,
          this._offsetPrev = -0,
          this._weightNext = -0,
          this._offsetNext = -0,
          this.DefaultSettings_ = {
              endingStart: 2400,
              endingEnd: 2400
          }
      }
      intervalChanged_(e, t, i) {
          const n = this.parameterPositions;
          let r = e - 2
            , s = e + 1
            , a = n[r]
            , o = n[s];
          if (void 0 === a)
              switch (this.getSettings_().endingStart) {
              case 2401:
                  r = e,
                  a = 2 * t - i;
                  break;
              case 2402:
                  r = n.length - 2,
                  a = t + n[r] - n[r + 1];
                  break;
              default:
                  r = e,
                  a = i
              }
          if (void 0 === o)
              switch (this.getSettings_().endingEnd) {
              case 2401:
                  s = e,
                  o = 2 * i - t;
                  break;
              case 2402:
                  s = 1,
                  o = i + n[1] - n[0];
                  break;
              default:
                  s = e - 1,
                  o = t
              }
          const l = .5 * (i - t)
            , c = this.valueSize;
          this._weightPrev = l / (t - a),
          this._weightNext = l / (o - i),
          this._offsetPrev = r * c,
          this._offsetNext = s * c
      }
      interpolate_(e, t, i, n) {
          const r = this.resultBuffer
            , s = this.sampleValues
            , a = this.valueSize
            , o = e * a
            , l = o - a
            , c = this._offsetPrev
            , u = this._offsetNext
            , h = this._weightPrev
            , d = this._weightNext
            , p = (i - t) / (n - t)
            , f = p * p
            , m = f * p
            , g = -h * m + 2 * h * f - h * p
            , v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
            , _ = (-1 - d) * m + (1.5 + d) * f + .5 * p
            , y = d * m - d * f;
          for (let e = 0; e !== a; ++e)
              r[e] = g * s[c + e] + v * s[l + e] + _ * s[o + e] + y * s[u + e];
          return r
      }
  }
  class Xv extends Gv {
      constructor(e, t, i, n) {
          super(e, t, i, n)
      }
      interpolate_(e, t, i, n) {
          const r = this.resultBuffer
            , s = this.sampleValues
            , a = this.valueSize
            , o = e * a
            , l = o - a
            , c = (i - t) / (n - t)
            , u = 1 - c;
          for (let e = 0; e !== a; ++e)
              r[e] = s[l + e] * u + s[o + e] * c;
          return r
      }
  }
  class qv extends Gv {
      constructor(e, t, i, n) {
          super(e, t, i, n)
      }
      interpolate_(e) {
          return this.copySampleValue_(e - 1)
      }
  }
  class jv {
      constructor(e, t, i, n) {
          if (void 0 === e)
              throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === t || 0 === t.length)
              throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
          this.name = e,
          this.times = Hv(t, this.TimeBufferType),
          this.values = Hv(i, this.ValueBufferType),
          this.setInterpolation(n || this.DefaultInterpolation)
      }
      static toJSON(e) {
          const t = e.constructor;
          let i;
          if (t.toJSON !== this.toJSON)
              i = t.toJSON(e);
          else {
              i = {
                  name: e.name,
                  times: Hv(e.times, Array),
                  values: Hv(e.values, Array)
              };
              const t = e.getInterpolation();
              t !== e.DefaultInterpolation && (i.interpolation = t)
          }
          return i.type = e.ValueTypeName,
          i
      }
      InterpolantFactoryMethodDiscrete(e) {
          return new qv(this.times,this.values,this.getValueSize(),e)
      }
      InterpolantFactoryMethodLinear(e) {
          return new Xv(this.times,this.values,this.getValueSize(),e)
      }
      InterpolantFactoryMethodSmooth(e) {
          return new Wv(this.times,this.values,this.getValueSize(),e)
      }
      setInterpolation(e) {
          let t;
          switch (e) {
          case Dh:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
          case Ch:
              t = this.InterpolantFactoryMethodLinear;
              break;
          case Ah:
              t = this.InterpolantFactoryMethodSmooth
          }
          if (void 0 === t) {
              const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
              if (void 0 === this.createInterpolant) {
                  if (e === this.DefaultInterpolation)
                      throw new Error(t);
                  this.setInterpolation(this.DefaultInterpolation)
              }
              return console.warn("THREE.KeyframeTrack:", t),
              this
          }
          return this.createInterpolant = t,
          this
      }
      getInterpolation() {
          switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
              return Dh;
          case this.InterpolantFactoryMethodLinear:
              return Ch;
          case this.InterpolantFactoryMethodSmooth:
              return Ah
          }
      }
      getValueSize() {
          return this.values.length / this.times.length
      }
      shift(e) {
          if (0 !== e) {
              const t = this.times;
              for (let i = 0, n = t.length; i !== n; ++i)
                  t[i] += e
          }
          return this
      }
      scale(e) {
          if (1 !== e) {
              const t = this.times;
              for (let i = 0, n = t.length; i !== n; ++i)
                  t[i] *= e
          }
          return this
      }
      trim(e, t) {
          const i = this.times
            , n = i.length;
          let r = 0
            , s = n - 1;
          for (; r !== n && i[r] < e; )
              ++r;
          for (; -1 !== s && i[s] > t; )
              --s;
          if (++s,
          0 !== r || s !== n) {
              r >= s && (s = Math.max(s, 1),
              r = s - 1);
              const e = this.getValueSize();
              this.times = i.slice(r, s),
              this.values = this.values.slice(r * e, s * e)
          }
          return this
      }
      validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
          e = !1);
          const i = this.times
            , n = this.values
            , r = i.length;
          0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
          e = !1);
          let s = null;
          for (let t = 0; t !== r; t++) {
              const n = i[t];
              if ("number" == typeof n && isNaN(n)) {
                  console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, n),
                  e = !1;
                  break
              }
              if (null !== s && s > n) {
                  console.error("THREE.KeyframeTrack: Out of order keys.", this, t, n, s),
                  e = !1;
                  break
              }
              s = n
          }
          if (void 0 !== n && (a = n,
          ArrayBuffer.isView(a) && !(a instanceof DataView)))
              for (let t = 0, i = n.length; t !== i; ++t) {
                  const i = n[t];
                  if (isNaN(i)) {
                      console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, i),
                      e = !1;
                      break
                  }
              }
          var a;
          return e
      }
      optimize() {
          const e = this.times.slice()
            , t = this.values.slice()
            , i = this.getValueSize()
            , n = this.getInterpolation() === Ah
            , r = e.length - 1;
          let s = 1;
          for (let a = 1; a < r; ++a) {
              let r = !1;
              const o = e[a];
              if (o !== e[a + 1] && (1 !== a || o !== e[0]))
                  if (n)
                      r = !0;
                  else {
                      const e = a * i
                        , n = e - i
                        , s = e + i;
                      for (let a = 0; a !== i; ++a) {
                          const i = t[e + a];
                          if (i !== t[n + a] || i !== t[s + a]) {
                              r = !0;
                              break
                          }
                      }
                  }
              if (r) {
                  if (a !== s) {
                      e[s] = e[a];
                      const n = a * i
                        , r = s * i;
                      for (let e = 0; e !== i; ++e)
                          t[r + e] = t[n + e]
                  }
                  ++s
              }
          }
          if (r > 0) {
              e[s] = e[r];
              for (let e = r * i, n = s * i, a = 0; a !== i; ++a)
                  t[n + a] = t[e + a];
              ++s
          }
          return s !== e.length ? (this.times = e.slice(0, s),
          this.values = t.slice(0, s * i)) : (this.times = e,
          this.values = t),
          this
      }
      clone() {
          const e = this.times.slice()
            , t = this.values.slice()
            , i = new (0,
          this.constructor)(this.name,e,t);
          return i.createInterpolant = this.createInterpolant,
          i
      }
  }
  jv.prototype.TimeBufferType = Float32Array,
  jv.prototype.ValueBufferType = Float32Array,
  jv.prototype.DefaultInterpolation = Ch;
  class Yv extends jv {
      constructor(e, t, i) {
          super(e, t, i)
      }
  }
  Yv.prototype.ValueTypeName = "bool",
  Yv.prototype.ValueBufferType = Array,
  Yv.prototype.DefaultInterpolation = Dh,
  Yv.prototype.InterpolantFactoryMethodLinear = void 0,
  Yv.prototype.InterpolantFactoryMethodSmooth = void 0;
  (class extends jv {
  }
  ).prototype.ValueTypeName = "color";
  (class extends jv {
  }
  ).prototype.ValueTypeName = "number";
  class Kv extends Gv {
      constructor(e, t, i, n) {
          super(e, t, i, n)
      }
      interpolate_(e, t, i, n) {
          const r = this.resultBuffer
            , s = this.sampleValues
            , a = this.valueSize
            , o = (i - t) / (n - t);
          let l = e * a;
          for (let e = l + a; l !== e; l += 4)
              Td.slerpFlat(r, 0, s, l - a, s, l, o);
          return r
      }
  }
  class Zv extends jv {
      InterpolantFactoryMethodLinear(e) {
          return new Kv(this.times,this.values,this.getValueSize(),e)
      }
  }
  Zv.prototype.ValueTypeName = "quaternion",
  Zv.prototype.InterpolantFactoryMethodSmooth = void 0;
  class $v extends jv {
      constructor(e, t, i) {
          super(e, t, i)
      }
  }
  $v.prototype.ValueTypeName = "string",
  $v.prototype.ValueBufferType = Array,
  $v.prototype.DefaultInterpolation = Dh,
  $v.prototype.InterpolantFactoryMethodLinear = void 0,
  $v.prototype.InterpolantFactoryMethodSmooth = void 0;
  (class extends jv {
  }
  ).prototype.ValueTypeName = "vector";
  class Jv {
      constructor(e=!0) {
          this.autoStart = e,
          this.startTime = 0,
          this.oldTime = 0,
          this.elapsedTime = 0,
          this.running = !1
      }
      start() {
          this.startTime = Qv(),
          this.oldTime = this.startTime,
          this.elapsedTime = 0,
          this.running = !0
      }
      stop() {
          this.getElapsedTime(),
          this.running = !1,
          this.autoStart = !1
      }
      getElapsedTime() {
          return this.getDelta(),
          this.elapsedTime
      }
      getDelta() {
          let e = 0;
          if (this.autoStart && !this.running)
              return this.start(),
              0;
          if (this.running) {
              const t = Qv();
              e = (t - this.oldTime) / 1e3,
              this.oldTime = t,
              this.elapsedTime += e
          }
          return e
      }
  }
  function Qv() {
      return ("undefined" == typeof performance ? Date : performance).now()
  }
  const e_ = "\\[\\]\\.:\\/"
    , t_ = new RegExp("[" + e_ + "]","g")
    , i_ = "[^" + e_ + "]"
    , n_ = "[^" + e_.replace("\\.", "") + "]"
    , r_ = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", i_) + /(WCOD+)?/.source.replace("WCOD", n_) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", i_) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", i_) + "$")
    , s_ = ["material", "materials", "bones", "map"];
  class a_ {
      constructor(e, t, i) {
          this.path = t,
          this.parsedPath = i || a_.parseTrackName(t),
          this.node = a_.findNode(e, this.parsedPath.nodeName),
          this.rootNode = e,
          this.getValue = this._getValue_unbound,
          this.setValue = this._setValue_unbound
      }
      static create(e, t, i) {
          return e && e.isAnimationObjectGroup ? new a_.Composite(e,t,i) : new a_(e,t,i)
      }
      static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(t_, "")
      }
      static parseTrackName(e) {
          const t = r_.exec(e);
          if (null === t)
              throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const i = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6]
          }
            , n = i.nodeName && i.nodeName.lastIndexOf(".");
          if (void 0 !== n && -1 !== n) {
              const e = i.nodeName.substring(n + 1);
              -1 !== s_.indexOf(e) && (i.nodeName = i.nodeName.substring(0, n),
              i.objectName = e)
          }
          if (null === i.propertyName || 0 === i.propertyName.length)
              throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
          return i
      }
      static findNode(e, t) {
          if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
              return e;
          if (e.skeleton) {
              const i = e.skeleton.getBoneByName(t);
              if (void 0 !== i)
                  return i
          }
          if (e.children) {
              const i = function(e) {
                  for (let n = 0; n < e.length; n++) {
                      const r = e[n];
                      if (r.name === t || r.uuid === t)
                          return r;
                      const s = i(r.children);
                      if (s)
                          return s
                  }
                  return null
              }
                , n = i(e.children);
              if (n)
                  return n
          }
          return null
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName]
      }
      _getValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n)
              e[t++] = i[n]
      }
      _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex]
      }
      _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t)
      }
      _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t]
      }
      _setValue_direct_setNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t],
          this.targetObject.needsUpdate = !0
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t],
          this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n)
              i[n] = e[t++]
      }
      _setValue_array_setNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n)
              i[n] = e[t++];
          this.targetObject.needsUpdate = !0
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n)
              i[n] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t]
      }
      _setValue_arrayElement_setNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t],
          this.targetObject.needsUpdate = !0
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t],
          this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t)
      }
      _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
          this.targetObject.needsUpdate = !0
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
          this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _getValue_unbound(e, t) {
          this.bind(),
          this.getValue(e, t)
      }
      _setValue_unbound(e, t) {
          this.bind(),
          this.setValue(e, t)
      }
      bind() {
          let e = this.node;
          const t = this.parsedPath
            , i = t.objectName
            , n = t.propertyName;
          let r = t.propertyIndex;
          if (e || (e = a_.findNode(this.rootNode, t.nodeName),
          this.node = e),
          this.getValue = this._getValue_unavailable,
          this.setValue = this._setValue_unavailable,
          !e)
              return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
          if (i) {
              let n = t.objectIndex;
              switch (i) {
              case "materials":
                  if (!e.material)
                      return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  if (!e.material.materials)
                      return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  e = e.material.materials;
                  break;
              case "bones":
                  if (!e.skeleton)
                      return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  e = e.skeleton.bones;
                  for (let t = 0; t < e.length; t++)
                      if (e[t].name === n) {
                          n = t;
                          break
                      }
                  break;
              case "map":
                  if ("map"in e) {
                      e = e.map;
                      break
                  }
                  if (!e.material)
                      return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  if (!e.material.map)
                      return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  e = e.material.map;
                  break;
              default:
                  if (void 0 === e[i])
                      return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  e = e[i]
              }
              if (void 0 !== n) {
                  if (void 0 === e[n])
                      return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                  e = e[n]
              }
          }
          const s = e[n];
          if (void 0 === s) {
              const i = t.nodeName;
              return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", e)
          }
          let a = this.Versioning.None;
          this.targetObject = e,
          void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
          let o = this.BindingType.Direct;
          if (void 0 !== r) {
              if ("morphTargetInfluences" === n) {
                  if (!e.geometry)
                      return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                  if (!e.geometry.morphAttributes)
                      return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                  void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
              }
              o = this.BindingType.ArrayElement,
              this.resolvedProperty = s,
              this.propertyIndex = r
          } else
              void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray,
              this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray,
              this.resolvedProperty = s) : this.propertyName = n;
          this.getValue = this.GetterByBindingType[o],
          this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
      }
      unbind() {
          this.node = null,
          this.getValue = this._getValue_unbound,
          this.setValue = this._setValue_unbound
      }
  }
  a_.Composite = class {
      constructor(e, t, i) {
          const n = i || a_.parseTrackName(t);
          this._targetGroup = e,
          this._bindings = e.subscribe_(t, n)
      }
      getValue(e, t) {
          this.bind();
          const i = this._targetGroup.nCachedObjects_
            , n = this._bindings[i];
          void 0 !== n && n.getValue(e, t)
      }
      setValue(e, t) {
          const i = this._bindings;
          for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
              i[n].setValue(e, t)
      }
      bind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
              e[t].bind()
      }
      unbind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
              e[t].unbind()
      }
  }
  ,
  a_.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
  },
  a_.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
  },
  a_.prototype.GetterByBindingType = [a_.prototype._getValue_direct, a_.prototype._getValue_array, a_.prototype._getValue_arrayElement, a_.prototype._getValue_toArray],
  a_.prototype.SetterByBindingTypeAndVersioning = [[a_.prototype._setValue_direct, a_.prototype._setValue_direct_setNeedsUpdate, a_.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [a_.prototype._setValue_array, a_.prototype._setValue_array_setNeedsUpdate, a_.prototype._setValue_array_setMatrixWorldNeedsUpdate], [a_.prototype._setValue_arrayElement, a_.prototype._setValue_arrayElement_setNeedsUpdate, a_.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [a_.prototype._setValue_fromArray, a_.prototype._setValue_fromArray_setNeedsUpdate, a_.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]],
  new Float32Array(1),
  "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
      detail: {
          revision: Jc
      }
  })),
  "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Jc);
  const o_ = Math.PI / 180
    , l_ = 180 / Math.PI;
  const c_ = {
      name: "CopyShader",
      uniforms: {
          tDiffuse: {
              value: null
          },
          opacity: {
              value: 1
          }
      },
      vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
      fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"
  };
  class u_ {
      constructor() {
          this.isPass = !0,
          this.enabled = !0,
          this.needsSwap = !0,
          this.clear = !1,
          this.renderToScreen = !1
      }
      setSize() {}
      render() {
          console.error("THREE.Pass: .render() must be implemented in derived pass.")
      }
      dispose() {}
  }
  const h_ = new pm(-1,1,1,-1,0,1)
    , d_ = new class extends uf {
      constructor() {
          super(),
          this.setAttribute("position", new tf([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
          this.setAttribute("uv", new tf([0, 2, 0, 0, 2, 0],2))
      }
  }
  ;
  class p_ {
      constructor(e) {
          this._mesh = new Cf(d_,e)
      }
      dispose() {
          this._mesh.geometry.dispose()
      }
      render(e) {
          e.render(this._mesh, h_)
      }
      get material() {
          return this._mesh.material
      }
      set material(e) {
          this._mesh.material = e
      }
  }
  class f_ extends u_ {
      constructor(e, t) {
          super(),
          this.textureID = void 0 !== t ? t : "tDiffuse",
          e instanceof Ff ? (this.uniforms = e.uniforms,
          this.material = e) : e && (this.uniforms = Nf.clone(e.uniforms),
          this.material = new Ff({
              name: void 0 !== e.name ? e.name : "unspecified",
              defines: Object.assign({}, e.defines),
              uniforms: this.uniforms,
              vertexShader: e.vertexShader,
              fragmentShader: e.fragmentShader
          })),
          this.fsQuad = new p_(this.material)
      }
      render(e, t, i) {
          this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture),
          this.fsQuad.material = this.material,
          this.renderToScreen ? (e.setRenderTarget(null),
          this.fsQuad.render(e)) : (e.setRenderTarget(t),
          this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          this.fsQuad.render(e))
      }
      dispose() {
          this.material.dispose(),
          this.fsQuad.dispose()
      }
  }
  class m_ extends u_ {
      constructor(e, t) {
          super(),
          this.scene = e,
          this.camera = t,
          this.clear = !0,
          this.needsSwap = !1,
          this.inverse = !1
      }
      render(e, t, i) {
          const n = e.getContext()
            , r = e.state;
          let s, a;
          r.buffers.color.setMask(!1),
          r.buffers.depth.setMask(!1),
          r.buffers.color.setLocked(!0),
          r.buffers.depth.setLocked(!0),
          this.inverse ? (s = 0,
          a = 1) : (s = 1,
          a = 0),
          r.buffers.stencil.setTest(!0),
          r.buffers.stencil.setOp(n.REPLACE, n.REPLACE, n.REPLACE),
          r.buffers.stencil.setFunc(n.ALWAYS, s, 4294967295),
          r.buffers.stencil.setClear(a),
          r.buffers.stencil.setLocked(!0),
          e.setRenderTarget(i),
          this.clear && e.clear(),
          e.render(this.scene, this.camera),
          e.setRenderTarget(t),
          this.clear && e.clear(),
          e.render(this.scene, this.camera),
          r.buffers.color.setLocked(!1),
          r.buffers.depth.setLocked(!1),
          r.buffers.color.setMask(!0),
          r.buffers.depth.setMask(!0),
          r.buffers.stencil.setLocked(!1),
          r.buffers.stencil.setFunc(n.EQUAL, 1, 4294967295),
          r.buffers.stencil.setOp(n.KEEP, n.KEEP, n.KEEP),
          r.buffers.stencil.setLocked(!0)
      }
  }
  class g_ extends u_ {
      constructor() {
          super(),
          this.needsSwap = !1
      }
      render(e) {
          e.state.buffers.stencil.setLocked(!1),
          e.state.buffers.stencil.setTest(!1)
      }
  }
  class v_ {
      constructor(e, t) {
          if (this.renderer = e,
          this._pixelRatio = e.getPixelRatio(),
          void 0 === t) {
              const i = e.getSize(new Jh);
              this._width = i.width,
              this._height = i.height,
              (t = new Ed(this._width * this._pixelRatio,this._height * this._pixelRatio,{
                  type: Lu
              })).texture.name = "EffectComposer.rt1"
          } else
              this._width = t.width,
              this._height = t.height;
          this.renderTarget1 = t,
          this.renderTarget2 = t.clone(),
          this.renderTarget2.texture.name = "EffectComposer.rt2",
          this.writeBuffer = this.renderTarget1,
          this.readBuffer = this.renderTarget2,
          this.renderToScreen = !0,
          this.passes = [],
          this.copyPass = new f_(c_),
          this.copyPass.material.blending = 0,
          this.clock = new Jv
      }
      swapBuffers() {
          const e = this.readBuffer;
          this.readBuffer = this.writeBuffer,
          this.writeBuffer = e
      }
      addPass(e) {
          this.passes.push(e),
          e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
      }
      insertPass(e, t) {
          this.passes.splice(t, 0, e),
          e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
      }
      removePass(e) {
          const t = this.passes.indexOf(e);
          -1 !== t && this.passes.splice(t, 1)
      }
      isLastEnabledPass(e) {
          for (let t = e + 1; t < this.passes.length; t++)
              if (this.passes[t].enabled)
                  return !1;
          return !0
      }
      render(e) {
          void 0 === e && (e = this.clock.getDelta());
          const t = this.renderer.getRenderTarget();
          let i = !1;
          for (let t = 0, n = this.passes.length; t < n; t++) {
              const n = this.passes[t];
              if (!1 !== n.enabled) {
                  if (n.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t),
                  n.render(this.renderer, this.writeBuffer, this.readBuffer, e, i),
                  n.needsSwap) {
                      if (i) {
                          const t = this.renderer.getContext()
                            , i = this.renderer.state.buffers.stencil;
                          i.setFunc(t.NOTEQUAL, 1, 4294967295),
                          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e),
                          i.setFunc(t.EQUAL, 1, 4294967295)
                      }
                      this.swapBuffers()
                  }
                  void 0 !== m_ && (n instanceof m_ ? i = !0 : n instanceof g_ && (i = !1))
              }
          }
          this.renderer.setRenderTarget(t)
      }
      reset(e) {
          if (void 0 === e) {
              const t = this.renderer.getSize(new Jh);
              this._pixelRatio = this.renderer.getPixelRatio(),
              this._width = t.width,
              this._height = t.height,
              (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
          }
          this.renderTarget1.dispose(),
          this.renderTarget2.dispose(),
          this.renderTarget1 = e,
          this.renderTarget2 = e.clone(),
          this.writeBuffer = this.renderTarget1,
          this.readBuffer = this.renderTarget2
      }
      setSize(e, t) {
          this._width = e,
          this._height = t;
          const i = this._width * this._pixelRatio
            , n = this._height * this._pixelRatio;
          this.renderTarget1.setSize(i, n),
          this.renderTarget2.setSize(i, n);
          for (let e = 0; e < this.passes.length; e++)
              this.passes[e].setSize(i, n)
      }
      setPixelRatio(e) {
          this._pixelRatio = e,
          this.setSize(this._width, this._height)
      }
      dispose() {
          this.renderTarget1.dispose(),
          this.renderTarget2.dispose(),
          this.copyPass.dispose()
      }
  }
  class __ extends u_ {
      constructor(e, t, i=null, n=null, r=null) {
          super(),
          this.scene = e,
          this.camera = t,
          this.overrideMaterial = i,
          this.clearColor = n,
          this.clearAlpha = r,
          this.clear = !0,
          this.clearDepth = !1,
          this.needsSwap = !1,
          this._oldClearColor = new Xp
      }
      render(e, t, i) {
          const n = e.autoClear;
          let r, s;
          e.autoClear = !1,
          null !== this.overrideMaterial && (s = this.scene.overrideMaterial,
          this.scene.overrideMaterial = this.overrideMaterial),
          null !== this.clearColor && (e.getClearColor(this._oldClearColor),
          e.setClearColor(this.clearColor, e.getClearAlpha())),
          null !== this.clearAlpha && (r = e.getClearAlpha(),
          e.setClearAlpha(this.clearAlpha)),
          1 == this.clearDepth && e.clearDepth(),
          e.setRenderTarget(this.renderToScreen ? null : i),
          !0 === this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          e.render(this.scene, this.camera),
          null !== this.clearColor && e.setClearColor(this._oldClearColor),
          null !== this.clearAlpha && e.setClearAlpha(r),
          null !== this.overrideMaterial && (this.scene.overrideMaterial = s),
          e.autoClear = n
      }
  }
  var y_ = {
      uniforms: {
          tDiffuse: {
              type: "t",
              value: null
          },
          time: {
              type: "f",
              value: 0
          },
          distortion: {
              type: "f",
              value: 3
          },
          distortion2: {
              type: "f",
              value: 5
          },
          speed: {
              type: "f",
              value: .2
          },
          rollSpeed: {
              type: "f",
              value: .1
          }
      },
      vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
      fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float time;", "uniform float distortion;", "uniform float distortion2;", "uniform float speed;", "uniform float rollSpeed;", "varying vec2 vUv;", "vec3 mod289(vec3 x) {", "  return x - floor(x * (1.0 / 289.0)) * 289.0;", "}", "vec2 mod289(vec2 x) {", "  return x - floor(x * (1.0 / 289.0)) * 289.0;", "}", "vec3 permute(vec3 x) {", "  return mod289(((x*34.0)+1.0)*x);", "}", "float snoise(vec2 v)", "  {", "  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0", "                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)", "                     -0.577350269189626,  // -1.0 + 2.0 * C.x", "                      0.024390243902439); // 1.0 / 41.0", "  vec2 i  = floor(v + dot(v, C.yy) );", "  vec2 x0 = v -   i + dot(i, C.xx);", "  vec2 i1;", "  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);", "  vec4 x12 = x0.xyxy + C.xxzz;", " x12.xy -= i1;", "  i = mod289(i); // Avoid truncation effects in permutation", "  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))", "\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));", "  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);", "  m = m*m ;", "  m = m*m ;", "  vec3 x = 2.0 * fract(p * C.www) - 1.0;", "  vec3 h = abs(x) - 0.5;", "  vec3 ox = floor(x + 0.5);", "  vec3 a0 = x - ox;", "  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );", "  vec3 g;", "  g.x  = a0.x  * x0.x  + h.x  * x0.y;", "  g.yz = a0.yz * x12.xz + h.yz * x12.yw;", "  return 130.0 * dot(m, g);", "}", "void main() {", "vec2 p = vUv;", "p -= vec2(0.5);", "p *= 1. - (distortion * 0.03);", "p += vec2(0.5);", "float ty = time*speed;", "float yt = p.y - ty;", "float offset = snoise(vec2(yt*3.0,0.0))*0.2;", "offset = offset * distortion * offset * distortion * offset;", "offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;", "gl_FragColor = texture2D(tDiffuse, vec2(fract(p.x + offset), fract(p.y+ offset)));", "}"].join("\n")
  }
    , x_ = {
      uniforms: {
          tDiffuse: {
              type: "t",
              value: null
          },
          time: {
              type: "f",
              value: 0
          },
          amount: {
              type: "f",
              value: .5
          },
          size: {
              type: "f",
              value: 4
          }
      },
      vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
      fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float time;", "uniform float amount;", "uniform float size;", "varying vec2 vUv;", "float rand(vec2 co){", "return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);", "}", "void main() {", "vec2 p = vUv;", "vec4 color = texture2D(tDiffuse, p);", "float xs = floor(gl_FragCoord.x / size);", "float ys = floor(gl_FragCoord.y / size);", "vec4 snow = vec4(rand(vec2(xs * (fract(time) * 0.05 + 0.001), ys * (fract(time) * 0.05 + 0.001))) * amount);", "gl_FragColor = color + snow;", "}"].join("\n")
  };
  const S_ = new class extends t {
      constructor(t) {
          super(),
          this.options = e({
              init: !0,
              define: null,
              waitFullLoad: !0
          }, t),
          this.store = new Map,
          this.registry = new Map,
          this.options.define && (this.defineAll(this.options.define),
          this.options.init && this.init())
      }
      init() {
          try {
              const e = this
                , t = function() {
                  if ("interactive" === document.readyState || "complete" === document.readyState)
                      return Promise.resolve(e.start()).then((function() {}
                      ));
                  document.addEventListener("DOMContentLoaded", ( () => e.start()), {
                      once: !0
                  })
              }();
              return Promise.resolve(t && t.then ? t.then((function() {}
              )) : void 0)
          } catch (e) {
              return Promise.reject(e)
          }
      }
      start() {
          try {
              const e = this;
              function t() {
                  return Promise.resolve(e.executeAll("init")).then((function() {
                      return Promise.resolve(e.executeAll("enter")).then((function() {
                          return Promise.resolve(e.executeAll("complete")).then((function() {}
                          ))
                      }
                      ))
                  }
                  ))
              }
              e.registry.forEach(( (t, i) => {
                  t.assign ? e.queryAll(t.assign).forEach((t => {
                      e.attach(i, t, null, !1)
                  }
                  )) : e.attach(i, null, null, !1)
              }
              ));
              const i = function() {
                  if (e.options.waitFullLoad)
                      return Promise.resolve(e.waitFullLoad()).then((function() {}
                      ))
              }();
              return Promise.resolve(i && i.then ? i.then(t) : t())
          } catch (n) {
              return Promise.reject(n)
          }
      }
      refresh(e, t, i) {
          void 0 === e && (e = !0),
          void 0 === t && (t = !0),
          void 0 === i && (i = !0);
          try {
              const n = this
                , r = [];
              return n.registry.forEach(( (s, a) => {
                  const o = n.store.get(a);
                  o && o.forEach(( (o, l) => {
                      s.assign ? i && o.el && !o.el.isConnected && r.push(n.detach(a, l, t)) : e && r.push(n.executeInstance(o, "refresh"))
                  }
                  )),
                  s.assign && n.queryAll(s.assign).forEach((t => {
                      const i = o && o.filter((e => e.el && t.isSameNode(e.el)))[0];
                      i ? e && r.push(n.executeInstance(i, "refresh")) : r.push(n.attach(a, t))
                  }
                  ))
              }
              )),
              e && n.trigger("refresh"),
              Promise.all(r)
          } catch (e) {
              return Promise.reject(e)
          }
      }
      executeAll(e) {
          void 0 === e && (e = "init");
          try {
              const t = this
                , i = [];
              return t.trigger(e),
              t.store.forEach((n => {
                  n.forEach((n => i.push(t.executeInstance(n, e))))
              }
              )),
              Promise.all(i)
          } catch (e) {
              return Promise.reject(e)
          }
      }
      executeInstance(e, t) {
          void 0 === t && (t = "init");
          try {
              const i = "on" + t.charAt(0).toUpperCase() + t.slice(1);
              return e[i] ? Promise.resolve(e._executors[t] = e[i]()) : Promise.resolve()
          } catch (e) {
              return Promise.reject(e)
          }
      }
      wait(e, t, i) {
          void 0 === t && (t = "init"),
          void 0 === i && (i = 0);
          try {
              const n = this;
              return Promise.resolve(n.waitInstance(n.get(e, i), t))
          } catch (e) {
              return Promise.reject(e)
          }
      }
      waitAll(e, t) {
          void 0 === t && (t = "init");
          try {
              const e = this
                , i = [];
              return e.store.forEach((n => {
                  n.forEach((n => i.push(e.waitInstance(n, t))))
              }
              )),
              Promise.all(i)
          } catch (e) {
              return Promise.reject(e)
          }
      }
      waitInstance(e, t) {
          void 0 === t && (t = "init");
          try {
              return Promise.resolve(e._executors[t])
          } catch (e) {
              return Promise.reject(e)
          }
      }
      waitFullLoad() {
          try {
              return Promise.resolve(new Promise((e => {
                  "complete" === document.readyState ? e() : window.addEventListener("load", ( () => e()))
              }
              )))
          } catch (e) {
              return Promise.reject(e)
          }
      }
      attach(e, t, i, n) {
          void 0 === n && (n = !0);
          try {
              const r = this
                , s = i || r.registry.get(e).options
                , a = new (0,
              r.registry.get(e).component)(r,t,s);
              r.store.has(e) || r.store.set(e, []),
              r.store.get(e).push(a),
              a._namespace = e;
              const o = function() {
                  if (n)
                      return Promise.resolve(r.executeInstance(a, "init")).then((function() {}
                      ))
              }();
              return Promise.resolve(o && o.then ? o.then((function() {
                  return a
              }
              )) : a)
          } catch (e) {
              return Promise.reject(e)
          }
      }
      detach(e, t, i) {
          void 0 === t && (t = 0),
          void 0 === i && (i = !0);
          try {
              const n = this
                , r = n.store.get(e).splice(t, 1)[0]
                , s = function() {
                  if (i)
                      return Promise.resolve(n.executeInstance(r, "destroy")).then((function() {}
                      ))
              }();
              return Promise.resolve(s && s.then ? s.then((function() {
                  return r
              }
              )) : r)
          } catch (e) {
              return Promise.reject(e)
          }
      }
      define(e, t, i, n) {
          this.registry.set(e, {
              assign: i,
              component: t,
              options: n
          })
      }
      defineAll(e) {
          e.forEach((e => {
              this.define(e.namespace, e.component, e.assign, e.options)
          }
          ))
      }
      get(e, t) {
          void 0 === t && (t = 0);
          const i = this.store.get(e);
          return i ? i[t] : null
      }
      getAll(e) {
          return this.store.get(e)
      }
      find(e, t, i) {
          void 0 === i && (i = 0);
          const n = this.findAll(e, t);
          return n ? n[i] : null
      }
      findAll(e, t) {
          const i = t ? [this.store.get(t) || []] : this.store
            , n = [];
          return i.forEach((t => {
              n.push(...t.filter((t => t.el && ("string" == typeof e ? t.el.matches(e) : t.el === e))))
          }
          )),
          n
      }
      query(e) {
          return "string" == typeof e ? document.querySelector(e) : "object" == typeof e ? e : null
      }
      queryAll(e) {
          return "string" == typeof e ? Array.from(document.querySelectorAll(e)) : "object" == typeof e ? e : []
      }
  }
  ({
      define: [{
          namespace: "ajax",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.options = e({
                      bindLinks: !0,
                      bindHistory: !0,
                      checkLinkUrlRegExp: /(\?.*)?\/(?:|[^.]+(?:\.(?:htm|html|php)|))(?:\?.*|)$/,
                      checkResponseStatus: !0,
                      history: "push",
                      historyState: {},
                      preventSame: !1,
                      preventHash: !0,
                      preventRunning: !1,
                      parserType: "text/html",
                      scrollRestoration: "manual",
                      updateSelectors: ["title", "meta", "#view-main"],
                      extendNodes: !1,
                      removeNodes: !0,
                      detachNodes: !0,
                      resetScroll: !0,
                      restoreScroll: !1,
                      restoreScrollHistory: !0,
                      scrollToHash: !0,
                      fireLeave: !0,
                      fireLoaded: !0,
                      fireRefresh: !0,
                      fireEnter: !0,
                      fireComplete: !0,
                      fireDestroy: !0,
                      fetch: {}
                  }, this.options),
                  this.event = {},
                  this.scroll = {},
                  this.parser = new DOMParser,
                  this.running = !1,
                  this.url = new URL(window.location.href),
                  this.prevUrl = null,
                  this.options.scrollRestoration && (window.history.scrollRestoration = this.options.scrollRestoration),
                  this.options.bindLinks && this.bindLinks(),
                  this.options.bindHistory && this.bindHistory()
              }
              bindLinks() {
                  document.addEventListener("click", (e => {
                      if (!(e.ctrlKey || e.shiftKey || e.altKey || e.metaKey))
                          for (let t = e.target; t && t !== document; t = t.parentNode)
                              if (r(t, this.options.checkLinkUrlRegExp)) {
                                  e.preventDefault(),
                                  this.goTo(t.href);
                                  break
                              }
                  }
                  ))
              }
              bindHistory() {
                  this.event.popstate = () => {
                      this.goTo(window.location.href, {
                          history: !1,
                          preventRunning: !1,
                          restoreScroll: this.options.restoreScrollHistory
                      })
                  }
                  ,
                  window.addEventListener("popstate", this.event.popstate)
              }
              pushHistory(e, t, i) {
                  void 0 === t && (t = "push"),
                  void 0 === i && (i = {}),
                  window.history["push" === t ? "pushState" : "replaceState"](i, "", e)
              }
              goTo(t, i) {
                  try {
                      const r = this;
                      if ((i = e({}, r.options, i)).preventRunning && r.running)
                          return Promise.resolve(!1);
                      if (r.prevUrl = r.url,
                      r.url = new URL(t,window.location.origin),
                      i.preventSame && r.url.href === r.prevUrl.href)
                          return Promise.resolve(!1);
                      if (i.preventHash && r.url.hash !== r.prevUrl.hash) {
                          if (r.url.href.split("#")[0] === r.prevUrl.href.split("#")[0])
                              return Promise.resolve(!1)
                      }
                      return r.scroll[r.prevUrl.href] = {
                          top: window.scrollY,
                          left: window.scrollX
                      },
                      r.running = !0,
                      i.history && r.pushHistory(r.url.href, i.history, i.historyState),
                      Promise.resolve(Promise.all([r.executeRequest(t, i), i.fireLeave ? r.app.executeAll("leave") : null])).then((function(e) {
                          function t() {
                              return i.updateSelectors && (t = i.updateSelectors,
                              s = e[0],
                              a = i.removeNodes,
                              o = i.extendNodes,
                              void 0 === a && (a = !0),
                              void 0 === o && (o = !1),
                              t.forEach((e => {
                                  !function(e, t, i, r) {
                                      void 0 === i && (i = !0),
                                      void 0 === r && (r = !1);
                                      const s = document.querySelectorAll(e)
                                        , a = t.querySelectorAll(e);
                                      s.forEach(( (e, t) => {
                                          if (a[t])
                                              if (r)
                                                  e.append(...a[t].childNodes);
                                              else if (n) {
                                                  const i = document.createElement("div");
                                                  i.innerHTML = a[t].outerHTML,
                                                  e.replaceWith(i.firstElementChild)
                                              } else
                                                  e.replaceWith(a[t]);
                                          else
                                              i && e.remove()
                                      }
                                      ))
                                  }(e, s, a, o)
                              }
                              ))),
                              i.resetScroll && window.scrollTo(0, 0),
                              Promise.resolve(r.app.refresh(i.fireRefresh, i.fireDestroy, i.detachNodes)).then((function() {
                                  function e() {
                                      function e() {
                                          r.running = !1
                                      }
                                      const t = function() {
                                          if (i.fireComplete)
                                              return Promise.resolve(r.app.executeAll("complete")).then((function() {}
                                              ))
                                      }();
                                      return t && t.then ? t.then(e) : e()
                                  }
                                  if (i.restoreScroll && r.scroll[r.url.href])
                                      window.scrollTo(r.scroll[r.url.href]);
                                  else if (i.scrollToHash && r.url.hash && r.app.query(r.url.hash)) {
                                      var t;
                                      null == (t = r.app.query(r.url.hash)) || t.scrollIntoView()
                                  }
                                  const n = function() {
                                      if (i.fireEnter)
                                          return Promise.resolve(r.app.executeAll("enter")).then((function() {}
                                          ))
                                  }();
                                  return n && n.then ? n.then(e) : e()
                              }
                              ));
                              var t, s, a, o
                          }
                          const s = function() {
                              if (i.fireLoaded)
                                  return Promise.resolve(r.app.executeAll("loaded")).then((function() {}
                                  ))
                          }();
                          return s && s.then ? s.then(t) : t()
                      }
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              executeRequest(e, t) {
                  try {
                      const i = this;
                      return Promise.resolve(fetch(e, t.fetch)).then((function(n) {
                          if (!t.checkResponseStatus || n.ok)
                              return Promise.resolve(n.text()).then((function(e) {
                                  return i.parser.parseFromString(e, t.parserType)
                              }
                              ));
                          window.location.assign(e)
                      }
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
          }
          ,
          options: {
              updateSelectors: ["title", "meta", ".cw-navbar", "#view-main"]
          }
      }, {
          namespace: "layout",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.initLenis(),
                  this.bindScrollToElements()
              }
              onEnter() {
                  try {
                      return Qa.refresh(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onComplete() {
                  try {
                      const e = this;
                      return setTimeout(( () => e.loadLazyImages()), 3e3),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onLeave() {
                  try {
                      return this.scrollEnable(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onRefresh() {
                  try {
                      return this.flushLenis(),
                      Qa.clearMatchMedia(),
                      Qa.killAll(),
                      Qa.clearScrollMemory(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              bindScrollToElements() {
                  document.body.addEventListener("click", (e => {
                      for (let t = e.target; t && t !== document.body; t = t.parentNode)
                          if (t.dataset.scrollTo || t.dataset.scrollToTarget) {
                              const i = t.dataset.scrollToOptions ? JSON.parse(t.dataset.scrollToOptions) : void 0;
                              t.dataset.scrollToTarget ? this.scrollToTarget(t.dataset.scrollToTarget, i) && (e.stopPropagation(),
                              e.preventDefault()) : this.scrollTo(t.dataset.scrollTo, 0, i) && (e.stopPropagation(),
                              e.preventDefault())
                          }
                  }
                  ))
              }
              initLenis() {
                  Qa.isTouch || (this.lenis = new Io,
                  this.lenis.on("scroll", Qa.update),
                  jn.ticker.add((e => this.lenis.raf(1e3 * e))),
                  jn.ticker.lagSmoothing(0))
              }
              flushLenis() {
                  this.lenis && (this.lenis.stop(),
                  this.lenis.start())
              }
              scrollEnable() {
                  this.lenis && this.lenis.start(),
                  document.documentElement.classList.remove("no-scroll")
              }
              scrollDisable() {
                  this.lenis && this.lenis.stop(),
                  document.documentElement.classList.add("no-scroll")
              }
              scrollTop() {
                  return this.lenis ? this.lenis.actualScroll : window.scrollY
              }
              scrollLeft() {
                  return window.scrollX
              }
              scrollHeight() {
                  return this.lenis ? this.lenis.limit : document.documentElement.scrollHeight
              }
              scrollWidth() {
                  return document.documentElement.scrollWidth
              }
              scrollTo(e, t, i) {
                  void 0 === t && (t = 0),
                  void 0 === i && (i = {});
                  const n = No({
                      offsetY: 0,
                      offsetX: 0,
                      duration: .3
                  }, i);
                  return e += n.offsetY,
                  t += n.offsetX,
                  this.flushLenis(),
                  n.duration ? jn.to(window, {
                      scrollTo: {
                          y: e,
                          x: t,
                          autoKill: !1
                      },
                      ease: n.ease,
                      duration: n.duration,
                      onComplete: n.onComplete
                  }) : window.scrollTo({
                      top: e,
                      left: t,
                      behavior: "instant"
                  }),
                  !0
              }
              scrollToTarget(e, t) {
                  const i = this.app.query(e);
                  if (!i)
                      return !1;
                  const n = getComputedStyle(i)
                    , r = i.getBoundingClientRect()
                    , s = r.top + this.scrollTop() - parseInt(n.scrollMarginTop)
                    , a = r.left + this.scrollLeft() - parseInt(n.scrollMarginLeft);
                  return this.scrollTo(s, a, t)
              }
              loadLazyImages() {
                  this.app.queryAll("img[loading=lazy]").forEach((e => e.setAttribute("loading", "eager")))
              }
          }
      }, {
          namespace: "cursor",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.initFollower()
              }
              onLeave() {
                  try {
                      const e = this;
                      return e.follower ? (e.follower.removeIcon(),
                      e.follower.removeText(),
                      e.follower.removeImg(),
                      e.follower.removeVideo(),
                      e.follower.removeState("-pointer"),
                      e.follower.removeState("-inverse"),
                      e.follower.removeState("-opaque"),
                      Promise.resolve()) : Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              initFollower() {
                  window.matchMedia("(pointer:fine)").matches && (this.follower = new Fo({
                      className: "cw-cursor",
                      innerClassName: "cw-cursor-inner",
                      textClassName: "cw-cursor-text",
                      mediaClassName: "cw-cursor-media",
                      mediaBoxClassName: "cw-cursor-media-box",
                      iconSvgClassName: "cw-svgsprite",
                      iconSvgSrc: "/assets/sprites/svgsprites.svg?2",
                      skewing: 1.5,
                      skewingMedia: .5
                  }))
              }
          }
      }, {
          namespace: "loader",
          assign: ".cw-loader",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.backdrop = this.el.querySelector(".cw-loader-backdrop"),
                  this.fill = this.el.querySelector(".cw-loader-fill"),
                  this.showTl = this.tlShow(),
                  this.hideTl = this.tlHide()
              }
              onInit() {
                  try {
                      return Promise.resolve(new Promise((e => {
                          "requestIdleCallback"in window ? requestIdleCallback(e) : requestAnimationFrame(e)
                      }
                      ))).then((function() {}
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onEnter() {
                  try {
                      const e = this;
                      return Promise.resolve(e.hide()).then((function() {}
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onLeave() {
                  try {
                      const e = this;
                      return Promise.resolve(e.show()).then((function() {}
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onRefresh() {
                  try {
                      return Promise.resolve(new Promise((e => {
                          "requestIdleCallback"in window ? requestIdleCallback(e) : requestAnimationFrame(e)
                      }
                      ))).then((function() {}
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              show() {
                  try {
                      const e = this;
                      return document.documentElement.classList.add("loader"),
                      Promise.resolve(e.showTl.play(0)).then((function() {}
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              hide() {
                  try {
                      const e = this;
                      return document.documentElement.classList.remove("loader"),
                      Promise.resolve(e.hideTl.play(0)).then((function() {}
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              tlShow() {
                  const e = new jn.timeline({
                      paused: !0
                  });
                  return e.set(this.el, {
                      display: "block",
                      pointerEvents: "auto"
                  }),
                  e.set(this.fill, {
                      opacity: 1
                  }),
                  e.fromTo(this.backdrop, {
                      opacity: 0
                  }, {
                      opacity: 1
                  }, 0),
                  e.fromTo(this.fill, {
                      scaleY: 0,
                      transformOrigin: "bottom bottom"
                  }, {
                      scaleY: 1,
                      transformOrigin: "bottom bottom",
                      duration: .7,
                      ease: "power4.inOut",
                      immediateRender: !1
                  }, 0),
                  e
              }
              tlHide() {
                  const e = new jn.timeline({
                      paused: !0
                  });
                  return e.set(this.el, {
                      pointerEvents: "none"
                  }, 0),
                  e.set(this.backdrop, {
                      opacity: 0
                  }, 0),
                  e.to(this.fill, {
                      opacity: 0,
                      duration: .4
                  }, 0),
                  e.set(this.el, {
                      display: "none"
                  }),
                  e
              }
          }
      }, {
          namespace: "metrika",
          component: class extends i {
              constructor() {
                  super(...arguments)
              }
              onRefresh() {
                  try {
                      return window.ym && window.ym(window.ymID, "hit"),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
          }
      }, {
          namespace: "video",
          assign: "video",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.source = this.el.querySelectorAll("source"),
                  this.bindSourceMediaRefresh()
              }
              bindSourceMediaRefresh() {
                  this.source.forEach((e => {
                      e.media && (window.matchMedia(e.media).onchange = () => {
                          this.el.isConnected && this.el.load()
                      }
                      )
                  }
                  ))
              }
          }
      }, {
          namespace: "divider",
          assign: ".cw-divider",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.injectSvg(),
                  this.bindMouseMove(),
                  this.bindResizeObserver()
              }
              onInit() {
                  try {
                      return this.magicShow(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              magicShow() {
                  Qa.create({
                      trigger: this.el,
                      animation: this.tlShow()
                  })
              }
              tlShow() {
                  const e = new jn.timeline;
                  return e.set(this.svg, {
                      transformOrigin: "left center"
                  }),
                  e.from(this.svg, {
                      scaleX: 0,
                      duration: 3,
                      ease: "expo.out"
                  }),
                  e
              }
              getPathD(e, t, i) {
                  return e || (e = this.el.offsetWidth / 2),
                  t || (t = 100),
                  void 0 === i && (i = this.el.offsetWidth),
                  "M0,100 Q" + e + "," + t + " " + i + ",100"
              }
              injectSvg() {
                  this.el.innerHTML = "<svg><path d='" + this.getPathD() + "'/></svg>",
                  this.svg = this.el.querySelector("svg"),
                  this.path = this.el.querySelector("path")
              }
              update() {
                  jn.killTweensOf(this.path),
                  this.path.setAttribute("d", this.getPathD())
              }
              bindMouseMove() {
                  if (Qa.isTouch)
                      return;
                  let e = 0;
                  this.el.addEventListener("mousemove", (t => {
                      const i = this.svg.getBoundingClientRect()
                        , n = t.pageX - window.pageXOffset - i.left
                        , r = t.pageY - window.pageYOffset - i.top;
                      e || (e = r < 100 ? 50 : -50);
                      const s = n
                        , a = 2 * r - 100 + e;
                      jn.to(this.path, {
                          attr: {
                              d: this.getPathD(s, a)
                          },
                          duration: .2,
                          overwrite: !0
                      })
                  }
                  )),
                  this.el.addEventListener("mouseleave", ( () => {
                      e = 0,
                      jn.to(this.path, {
                          attr: {
                              d: this.getPathD()
                          },
                          duration: 2,
                          ease: "elastic.out(1, 0.2)"
                      })
                  }
                  ))
              }
              bindResizeObserver() {
                  this.updateDebounced = function(e, t, i) {
                      var n, r, s, a, o, l, c = 0, u = !1, h = !1, d = !0;
                      if ("function" != typeof e)
                          throw new TypeError("Expected a function");
                      function p(t) {
                          var i = n
                            , s = r;
                          return n = r = void 0,
                          c = t,
                          a = e.apply(s, i)
                      }
                      function f(e) {
                          var i = e - l;
                          return void 0 === l || i >= t || i < 0 || h && e - c >= s
                      }
                      function m() {
                          var e = ko();
                          if (f(e))
                              return g(e);
                          o = setTimeout(m, function(e) {
                              var i = t - (e - l);
                              return h ? rl(i, s - (e - c)) : i
                          }(e))
                      }
                      function g(e) {
                          return o = void 0,
                          d && n ? p(e) : (n = r = void 0,
                          a)
                      }
                      function v() {
                          var e = ko()
                            , i = f(e);
                          if (n = arguments,
                          r = this,
                          l = e,
                          i) {
                              if (void 0 === o)
                                  return function(e) {
                                      return c = e,
                                      o = setTimeout(m, t),
                                      u ? p(e) : a
                                  }(l);
                              if (h)
                                  return clearTimeout(o),
                                  o = setTimeout(m, t),
                                  p(l)
                          }
                          return void 0 === o && (o = setTimeout(m, t)),
                          a
                      }
                      return t = il(t) || 0,
                      Oo(i) && (u = !!i.leading,
                      s = (h = "maxWait"in i) ? nl(il(i.maxWait) || 0, t) : s,
                      d = "trailing"in i ? !!i.trailing : d),
                      v.cancel = function() {
                          void 0 !== o && clearTimeout(o),
                          c = 0,
                          n = l = r = o = void 0
                      }
                      ,
                      v.flush = function() {
                          return void 0 === o ? a : g(ko())
                      }
                      ,
                      v
                  }(this.update.bind(this), 30),
                  this.resizeObserver = new ResizeObserver(( () => this.updateDebounced())),
                  this.resizeObserver.observe(this.el)
              }
          }
      }, {
          namespace: "button",
          assign: ".cw-btn",
          component: class extends i {
              constructor() {
                  super(...arguments)
              }
          }
      }, {
          namespace: "checkbox",
          assign: ".cw-checkbox",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.cursor = this.app.get("cursor"),
                  this.ripple = this.el.querySelector(".cw-checkbox_cta-ripple"),
                  this.bindHover()
              }
              bindHover() {
                  this.cursor.follower && (this.el.addEventListener("mouseenter", ( () => {
                      this.cursor.follower.addState("-opaque")
                  }
                  )),
                  this.el.addEventListener("mouseleave", ( () => {
                      this.cursor.follower.removeState("-opaque")
                  }
                  )),
                  Al(this.el, {
                      xDelta: .2,
                      yDelta: .2,
                      leaveSpeed: 2,
                      leaveEase: "elastic.out(1,0.4)"
                  }))
              }
          }
      }, {
          namespace: "input.light",
          assign: ".cw-input_light",
          component: class extends i {
              constructor() {
                  var e, t;
                  super(...arguments),
                  this.input = this.el.querySelector("input, textarea"),
                  this.isTextarea = "TEXTAREA" === (null == (e = this.input) ? void 0 : e.tagName),
                  this.validityMsg = JSON.parse(null != (t = this.el.dataset.validityMsg) ? t : "null"),
                  this.message = this.el.querySelector(".cw-input_light-message"),
                  this.bindInput(),
                  this.isTextarea && this.bindAutosize()
              }
              bindInput() {
                  this.input && this.input.addEventListener("change", ( () => {
                      this.el.classList.toggle("-filled", !!this.input.value),
                      this.checkValidity()
                  }
                  ))
              }
              bindAutosize() {
                  Xl(this.input),
                  this.input.addEventListener("change", ( () => Qa.refresh()))
              }
              checkValidity() {
                  const e = this.input.validity;
                  if (e && this.validityMsg) {
                      if (this.el.classList.toggle("-error", !e.valid),
                      e.valid)
                          return this.message.innerHTML = "",
                          !0;
                      for (let t in e)
                          if (e[t] && this.validityMsg[t]) {
                              this.message.innerHTML = this.validityMsg[t];
                              break
                          }
                      return !1
                  }
              }
              reset() {
                  this.el.classList.remove("-filled -error")
              }
          }
      }, {
          namespace: "input.file",
          assign: ".cw-input_file",
          component: class extends i {
              constructor() {
                  var e, t;
                  super(...arguments),
                  this.files = [],
                  this.overallSize = 0,
                  this.error = !1,
                  this.validity = JSON.parse(null != (e = this.el.dataset.validity) ? e : "null"),
                  this.validityMsg = JSON.parse(null != (t = this.el.dataset.validityMsg) ? t : "null"),
                  this.input = this.el.querySelector("[type=file]"),
                  this.isMultiple = !!this.input.multiple,
                  this.btn = this.el.querySelector(".cw-input_file-btn"),
                  this.items = this.el.querySelector(".cw-input_file-items"),
                  this.message = this.el.querySelector(".cw-input_file-message"),
                  this.bindChange()
              }
              bindChange() {
                  this.btn.addEventListener("click", ( () => this.input.click())),
                  this.input.addEventListener("change", ( () => {
                      this.suppressAdd || this.addFiles(),
                      this.suppressAdd = !1
                  }
                  ))
              }
              checkValidity() {
                  this.validity && this.validityMsg && (this.error = !1,
                  this.files.length > this.validity.limit && (this.error = "limit"),
                  this.overallSize > this.validity.size && (this.error = "size"),
                  this.error ? this.setError(this.validityMsg[this.error]) : this.removeError())
              }
              reset() {
                  this.input.innerHTML = "",
                  this.files = [],
                  this.updateFiles()
              }
              setError(e) {
                  void 0 === e && (e = ""),
                  this.el.classList.add("-error"),
                  e && (this.message.innerHTML = e),
                  this.input.setCustomValidity(e || "error")
              }
              removeError() {
                  this.el.classList.remove("-error"),
                  this.message.innerHTML = "",
                  this.input.setCustomValidity("")
              }
              addFiles() {
                  this.files = this.isMultiple ? this.files.concat(Array.from(this.input.files)) : this.input.files,
                  this.updateFiles()
              }
              updateFiles() {
                  const e = new DataTransfer
                    , t = document.createDocumentFragment();
                  this.overallSize = 0,
                  this.files.forEach(( (i, n) => {
                      const r = document.createElement("div");
                      r.className = "cw-input_file-item",
                      r.innerHTML = "<i></i><b>" + i.name + "</b>",
                      r.addEventListener("click", ( () => this.removeFile(n))),
                      t.appendChild(r),
                      e.items.add(i),
                      this.overallSize += i.size
                  }
                  )),
                  this.input.files = e.files,
                  this.items.innerHTML = "",
                  this.items.appendChild(t),
                  this.checkValidity(),
                  Qa.refresh()
              }
              removeFile(e) {
                  this.files.splice(e, 1),
                  this.updateFiles(),
                  this.suppressAdd = !0,
                  this.input.dispatchEvent(new Event("change"))
              }
          }
      }, {
          namespace: "modal",
          assign: ".cw-modal",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.showTimeout = 30,
                  this.hideTimeout = 600,
                  this.dialog = this.el.querySelector("[data-modal-dialog]"),
                  this.bindCloses(),
                  this.bindOpens()
              }
              bindCloses() {
                  this.el.querySelectorAll("[data-modal-close]").forEach((e => {
                      e.addEventListener("click", ( () => this.hide()))
                  }
                  ))
              }
              bindOpens() {
                  this.el.id && this.app.queryAll("[data-modal-open='#" + this.el.id + "']").forEach((e => {
                      e.removeAttribute("data-modal-open"),
                      e.addEventListener("click", ( () => this.show()))
                  }
                  ))
              }
              show() {
                  this.trigger("show"),
                  this.app.trigger("modalShow", this),
                  this.el.classList.add("-show"),
                  document.documentElement.classList.add("modal"),
                  clearInterval(this.visibleInt),
                  this.visibleInt = setTimeout(( () => {
                      this.el.classList.add("-visible"),
                      this.trigger("showed"),
                      this.app.trigger("modalShowed", this)
                  }
                  ), this.showTimeout),
                  this.el.querySelectorAll("video").forEach((e => e.play()))
              }
              hide() {
                  this.trigger("hide"),
                  this.app.trigger("modalHide", this),
                  this.el.classList.remove("-visible"),
                  clearInterval(this.visibleInt),
                  this.visibleInt = setTimeout(( () => {
                      this.el.classList.remove("-show"),
                      document.documentElement.classList.remove("modal"),
                      this.trigger("hidden"),
                      this.app.trigger("modalHidden", this)
                  }
                  ), this.hideTimeout),
                  this.el.querySelectorAll("video").forEach((e => e.pause()))
              }
          }
      }, {
          namespace: "navbar",
          assign: ".cw-navbar",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.layout = this.app.get("layout"),
                  this.cursor = this.app.get("cursor"),
                  this.backdrop = this.el.querySelector(".cw-navbar-backdrop"),
                  this.logo = this.el.querySelector(".cw-navbar-logo"),
                  this.logoPath = this.logo.querySelectorAll("path"),
                  this.nav = this.el.querySelectorAll(".cw-navbar-nav"),
                  this.toggleEl = this.el.querySelector(".cw-navbar-toggle"),
                  this.toggleBtn = this.toggleEl.querySelector("button"),
                  this.menu = this.el.querySelector(".cw-navbar-menu"),
                  this.menuTop = this.el.querySelector(".cw-navbar-menu-top"),
                  this.menuBottom = this.el.querySelector(".cw-navbar-menu-bottom"),
                  this.hideTl = this.tlHide(),
                  this.showTl = this.tlShow(),
                  this.opened = !1
              }
              onInit() {
                  try {
                      const e = this;
                      return e.bindToggle(),
                      e.handleEnter(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onEnter() {
                  try {
                      const e = this
                        , t = function() {
                          if (e.enterTl)
                              return Promise.resolve(e.enterTl.play(0)).then((function() {}
                              ))
                      }();
                      return Promise.resolve(t && t.then ? t.then((function() {}
                      )) : void 0)
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              handleEnter() {
                  this.enterTl = this.tlEnter()
              }
              tlEnter() {
                  const e = new jn.timeline({
                      paused: !0
                  });
                  return e.fromTo(this.logoPath, {
                      scale: 0,
                      transformOrigin: "center center"
                  }, {
                      scale: 1,
                      duration: .4,
                      stagger: .06,
                      transformOrigin: "center center"
                  }, 0),
                  e.set([this.nav, this.toggleEl], {
                      willChange: "transform"
                  }),
                  e.fromTo([this.nav, this.toggleEl], {
                      y: 30,
                      opacity: 0,
                      clipPath: "inset(0 0 100% 0)"
                  }, {
                      y: 0,
                      opacity: 1,
                      clipPath: "inset(0 0 0% 0)",
                      duration: .8,
                      stagger: .1,
                      clearProps: "y,opacity,clipPath"
                  }, 0),
                  e.set([this.nav, this.toggleEl], {
                      willChange: "auto"
                  }),
                  e
              }
              bindToggle() {
                  this.toggleBtn.addEventListener("click", ( () => this.toggle())),
                  this.backdrop.addEventListener("click", ( () => this.hide())),
                  this.el.addEventListener("mouseenter", ( () => {
                      var e;
                      this.el.classList.contains("-inverse") && (null == (e = this.cursor.follower) || e.addState("-inverse"))
                  }
                  )),
                  window.addEventListener("keyup", (e => {
                      "Escape" === e.key && this.toggle()
                  }
                  )),
                  Qa.isTouch || Al(this.toggleBtn, {
                      leaveSpeed: 2,
                      leaveEase: "elastic.out(1,0.25)"
                  })
              }
              toggle() {
                  this.opened ? this.hide() : this.show()
              }
              show() {
                  this.opened = !0,
                  this.el.classList.add("-open"),
                  document.documentElement.classList.add("menu-open"),
                  this.layout.lenis || this.layout.scrollDisable(),
                  this.hideTl.pause(),
                  this.showTl.play(0)
              }
              hide() {
                  this.opened = !1,
                  this.el.classList.remove("-open"),
                  document.documentElement.classList.remove("menu-open"),
                  this.layout.lenis || this.layout.scrollEnable(),
                  this.showTl.pause(),
                  this.hideTl.play(0)
              }
              tlShow() {
                  const e = new jn.timeline({
                      paused: !0,
                      immediateRender: !1
                  });
                  return e.set(this.menu, {
                      display: "grid",
                      pointerEvents: "auto"
                  }),
                  e.set(this.backdrop, {
                      display: "block",
                      pointerEvents: "auto"
                  }),
                  e.fromTo(this.backdrop, {
                      opacity: 0
                  }, {
                      opacity: 1,
                      duration: 1
                  }, 0),
                  e.fromTo(this.menu, {
                      clipPath: "inset(0 0 0 100%)"
                  }, {
                      clipPath: "inset(0 0 0 0%)",
                      duration: 1,
                      ease: "power4.out",
                      clearProps: "clipPath"
                  }, 0),
                  e.fromTo([this.menuTop, this.menuBottom], {
                      xPercent: 50
                  }, {
                      xPercent: 0,
                      duration: 1,
                      ease: "expo.out"
                  }, 0),
                  e.fromTo([this.menuTop, this.menuBottom], {
                      opacity: 0
                  }, {
                      opacity: 1,
                      duration: .5
                  }, .15),
                  e
              }
              tlHide() {
                  const e = new jn.timeline({
                      paused: !0,
                      immediateRender: !1
                  });
                  return e.set(this.menu, {
                      pointerEvents: "none"
                  }),
                  e.set(this.backdrop, {
                      pointerEvents: "none"
                  }),
                  e.fromTo(this.backdrop, {
                      opacity: 1
                  }, {
                      opacity: 0,
                      duration: .4
                  }, 0),
                  e.fromTo(this.menu, {
                      clipPath: "inset(0 0 0 0%)"
                  }, {
                      clipPath: "inset(0 0 0 100%)",
                      duration: .4,
                      clearProps: "clipPath"
                  }, 0),
                  e.fromTo([this.menuTop, this.menuBottom], {
                      xPercent: 0
                  }, {
                      xPercent: 20,
                      duration: .4
                  }, 0),
                  e.fromTo([this.menuTop, this.menuBottom], {
                      opacity: 1
                  }, {
                      opacity: 0,
                      duration: .1
                  }, 0),
                  e.set(this.menu, {
                      display: "none"
                  }),
                  e.set(this.backdrop, {
                      display: "none"
                  }),
                  e
              }
          }
      }, {
          namespace: "intouch",
          assign: ".cw-intouch",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.video = this.el.querySelector(".cw-intouch-video")
              }
              onInit() {
                  try {
                      const e = this;
                      return e.handleEnter(),
                      e.initMagnetic(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onEnter() {
                  try {
                      const e = this;
                      return e.enterTl ? Promise.resolve(e.app.wait("loader", "enter")).then((function() {
                          return Promise.resolve(e.enterTl.play(0)).then((function() {}
                          ))
                      }
                      )) : Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onRefresh() {
                  try {
                      const e = this;
                      return e.enterTl && e.enterTl.pause(0),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              handleEnter() {
                  this.el.offsetWidth && (this.enterTl = this.tlEnter())
              }
              tlEnter() {
                  const e = new jn.timeline({
                      paused: !0
                  });
                  return e.from(this.el, {
                      scale: 0,
                      duration: 2,
                      ease: "expo.out"
                  }),
                  e
              }
              initMagnetic() {
                  Qa.isTouch || Al(this.video, {
                      box: this.el,
                      xDelta: .08,
                      yDelta: .08,
                      leaveSpeed: 2,
                      leaveEase: "elastic.out(1,0.25)"
                  })
              }
          }
      }, {
          namespace: "embedded",
          assign: ".cw-embedded",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.cursor = this.app.get("cursor"),
                  this.src = this.el.dataset.src,
                  this.bindSwitch(),
                  this.bindCursor()
              }
              bindSwitch() {
                  this.src && this.el.addEventListener("click", ( () => this.injectFrame()))
              }
              bindCursor() {
                  this.cursor.follower && (this.el.addEventListener("mouseenter", ( () => this.cursor.follower.hide())),
                  this.el.addEventListener("mouseleave", ( () => this.cursor.follower.show())))
              }
              injectFrame() {
                  this.el.innerHTML = "<iframe src='" + this.src + "' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen></iframe>"
              }
          }
      }, {
          namespace: "tophead",
          assign: ".cw-tophead",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.fill = this.el.querySelector(".cw-tophead-fill"),
                  this.header = this.el.querySelector(".cw-tophead-header"),
                  this.title = this.el.querySelector(".cw-tophead-title")
              }
              onInit() {
                  try {
                      return this.handleEnter(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onEnter() {
                  try {
                      const e = this;
                      return e.enterTl && e.enterTl.play(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              handleEnter() {
                  this.enterTl = this.tlEnter()
              }
              tlEnter() {
                  const e = new jn.timeline({
                      paused: !0
                  });
                  return this.header && e.add(Pl(this.header.firstElementChild, {
                      stagger: .1
                  }), 0),
                  this.title && e.add(Pl(this.title.firstElementChild), 0),
                  this.fill && (e.set(this.fill, {
                      willChange: "transform"
                  }),
                  e.fromTo(this.fill, {
                      scaleY: window.innerHeight / this.el.offsetHeight,
                      transformOrigin: "top center"
                  }, {
                      scaleY: 1,
                      transformOrigin: "top center",
                      duration: 3,
                      ease: "expo.out"
                  }, .5),
                  e.set(this.fill, {
                      willChange: "auto"
                  })),
                  e
              }
          }
      }, {
          namespace: "contact",
          assign: ".cw-contact",
          component: class extends i {
              constructor() {
                  var e;
                  super(...arguments),
                  this.cursor = this.app.get("cursor"),
                  this.modalSuccess = this.app.find("#modal-contact-success", "modal"),
                  this.modalError = this.app.find("#modal-contact-error", "modal"),
                  this.modalErrorMessage = null == (e = this.modalError) ? void 0 : e.el.querySelector(".cw-modal_box-message-message"),
                  this.header = this.el.querySelector(".cw-contact-header"),
                  this.form = this.el.querySelector(".cw-contact-form"),
                  this.input = this.form.querySelectorAll("input, select, textarea"),
                  this.submitBtn = this.el.querySelector("[type=submit]"),
                  this.attachments = this.app.get("input.file"),
                  function() {
                      if (ql)
                          return;
                      const e = document.createElement("script");
                      e.async = !0,
                      e.src = "https://www.google.com/recaptcha/api.js?render=6Lewc_4ZAAAAAFQApM6YE6VtaTFKJgNHxePjQo7D",
                      document.body.appendChild(e),
                      ql = !0
                  }(),
                  this.bindForm(),
                  this.bindInputs(),
                  this.handleEnter(),
                  this.checkValidity()
              }
              onEnter() {
                  try {
                      const e = this
                        , t = function() {
                          if (e.enterTl)
                              return Promise.resolve(e.enterTl.play()).then((function() {}
                              ))
                      }();
                      return Promise.resolve(t && t.then ? t.then((function() {}
                      )) : void 0)
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              handleEnter() {
                  this.enterTl = this.tlEnter()
              }
              bindForm() {
                  const e = this;
                  this.form.addEventListener("submit", (function(t) {
                      try {
                          return t.preventDefault(),
                          window.grecaptcha ? window.grecaptcha.ready(( () => {
                              window.grecaptcha.execute("6Lewc_4ZAAAAAFQApM6YE6VtaTFKJgNHxePjQo7D", {
                                  action: "submit"
                              }).then((t => {
                                  e.reqRecaptchaToken = t,
                                  e.submit()
                              }
                              ))
                          }
                          )) : e.submit(),
                          Promise.resolve()
                      } catch (t) {
                          return Promise.reject(t)
                      }
                  }
                  ))
              }
              bindInputs() {
                  this.input.forEach((e => {
                      e.addEventListener("change", ( () => this.checkValidity()))
                  }
                  ))
              }
              checkValidity() {
                  this.submitBtn.disabled = !this.form.checkValidity()
              }
              submit() {
                  this.data = new FormData(this.form),
                  window.ym && window.ym(window.ymID, "reachGoal", "order"),
                  this.reqRecaptchaToken && this.data.append("g-recaptcha-response", this.reqRecaptchaToken),
                  this.setLoadingState(),
                  fetch(this.form.action, {
                      method: "POST",
                      body: this.data,
                      cache: "no-cache"
                  }).then((e => {
                      if (!e.ok)
                          return this.setErrorState(e.statusText),
                          !1;
                      this.setSuccessState()
                  }
                  )).catch(( () => {
                      this.setErrorState()
                  }
                  ))
              }
              reset() {
                  this.form.reset(),
                  this.attachments.reset(),
                  this.submitBtn.setAttribute("disabled", !0)
              }
              setLoadingState() {
                  var e, t;
                  this.submitBtn.setAttribute("disabled", !0),
                  null == (e = this.cursor) || e.follower.removeState("-opaque"),
                  null == (t = this.cursor) || t.follower.addState("-loading")
              }
              removeLoadingState() {
                  var e;
                  this.submitBtn.removeAttribute("disabled"),
                  null == (e = this.cursor) || e.follower.removeState("-loading")
              }
              setSuccessState() {
                  this.removeLoadingState(),
                  this.reset(),
                  this.modalSuccess.show()
              }
              setErrorState(e) {
                  this.removeLoadingState(),
                  this.modalErrorMessage.innerHTML = null != e ? e : "",
                  this.modalError.show()
              }
              tlEnter() {
                  const e = new jn.timeline({
                      paused: !0
                  })
                    , t = Array.from(this.el.querySelectorAll(".cw-contact-label, .cw-checkbox, .cw-contact-group")).filter((e => Qa.isInViewport(e)));
                  return this.header && e.add(Pl(this.header.firstElementChild), 0),
                  e.set(t, {
                      willChange: "transform"
                  }, 0),
                  e.fromTo(t, {
                      y: window.innerWidth > 1e3 ? 50 : 30,
                      opacity: 0
                  }, {
                      y: 0,
                      opacity: 1,
                      ease: "power3.out",
                      duration: 1,
                      stagger: .04
                  }, .2),
                  e.set(t, {
                      willChange: "auto"
                  }),
                  e
              }
          }
      }, {
          namespace: "work",
          assign: ".cw-work",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.cursor = this.app.get("cursor"),
                  this.filterModal = this.app.find("#modal-work-filters", "modal"),
                  this.filter = this.el.querySelector(".cw-work-filter"),
                  this.filterTitle = this.el.querySelector(".cw-work-filter-title"),
                  this.filterActive = this.filter.querySelector(".cw-work-filter-active"),
                  this.gridLeft = this.el.querySelector(".cw-work-col.-left"),
                  this.gridRight = this.el.querySelector(".cw-work-col.-right"),
                  this.itemLeft = Array.from(this.gridLeft.querySelectorAll(".cw-work-item")),
                  this.itemRight = Array.from(this.gridRight.querySelectorAll(".cw-work-item")),
                  this.itemLength = this.itemLeft.length + this.itemRight.length,
                  this.item = new Array(this.itemLength).fill(void 0).map(( (e, t) => t % 2 == 0 ? this.itemLeft[Math.floor(t / 2)] : t % 2 == 1 ? this.itemRight[Math.floor(t / 2)] : void 0)),
                  this.bindFilter()
              }
              onInit() {
                  try {
                      return this.handleEnter(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onEnter() {
                  try {
                      const e = this;
                      return e.enterTl && e.enterTl.play(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              handleEnter() {
                  this.enterTl = this.tlEnter()
              }
              bindFilter() {
                  const e = this.filterModal.el.querySelectorAll(".cw-modal_box-nav-item a");
                  this.cursor.follower && this.filterModal.on("hide", ( () => this.cursor.follower.removeIcon())),
                  this.filterActive.addEventListener("click", ( () => this.openFilters())),
                  e.forEach((e => {
                      e.addEventListener("click", ( () => {
                          this.filterSelect(e.dataset.filterTarget, e.innerText),
                          this.hideFilters()
                      }
                      ))
                  }
                  ))
              }
              filterSelect(e, t) {
                 
              }
              openFilters() {
                  this.filterModal.show()
              }
              hideFilters() {
                  this.filterModal.hide()
              }
              tlEnter() {
                  const e = new jn.timeline({
                      paused: !0,
                      delay: .4
                  });
                  return jn.set(this.item, {
                      opacity: 0
                  }),
                  this.filter && e.add(Nl([this.filterTitle, this.filterActive]), 0),
                  e.add(( () => this.magicShow()), 0),
                  e
              }
              magicShow() {
                  this.item.length && Ol(this.item, null, {
                      interval: .2
                  })
              }
          }
      }, {
          namespace: "entrylist",
          assign: ".cw-entrylist",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.header = this.el.querySelector(".cw-entrylist-header"),
                  this.filter = this.el.querySelectorAll(".cw-entrylist-filter"),
                  this.items = this.el.querySelector(".cw-entrylist-items"),
                  this.item = Array.from(this.el.querySelectorAll(".cw-entrylist-item")),
                  this.empty = this.el.querySelectorAll(".cw-entrylist-empty")
              }
              onInit() {
                  try {
                      const e = this;
                      return e.bindFilters(),
                      e.handleEnter(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onEnter() {
                  try {
                      const e = this
                        , t = function() {
                          if (e.enterTl)
                              return Promise.resolve(e.enterTl.play(0)).then((function() {}
                              ))
                      }();
                      return Promise.resolve(t && t.then ? t.then((function() {}
                      )) : void 0)
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              bindFilters() {
                  this.filter.forEach((e => {
                      e.addEventListener("click", ( () => {
                          this.smoothChangeCategory(e.dataset.filterId),
                          this.filter.forEach((t => {
                              t.classList.toggle("-active", t === e)
                          }
                          ))
                      }
                      ))
                  }
                  ))
              }
              setCategoryFilter(e) {
                  this.item.forEach((t => {
                      t.toggleAttribute("hidden", !!e && e !== t.dataset.catId)
                  }
                  ))
              }
              smoothChangeCategory(e) {
                  this.stItemShow && this.stItemShow.forEach((e => {
                      e.kill()
                  }
                  )),
                  this.setCategoryFilter(e),
                  jn.killTweensOf(this.item),
                  jn.set(this.item, {
                      opacity: 1
                  })
              }
              handleEnter() {
                  this.enterTl = this.tlEnter()
              }
              tlEnter() {
                  const e = new jn.timeline({
                      paused: !0
                  });
                  return this.header && e.add(Pl(this.header.firstElementChild, {
                      stagger: .1
                  }), 0),
                  this.filter.length && e.fromTo(this.filter, {
                      y: window.innerWidth > 1e3 ? 50 : 30,
                      opacity: 0
                  }, {
                      y: 0,
                      opacity: 1,
                      ease: "power3.out",
                      duration: 1,
                      stagger: .04
                  }, .2),
                  this.item.length ? (jn.set(this.item, {
                      opacity: 0
                  }),
                  e.add(( () => this.magicShowItem()), .45)) : e.add(Ul(this.empty), .45),
                  e
              }
              magicShowItem() {
                  this.stItemShow = Ol(this.item)
              }
          }
      }, {
          namespace: "featured",
          assign: ".cw-featured",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.header = this.el.querySelector(".cw-featured-header"),
                  this.item = this.el.querySelectorAll(".cw-featured-item"),
                  this.fill = this.el.querySelector(".cw-featured-fill")
              }
              onInit() {
                  try {
                      const e = this;
                      return e.bindVideoPlay(),
                      e.magicShow(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              bindVideoPlay() {
                  Qa.isTouch || this.item.forEach((e => {
                      const t = e.querySelector("video");
                      t && (e.addEventListener("mouseenter", ( () => t.play())),
                      e.addEventListener("mouseleave", ( () => t.pause())))
                  }
                  ))
              }
              magicShow() {
                  this.header && Rl(this.header.firstElementChild, {
                      stagger: .2
                  }),
                  this.item.length && Ol(this.item)
              }
          }
      }, {
          namespace: "overview",
          assign: ".cw-overview",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.cursor = this.app.get("cursor"),
                  this.bg = this.el.querySelector(".cw-overview-bg"),
                  this.content = this.el.querySelector(".cw-overview-content"),
                  this.carousel = this.el.querySelector(".cw-overview-carousel"),
                  this.carouselItem = this.el.querySelectorAll(".cw-overview-carousel-item"),
                  this.header = this.el.querySelector(".cw-overview-header"),
                  this.icon = this.el.querySelector(".cw-overview-icon"),
                  this.caption = this.el.querySelectorAll(".cw-overview-caption"),
                  this.author = this.el.querySelector(".cw-overview-author"),
                  this.text = this.el.querySelector(".cw-overview-text"),
                  this.action = this.el.querySelector(".cw-overview-action"),
                  this.link = this.el.querySelectorAll(".cw-overview-link"),
                  this.counter = this.el.querySelectorAll(".cw-overview-counter"),
                  this.logo = this.el.querySelectorAll(".cw-overview-logo"),
                  this.initCarousel()
              }
              onInit() {
                  try {
                      const e = this;
                      return e.magicParallax(),
                      e.magicShow(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onDestroy() {
                  try {
                      const e = this;
                      return e.swiper && e.swiper.destroy(!0, !1),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              initCarousel() {
                  this.carousel && (this.swiper = new Hc(this.carousel,{
                      wrapperClass: "cw-overview-carousel-wrap",
                      slideClass: "cw-overview-carousel-item",
                      slidesPerView: 1,
                      speed: 1e3,
                      loop: !0,
                      grabCursor: !0,
                      touchStartPreventDefault: !1,
                      autoplay: {
                          delay: 5e3,
                          pauseOnMouseEnter: !0
                      }
                  }),
                  this.carouselItem.forEach((e => {
                      const t = e.querySelector(".cw-overview-text");
                      t && (t.addEventListener("click", (e => {
                          this.swiper.slideNext()
                      }
                      )),
                      this.cursor.follower && (t.addEventListener("mouseenter", ( () => {
                          this.cursor.follower.setIcon("long-arrow-right", "font-size:28px")
                      }
                      )),
                      t.addEventListener("mouseleave", ( () => {
                          this.cursor.follower.removeIcon()
                      }
                      ))))
                  }
                  )))
              }
              magicShow() {
                  var e, t, i;
                  this.header && Rl(this.header.firstElementChild),
                  this.icon && Il(this.icon),
                  this.caption.length && this.caption.forEach((e => {
                      Rl(e, {
                          stagger: .1
                      })
                  }
                  )),
                  this.author && Bl(this.author),
                  this.text && Rl(this.text),
                  this.action && Fl(this.action),
                  this.link.length && Bl(this.link, {
                      duration: .8,
                      stagger: .2
                  }),
                  this.counter.length && Fl(this.counter),
                  this.logo.length && (e = this.logo,
                  void 0 === t && (t = {}),
                  void 0 === i && (i = {}),
                  jn.set(e, {
                      opacity: 0
                  }),
                  Qa.refresh(),
                  Qa.batch(e, Cl({
                      onEnter: e => Ul(e, t),
                      once: !0
                  }, i)))
              }
              magicParallax() {
                  this.bg && Qa.create({
                      trigger: this.el,
                      animation: this.tlParallax(),
                      start: "top bottom",
                      end: "bottom top",
                      scrub: !0
                  })
              }
              tlParallax() {
                  const e = new jn.timeline;
                  return this.bg && e.fromTo(this.bg, {
                      yPercent: -30
                  }, {
                      yPercent: 30,
                      ease: "none"
                  }, 0),
                  e
              }
          }
      }, {
          namespace: "splitshow",
          assign: ".cw-splitshow",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.item = this.el.querySelectorAll(".cw-splitshow-item")
              }
              onInit() {
                  try {
                      return this.magicItems(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              magicItems() {
                  this.item.forEach((e => {
                      const t = e.querySelector(".cw-splitshow-preview").querySelector(".cw-splitshow-preview-media")
                        , i = e.querySelector(".cw-splitshow-caption");
                      Qa.create({
                          trigger: e,
                          animation: this.tlShow(t, i),
                          once: !0
                      }),
                      Qa.create({
                          trigger: e,
                          animation: this.tlParallax(t),
                          start: "top bottom",
                          end: "bottom top",
                          scrub: !0
                      })
                  }
                  ))
              }
              tlShow(e, t) {
                  const i = new jn.timeline;
                  return jn.set(e, {
                      opacity: 0
                  }),
                  i.to(e, {
                      opacity: 1,
                      duration: 1
                  }),
                  i
              }
              tlParallax(e) {
                  const t = new jn.timeline;
                  return jn.set(e, {
                      scale: 1.05
                  }),
                  t.fromTo(e, {
                      y: "-10%"
                  }, {
                      y: "10%",
                      ease: "none"
                  }),
                  t
              }
          }
      }, {
          namespace: "summary",
          assign: ".cw-summary",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.header = this.el.querySelector(".cw-summary-header"),
                  this.text = this.el.querySelector(".cw-summary-text"),
                  this.figure = this.el.querySelector(".cw-summary-figure"),
                  this.carousel = this.el.querySelector(".cw-summary-carousel"),
                  this.entry = this.el.querySelectorAll(".cw-summary-entry"),
                  this.more = this.el.querySelector(".cw-summary-more"),
                  this.actionBtn = this.el.querySelector(".cw-summary-action a"),
                  this.initCarousel()
              }
              onInit() {
                  try {
                      return this.magicShow(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onDestroy() {
                  try {
                      const e = this;
                      return e.swiper && e.sb.destroy(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              initCarousel() {
                  this.carousel && (this.sb = new $c({
                      viewport: this.carousel,
                      scrollMode: "transform",
                      direction: "horizontal",
                      lockScrollOnDragDirection: "horizontal"
                  }))
              }
              magicShow() {
                  this.figure && Il(this.figure, {
                      from: .5
                  }),
                  this.header && Rl(this.header.firstElementChild, {
                      stagger: .2
                  }),
                  this.text && Rl(this.text),
                  this.entry.length && Bl(this.entry, {
                      duration: 1
                  }),
                  this.more && Fl(this.more),
                  this.actionBtn && kl(this.actionBtn)
              }
          }
      }, {
          namespace: "screenshot",
          assign: ".cw-screenshot",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.preview = this.el.querySelector(".cw-screenshot-preview"),
                  this.previewMedia = this.preview.querySelector(".cw-screenshot-preview-media")
              }
              onInit() {
                  try {
                      const e = this;
                      return e.magicShow(),
                      e.magicParallax(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              magicShow() {
                  Qa.create({
                      trigger: this.el,
                      animation: this.tlShow(),
                      once: !0
                  })
              }
              tlShow() {
                  const e = new jn.timeline;
                  return jn.set(this.previewMedia, {
                      opacity: 0
                  }),
                  e.to(this.previewMedia, {
                      opacity: 1,
                      duration: 1
                  }),
                  e
              }
              magicParallax() {
                  Qa.create({
                      trigger: this.el,
                      animation: this.tlParallax(),
                      start: "top bottom",
                      end: "bottom top",
                      scrub: !0
                  })
              }
              tlParallax() {
                  const e = new jn.timeline;
                  return jn.set(this.previewMedia, {
                      scale: 1.05
                  }),
                  e.fromTo(this.previewMedia, {
                      y: "-10%"
                  }, {
                      y: "10%",
                      ease: "none"
                  }),
                  e
              }
          }
      }, {
          namespace: "nextcase",
          assign: ".cw-nextcase",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.reel = this.el.querySelector(".cw-nextcase-reel"),
                  this.initReeller()
              }
              onDestroy() {
                  try {
                      return this.reeller.destroy(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              initReeller() {
                  this.reeller = new Yc({
                      container: this.reel,
                      wrapper: ".cw-nextcase-reel-items",
                      itemSelector: ".cw-nextcase-reel-item",
                      speed: 15,
                      plugins: {
                          scroller: {
                              multiplier: .3,
                              speed: 1,
                              threshold: 1,
                              reversed: !0
                          }
                      }
                  })
              }
          }
      }, {
          namespace: "smfeed",
          assign: ".cw-smfeed",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.reel = this.el.querySelector(".cw-smfeed-reel"),
                  this.carousel = this.el.querySelector(".cw-smfeed-carousel"),
                  this.item = this.el.querySelectorAll(".cw-smfeed-item")
              }
              onInit() {
                  try {
                      const e = this;
                      return e.initReeller(),
                      e.initCarousel(),
                      e.magicShow(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onDestroy() {
                  try {
                      const e = this;
                      return e.sb && e.sb.destroy(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              initCarousel() {
                  this.carousel && (this.sb = new $c({
                      viewport: this.carousel,
                      scrollMode: "transform",
                      direction: "horizontal",
                      lockScrollOnDragDirection: "horizontal"
                  }))
              }
              initReeller() {
                  this.reel && (this.reeller = new Yc({
                      container: this.reel,
                      wrapper: ".cw-smfeed-reel-wrap",
                      itemSelector: ".cw-smfeed-reel-item",
                      speed: 20,
                      plugins: {
                          scroller: {
                              multiplier: .3,
                              speed: 1,
                              threshold: 1,
                              reversed: !0
                          }
                      }
                  }))
              }
              magicShow() {
                  this.item.length && Bl(this.item, {
                      duration: 1
                  })
              }
          }
      }, {
          namespace: "outro",
          assign: ".cw-outro",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.reel = this.el.querySelector(".cw-outro-reel"),
                  this.header = this.el.querySelector(".cw-outro-header"),
                  this.caption = this.el.querySelector(".cw-outro-caption"),
                  this.social = this.el.querySelectorAll(".cw-outro-social"),
                  this.location = this.el.querySelectorAll(".cw-outro-location"),
                  this.initReeller()
              }
              onInit() {
                  try {
                      return this.magicShow(),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              initReeller() {
                  new Yc({
                      container: this.reel,
                      wrapper: ".cw-outro-reel-wrap",
                      itemSelector: ".cw-outro-reel-item",
                      speed: 10,
                      plugins: {
                          scroller: {
                              multiplier: .3,
                              speed: 1,
                              threshold: 1,
                              reversed: !0
                          }
                      }
                  }),
                  Qa.isTouch || this.social.forEach((e => {
                      const t = e.querySelector(".cw-outro-social-reel")
                        , i = new Yc({
                          container: t,
                          wrapper: ".cw-outro-social-reel-wrap",
                          itemSelector: ".cw-outro-social-reel-item",
                          autoStop: !1,
                          speed: 3
                      });
                      e.addEventListener("mouseenter", ( () => i.reverse())),
                      e.addEventListener("mouseleave", ( () => i.pause()))
                  }
                  ))
              }
              magicShow() {
                  this.caption && Rl(this.caption, {
                      stagger: .1
                  }),
                  this.social.length && this.social.forEach((e => {
                      Qa.create({
                          trigger: e,
                          start: "center bottom",
                          animation: this.tlShowSocialItem(e),
                          once: !0
                      })
                  }
                  )),
                  this.location.length && this.location.forEach((e => {
                      Qa.create({
                          trigger: e,
                          start: "center bottom",
                          animation: this.tlShowLocationItem(e),
                          once: !0
                      })
                  }
                  ))
              }
              tlShowSocialItem(e) {
                  const t = new jn.timeline
                    , i = e.querySelector(".cw-outro-social-title")
                    , n = e.querySelector(".cw-outro-social-divider")
                    , r = e.querySelector(".cw-outro-social-arr");
                  return jn.set(n, {
                      scaleX: 0,
                      transformOrigin: "left center"
                  }),
                  t.to(n, {
                      scaleX: 1,
                      duration: 3,
                      stagger: .3,
                      ease: "expo.out"
                  }, 0),
                  t.add(Pl(i, {
                      duration: 2.5
                  }), 0),
                  t.add(Ll(r), .5),
                  t
              }
              tlShowLocationItem(e) {
                  const t = new jn.timeline
                    , i = e.querySelector(".cw-outro-location-caption")
                    , n = e.querySelector(".cw-outro-location-address")
                    , r = e.querySelector(".cw-outro-location-action");
                  return t.add(Ul(i), 0),
                  t.add(Pl(n), .2),
                  t.add(Nl(r), .4),
                  t
              }
          }
      }, {
          namespace: "footer",
          assign: ".cw-footer",
          component: class extends i {
              constructor() {
                  super(...arguments),
                  this.header = this.el.querySelector(".cw-footer-header"),
                  this.bgMedia = this.el.querySelector(".cw-footer-bg-media"),
                  this.bgVideo = this.bgMedia.querySelector("video"),
                  this.action = this.el.querySelector(".cw-footer-action"),
                  this.actionBtn = this.action.querySelector("a"),
                  this.tag = this.el.querySelectorAll(".cw-footer-tag"),
                  this.link = this.el.querySelectorAll(".cw-footer-link"),
                  this.sceneVisible = !1
              }
              onInit() {
                  try {
                      const e = this;
                      return Promise.resolve(e.loadScene()).then((function() {
                          e.magicShow()
                      }
                      ))
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              onLeave() {
                  try {
                      const e = this;
                      return Qa.isTouch || (e.sceneVisible = !1,
                      e.bgVideo.pause(),
                      e.renderFn && jn.ticker.remove(e.renderFn),
                      e.resizeFn && window.removeEventListener("resize", e.resizeFn)),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              loadScene() {
                  try {
                      const e = this;
                      return Qa.isTouch || (e.bgVideo.style.display = "none",
                      e.bgVideo.pause(),
                      e.observer = new IntersectionObserver((t => {
                          try {
                              t[0].isIntersecting ? (e.sceneVisible = !0,
                              e.bgVideo.play()) : (e.sceneVisible = !1,
                              e.bgVideo.pause())
                          } finally {}
                      }
                      )),
                      e.observer.observe(e.el),
                      e.sceneTexture = new Vv(e.bgVideo),
                      e.sceneTexture.minFilter = 1006,
                      e.sceneTexture.magFilter = 1006,
                      e.sceneMaterial = new Kp({
                          map: e.sceneTexture
                      }),
                      e.sceneGeometry = new em(1600,900,1,1),
                      e.scenePlane = new Cf(e.sceneGeometry,e.sceneMaterial),
                      e.scenePlane.z = 0,
                      e.sceneFov = 45,
                      e.sceneCamera = new kf(e.sceneFov,e.bgMedia.offsetWidth / e.bgMedia.offsetHeight,20,3e3),
                      e.sceneCamera.position.z = 970,
                      e.sceneMain = new kv,
                      e.sceneMain.add(e.scenePlane),
                      e.sceneRenderer = new zv({
                          antialias: !1,
                          alpha: !1,
                          powerPreference: "high-performance"
                      }),
                      e.sceneRenderer.setSize(e.bgMedia.offsetWidth, e.bgMedia.offsetHeight),
                      e.bgMedia.appendChild(e.sceneRenderer.domElement),
                      e.sceneComposer = new v_(e.sceneRenderer),
                      e.sceneRenderPass = new __(e.sceneMain,e.sceneCamera),
                      e.sceneBadTVPass = new f_(y_),
                      e.sceneStaticPass = new f_(x_),
                      e.sceneComposer.addPass(e.sceneRenderPass),
                      e.sceneComposer.addPass(e.sceneBadTVPass),
                      e.sceneComposer.addPass(e.sceneStaticPass),
                      e.sceneBadTVPass.uniforms.distortion.value = 0,
                      e.sceneBadTVPass.uniforms.distortion2.value = 0,
                      e.sceneBadTVPass.uniforms.speed.value = .22,
                      e.sceneBadTVPass.uniforms.rollSpeed.value = 0,
                      e.sceneStaticPass.uniforms.amount.value = .03,
                      e.sceneStaticPass.uniforms.size.value = 1.5,
                      e.renderFn = t => {
                          e.sceneVisible && (e.sceneComposer.render(t),
                          e.sceneBadTVPass.uniforms.time.value = t,
                          e.sceneStaticPass.uniforms.time.value = t)
                      }
                      ,
                      jn.ticker.add(e.renderFn),
                      e.resizeFn = () => {
                          if (e.sceneRenderer.setSize(e.bgMedia.offsetWidth, e.bgMedia.offsetHeight),
                          e.sceneCamera.aspect = e.bgMedia.offsetWidth / e.bgMedia.offsetHeight,
                          e.sceneCamera.updateProjectionMatrix(),
                          e.sceneCamera.aspect > 16 / 9) {
                              const t = Math.tan(e.sceneFov / 2 * o_)
                                , i = e.sceneCamera.aspect / (16 / 9);
                              e.sceneCamera.fov = 2 * (Math.atan(t / i) * l_)
                          } else
                              e.sceneCamera.fov = e.sceneFov
                      }
                      ,
                      window.addEventListener("resize", e.resizeFn),
                      e.actionBtn.addEventListener("mouseenter", ( () => {
                          jn.to(e.sceneBadTVPass.uniforms.distortion, {
                              value: 5,
                              duration: .5
                          }),
                          jn.to(e.sceneStaticPass.uniforms.amount, {
                              value: .15,
                              duration: .5
                          })
                      }
                      )),
                      e.actionBtn.addEventListener("mouseleave", ( () => {
                          jn.to(e.sceneBadTVPass.uniforms.distortion, {
                              value: 0,
                              duration: .5
                          }),
                          jn.to(e.sceneStaticPass.uniforms.amount, {
                              value: .03,
                              duration: .5
                          })
                      }
                      ))),
                      Promise.resolve()
                  } catch (e) {
                      return Promise.reject(e)
                  }
              }
              magicShow() {
                  this.header && Rl(this.header.firstElementChild, {
                      type: "lines",
                      stagger: .3
                  }),
                  this.actionBtn && kl(this.actionBtn),
                  this.tag.length && this.link.length && Bl([this.tag, this.link])
              }
          }
      }]
  });
  window.app = S_,
  window.addEventListener("pagehide", ( () => window.scrollTo(0, 0)))
}
)();
